
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model activations
 * 
 */
export type activations = {
  id: number
  user_id: number
  code: string
  completed: boolean
  completed_at: Date | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model activity_log
 * 
 */
export type activity_log = {
  id: number
  log_name: string | null
  description: string
  subject_id: number | null
  subject_type: string | null
  causer_id: number | null
  causer_type: string | null
  properties: string | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model airlines
 * 
 */
export type airlines = {
  id: number
  name: string | null
  alias: string | null
  iata: string | null
  icao: string | null
  callsign: string | null
  country: string | null
  active: string | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model airport_services
 * 
 */
export type airport_services = {
  id: number
  name: string
  description: string | null
  pickup_dropoff: boolean
  pickup_date_time: Date
  num_passengers: number
  pickup_from: string
  dropoff_location: string
  airline: string | null
  flight_number: string | null
  status: boolean
  pick_up_lat: string
  drop_off_lat: string
  pick_up_lon: string
  drop_off_lon: string
  service_id: number
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model airports
 * 
 */
export type airports = {
  id: number
  name: string | null
  city: string | null
  country: string | null
  iata: string | null
  icao: string | null
  latitude: string | null
  longitude: string | null
  altitude: string | null
  timezone: string | null
  dst: string | null
  tz_database_time_zone: string | null
  Type: string | null
  Source: string | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model blog_categories
 * 
 */
export type blog_categories = {
  id: number
  title: string
  created_at: Date | null
  updated_at: Date | null
  deleted_at: Date | null
}

/**
 * Model blog_comments
 * 
 */
export type blog_comments = {
  id: number
  blog_id: number
  name: string
  email: string
  website: string | null
  comment: string
  created_at: Date | null
  updated_at: Date | null
  deleted_at: Date | null
}

/**
 * Model blogs
 * 
 */
export type blogs = {
  id: number
  blog_category_id: number
  user_id: number
  title: string
  slug: string | null
  content: string
  image: string | null
  views: number
  created_at: Date | null
  updated_at: Date | null
  deleted_at: Date | null
}

/**
 * Model body_types
 * 
 */
export type body_types = {
  id: number
  body_type: string | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model car_features
 * 
 */
export type car_features = {
  id: number
  car_id: number
  feature_id: number
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model car_price_types
 * 
 */
export type car_price_types = {
  id: number
  name: string | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model car_prices
 * 
 */
export type car_prices = {
  id: number
  car_id: number
  car_price_type_id: number
  monday: number | null
  tuesday: number | null
  wednesday: number | null
  thursday: number | null
  friday: number | null
  saturday: number | null
  sunday: number | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model cars
 * 
 */
export type cars = {
  id: number
  body_type_id: number
  transmission_id: number
  manufacturer_id: number
  driver_id: number
  fuel_id: number
  vehicle_type_id: number
  car_model: string | null
  name: string | null
  qty: string | null
  passenger_seats: number | null
  maximum_luggage: number | null
  total_doors: number | null
  child_seat: number | null
  image: string | null
  status: boolean | null
  per_mile_rate: number | null
  hourly_rate: number | null
  minimum_fare: number | null
  minimum_hours: number | null
  fixed_price: number | null
  is_slab_enabled: boolean | null
  is_loc_enabled: boolean | null
  created_at: Date | null
  updated_at: Date | null
  isActive: boolean | null
  car_type: cars_car_type | null
}

/**
 * Model city_tours
 * 
 */
export type city_tours = {
  id: number
  city_name: string
  pick_up_location: string
  Created_on: Date
}

/**
 * Model countries
 * 
 */
export type countries = {
  id: number
  sortname: string
  name: string
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model coupons
 * 
 */
export type coupons = {
  id: number
  coupon_name: string | null
  percentage: number | null
  price: number | null
  status: boolean
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model datatables
 * 
 */
export type datatables = {
  id: number
  firstname: string | null
  lastname: string | null
  email: string | null
  points: string | null
  notes: string | null
  created_at: Date | null
  updated_at: Date | null
  age: number | null
  job: string | null
  gender: string | null
  country: string | null
  sale_date: string | null
}

/**
 * Model drivers
 * 
 */
export type drivers = {
  id: number
  name: string | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model features
 * 
 */
export type features = {
  id: number
  feature: string | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model files
 * 
 */
export type files = {
  id: number
  filename: string
  mime: string
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model fuel_types
 * 
 */
export type fuel_types = {
  id: number
  fuel_type: string | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model gratuities
 * 
 */
export type gratuities = {
  id: number
  percentage: number | null
  status: boolean | null
  name: string | null
  price: number
  service_id: number
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model hourly_services
 * 
 */
export type hourly_services = {
  id: number
  name: string
  description: string | null
  pickup_location: string
  pickup_date_time: Date
  num_passengers: number
  num_service_hours: number
  dropoff_location: string
  add_another_stop: boolean
  additional_comments: string | null
  status: boolean
  service_id: number
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model locations
 * 
 */
export type locations = {
  id: number
  title: string | null
  pickup_location: string | null
  pickup_lat: string | null
  pickup_lng: string | null
  dropoff_location: string | null
  dropoff_lat: string | null
  dropoff_lng: string | null
  fee: number | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model manufacturers
 * 
 */
export type manufacturers = {
  id: number
  Manufacturer: string | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model migrations
 * 
 */
export type migrations = {
  id: number
  migration: string
  batch: number
}

/**
 * Model package_types
 * 
 */
export type package_types = {
  id: number
  name: string
  password: string
  Created_on: Date
}

/**
 * Model persistences
 * 
 */
export type persistences = {
  id: number
  user_id: number
  code: string
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model point_to_point_services
 * 
 */
export type point_to_point_services = {
  id: number
  name: string
  description: string | null
  pickup_location: string
  pickup_date_time: Date
  num_passengers: number
  dropoff_location: string
  add_another_stop: boolean
  additional_comments: string | null
  status: boolean
  pick_up_lat: string
  pick_up_lon: string
  drop_off_lat: string
  drop_off_lon: string
  service_id: number
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model reminders
 * 
 */
export type reminders = {
  id: number
  user_id: number
  code: string
  completed: boolean
  completed_at: Date | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model reservations
 * 
 */
export type reservations = {
  id: number
  order_number: string | null
  service_id: number
  car_id: number
  pick_up_postal_code: string | null
  pick_up_lat: number | null
  pick_up_lon: number | null
  pick_up_loc_name: string | null
  drop_off_postal_code: string | null
  drop_off_lat: number | null
  drop_off_lon: number | null
  drop_off_loc_name: string | null
  pick_up_date: Date | null
  price: number | null
  tax: number | null
  airline: string | null
  flight_no: string | null
  no_of_hours: number | null
  maximum_passenger: number | null
  maximum_luggage: number | null
  customer_first_name: string | null
  customer_last_name: string | null
  customer_cnic: string | null
  customer_email: string | null
  customer_phone: string | null
  created_at: Date | null
  updated_at: Date | null
  uuid: string
  payment_method: string | null
  isPaid: number | null
  special_instruction: string | null
}

/**
 * Model role_users
 * 
 */
export type role_users = {
  user_id: number
  role_id: number
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model roles
 * 
 */
export type roles = {
  id: number
  slug: string
  name: string
  permissions: string | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model services
 * 
 */
export type services = {
  id: number
  Name: string | null
  Status: string | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model sys_settings
 * 
 */
export type sys_settings = {
  id: number
  sys_name: string
  sys_details: string
  Created_on: Date
  setting_key: string
}

/**
 * Model taggable_tags
 * 
 */
export type taggable_tags = {
  tag_id: number
  name: string
  normalized: string
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model tasks
 * 
 */
export type tasks = {
  id: number
  user_id: number
  finished: number
  task_description: string
  task_deadline: Date
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model throttle
 * 
 */
export type throttle = {
  id: number
  user_id: number | null
  type: string
  ip: string | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model tours
 * 
 */
export type tours = {
  id: number
  title: string | null
  pickup_location: string | null
  pickup_lat: number | null
  pickup_lng: number | null
  dropoff_location: string | null
  dropoff_lat: number | null
  dropoff_lng: number | null
  price_per_passenger: number | null
  status: Buffer | null
  created_at: Date | null
  updated_at: Date | null
  isActive: boolean | null
  car_id: number | null
  description: string | null
  luggage: number | null
}

/**
 * Model transmissions
 * 
 */
export type transmissions = {
  id: number
  transmission: string | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model users
 * 
 */
export type users = {
  id: number
  email: string
  password: string
  permissions: string | null
  last_login: Date | null
  first_name: string | null
  last_name: string | null
  bio: string | null
  gender: string | null
  dob: Date | null
  pic: string | null
  country: string | null
  state: string | null
  city: string | null
  address: string | null
  postal: string | null
  status: boolean | null
  reset_token: string | null
  token_expired_at: Date | null
  created_at: Date | null
  updated_at: Date | null
  deleted_at: Date | null
}

/**
 * Model location_exceptions
 * 
 */
export type location_exceptions = {
  id: number
  pick_up_loc_name: string | null
  pick_up_postal_code: string
  drop_off_loc_name: string | null
  drop_off_postal_code: string
  price: number
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model package_serivce
 * 
 */
export type package_serivce = {
  id: number
  name: string | null
  description: string | null
  passenger_capacity: number
  price: number
  created_at: Date | null
  updated_at: Date | null
  car_id: number
  isActive: boolean | null
  pickup_location: string | null
  pickup_lat: number | null
  pickup_lng: number | null
  dropoff_location: string | null
  dropoff_lat: number | null
  dropoff_lng: number | null
  luggage: number | null
}

/**
 * Model slabs
 * 
 */
export type slabs = {
  id: number
  car_id: number
  initial_distance: number
  final_distance: number
  price: number
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model timeslots
 * 
 */
export type timeslots = {
  id: number
  time: Date | null
  isActive: boolean | null
  sub_service_id: number | null
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model vehicle_types
 * 
 */
export type vehicle_types = {
  id: number
  name: string
  created_at: Date | null
  updated_at: Date | null
}

/**
 * Model sub_services
 * 
 */
export type sub_services = {
  id: number
  name: string | null
  pickup_location: string | null
  pickup_lat: number | null
  pickup_lng: number | null
  dropoff_location: string | null
  dropoff_lat: number | null
  dropoff_lng: number | null
  price_per_passenger: number | null
  status: Buffer | null
  created_at: Date | null
  updated_at: Date | null
  isActive: boolean | null
  car_id: number | null
  service_id: number
  description: string | null
  luggage: number | null
  passenger_capacity: number | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const cars_car_type: {
  Other: 'Other',
  Tour: 'Tour',
  Package: 'Package'
};

export type cars_car_type = (typeof cars_car_type)[keyof typeof cars_car_type]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Activations
 * const activations = await prisma.activations.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Activations
   * const activations = await prisma.activations.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.activations`: Exposes CRUD operations for the **activations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activations
    * const activations = await prisma.activations.findMany()
    * ```
    */
  get activations(): Prisma.activationsDelegate<GlobalReject>;

  /**
   * `prisma.activity_log`: Exposes CRUD operations for the **activity_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activity_logs
    * const activity_logs = await prisma.activity_log.findMany()
    * ```
    */
  get activity_log(): Prisma.activity_logDelegate<GlobalReject>;

  /**
   * `prisma.airlines`: Exposes CRUD operations for the **airlines** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Airlines
    * const airlines = await prisma.airlines.findMany()
    * ```
    */
  get airlines(): Prisma.airlinesDelegate<GlobalReject>;

  /**
   * `prisma.airport_services`: Exposes CRUD operations for the **airport_services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Airport_services
    * const airport_services = await prisma.airport_services.findMany()
    * ```
    */
  get airport_services(): Prisma.airport_servicesDelegate<GlobalReject>;

  /**
   * `prisma.airports`: Exposes CRUD operations for the **airports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Airports
    * const airports = await prisma.airports.findMany()
    * ```
    */
  get airports(): Prisma.airportsDelegate<GlobalReject>;

  /**
   * `prisma.blog_categories`: Exposes CRUD operations for the **blog_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blog_categories
    * const blog_categories = await prisma.blog_categories.findMany()
    * ```
    */
  get blog_categories(): Prisma.blog_categoriesDelegate<GlobalReject>;

  /**
   * `prisma.blog_comments`: Exposes CRUD operations for the **blog_comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blog_comments
    * const blog_comments = await prisma.blog_comments.findMany()
    * ```
    */
  get blog_comments(): Prisma.blog_commentsDelegate<GlobalReject>;

  /**
   * `prisma.blogs`: Exposes CRUD operations for the **blogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blogs.findMany()
    * ```
    */
  get blogs(): Prisma.blogsDelegate<GlobalReject>;

  /**
   * `prisma.body_types`: Exposes CRUD operations for the **body_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Body_types
    * const body_types = await prisma.body_types.findMany()
    * ```
    */
  get body_types(): Prisma.body_typesDelegate<GlobalReject>;

  /**
   * `prisma.car_features`: Exposes CRUD operations for the **car_features** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Car_features
    * const car_features = await prisma.car_features.findMany()
    * ```
    */
  get car_features(): Prisma.car_featuresDelegate<GlobalReject>;

  /**
   * `prisma.car_price_types`: Exposes CRUD operations for the **car_price_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Car_price_types
    * const car_price_types = await prisma.car_price_types.findMany()
    * ```
    */
  get car_price_types(): Prisma.car_price_typesDelegate<GlobalReject>;

  /**
   * `prisma.car_prices`: Exposes CRUD operations for the **car_prices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Car_prices
    * const car_prices = await prisma.car_prices.findMany()
    * ```
    */
  get car_prices(): Prisma.car_pricesDelegate<GlobalReject>;

  /**
   * `prisma.cars`: Exposes CRUD operations for the **cars** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cars
    * const cars = await prisma.cars.findMany()
    * ```
    */
  get cars(): Prisma.carsDelegate<GlobalReject>;

  /**
   * `prisma.city_tours`: Exposes CRUD operations for the **city_tours** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more City_tours
    * const city_tours = await prisma.city_tours.findMany()
    * ```
    */
  get city_tours(): Prisma.city_toursDelegate<GlobalReject>;

  /**
   * `prisma.countries`: Exposes CRUD operations for the **countries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.countries.findMany()
    * ```
    */
  get countries(): Prisma.countriesDelegate<GlobalReject>;

  /**
   * `prisma.coupons`: Exposes CRUD operations for the **coupons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupons.findMany()
    * ```
    */
  get coupons(): Prisma.couponsDelegate<GlobalReject>;

  /**
   * `prisma.datatables`: Exposes CRUD operations for the **datatables** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Datatables
    * const datatables = await prisma.datatables.findMany()
    * ```
    */
  get datatables(): Prisma.datatablesDelegate<GlobalReject>;

  /**
   * `prisma.drivers`: Exposes CRUD operations for the **drivers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.drivers.findMany()
    * ```
    */
  get drivers(): Prisma.driversDelegate<GlobalReject>;

  /**
   * `prisma.features`: Exposes CRUD operations for the **features** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Features
    * const features = await prisma.features.findMany()
    * ```
    */
  get features(): Prisma.featuresDelegate<GlobalReject>;

  /**
   * `prisma.files`: Exposes CRUD operations for the **files** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.files.findMany()
    * ```
    */
  get files(): Prisma.filesDelegate<GlobalReject>;

  /**
   * `prisma.fuel_types`: Exposes CRUD operations for the **fuel_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fuel_types
    * const fuel_types = await prisma.fuel_types.findMany()
    * ```
    */
  get fuel_types(): Prisma.fuel_typesDelegate<GlobalReject>;

  /**
   * `prisma.gratuities`: Exposes CRUD operations for the **gratuities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gratuities
    * const gratuities = await prisma.gratuities.findMany()
    * ```
    */
  get gratuities(): Prisma.gratuitiesDelegate<GlobalReject>;

  /**
   * `prisma.hourly_services`: Exposes CRUD operations for the **hourly_services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hourly_services
    * const hourly_services = await prisma.hourly_services.findMany()
    * ```
    */
  get hourly_services(): Prisma.hourly_servicesDelegate<GlobalReject>;

  /**
   * `prisma.locations`: Exposes CRUD operations for the **locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.locations.findMany()
    * ```
    */
  get locations(): Prisma.locationsDelegate<GlobalReject>;

  /**
   * `prisma.manufacturers`: Exposes CRUD operations for the **manufacturers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Manufacturers
    * const manufacturers = await prisma.manufacturers.findMany()
    * ```
    */
  get manufacturers(): Prisma.manufacturersDelegate<GlobalReject>;

  /**
   * `prisma.migrations`: Exposes CRUD operations for the **migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migrations
    * const migrations = await prisma.migrations.findMany()
    * ```
    */
  get migrations(): Prisma.migrationsDelegate<GlobalReject>;

  /**
   * `prisma.package_types`: Exposes CRUD operations for the **package_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Package_types
    * const package_types = await prisma.package_types.findMany()
    * ```
    */
  get package_types(): Prisma.package_typesDelegate<GlobalReject>;

  /**
   * `prisma.persistences`: Exposes CRUD operations for the **persistences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Persistences
    * const persistences = await prisma.persistences.findMany()
    * ```
    */
  get persistences(): Prisma.persistencesDelegate<GlobalReject>;

  /**
   * `prisma.point_to_point_services`: Exposes CRUD operations for the **point_to_point_services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Point_to_point_services
    * const point_to_point_services = await prisma.point_to_point_services.findMany()
    * ```
    */
  get point_to_point_services(): Prisma.point_to_point_servicesDelegate<GlobalReject>;

  /**
   * `prisma.reminders`: Exposes CRUD operations for the **reminders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reminders
    * const reminders = await prisma.reminders.findMany()
    * ```
    */
  get reminders(): Prisma.remindersDelegate<GlobalReject>;

  /**
   * `prisma.reservations`: Exposes CRUD operations for the **reservations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservations.findMany()
    * ```
    */
  get reservations(): Prisma.reservationsDelegate<GlobalReject>;

  /**
   * `prisma.role_users`: Exposes CRUD operations for the **role_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Role_users
    * const role_users = await prisma.role_users.findMany()
    * ```
    */
  get role_users(): Prisma.role_usersDelegate<GlobalReject>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<GlobalReject>;

  /**
   * `prisma.services`: Exposes CRUD operations for the **services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.services.findMany()
    * ```
    */
  get services(): Prisma.servicesDelegate<GlobalReject>;

  /**
   * `prisma.sys_settings`: Exposes CRUD operations for the **sys_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sys_settings
    * const sys_settings = await prisma.sys_settings.findMany()
    * ```
    */
  get sys_settings(): Prisma.sys_settingsDelegate<GlobalReject>;

  /**
   * `prisma.taggable_tags`: Exposes CRUD operations for the **taggable_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Taggable_tags
    * const taggable_tags = await prisma.taggable_tags.findMany()
    * ```
    */
  get taggable_tags(): Prisma.taggable_tagsDelegate<GlobalReject>;

  /**
   * `prisma.tasks`: Exposes CRUD operations for the **tasks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.tasks.findMany()
    * ```
    */
  get tasks(): Prisma.tasksDelegate<GlobalReject>;

  /**
   * `prisma.throttle`: Exposes CRUD operations for the **throttle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Throttles
    * const throttles = await prisma.throttle.findMany()
    * ```
    */
  get throttle(): Prisma.throttleDelegate<GlobalReject>;

  /**
   * `prisma.tours`: Exposes CRUD operations for the **tours** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tours
    * const tours = await prisma.tours.findMany()
    * ```
    */
  get tours(): Prisma.toursDelegate<GlobalReject>;

  /**
   * `prisma.transmissions`: Exposes CRUD operations for the **transmissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transmissions
    * const transmissions = await prisma.transmissions.findMany()
    * ```
    */
  get transmissions(): Prisma.transmissionsDelegate<GlobalReject>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<GlobalReject>;

  /**
   * `prisma.location_exceptions`: Exposes CRUD operations for the **location_exceptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Location_exceptions
    * const location_exceptions = await prisma.location_exceptions.findMany()
    * ```
    */
  get location_exceptions(): Prisma.location_exceptionsDelegate<GlobalReject>;

  /**
   * `prisma.package_serivce`: Exposes CRUD operations for the **package_serivce** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Package_serivces
    * const package_serivces = await prisma.package_serivce.findMany()
    * ```
    */
  get package_serivce(): Prisma.package_serivceDelegate<GlobalReject>;

  /**
   * `prisma.slabs`: Exposes CRUD operations for the **slabs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Slabs
    * const slabs = await prisma.slabs.findMany()
    * ```
    */
  get slabs(): Prisma.slabsDelegate<GlobalReject>;

  /**
   * `prisma.timeslots`: Exposes CRUD operations for the **timeslots** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Timeslots
    * const timeslots = await prisma.timeslots.findMany()
    * ```
    */
  get timeslots(): Prisma.timeslotsDelegate<GlobalReject>;

  /**
   * `prisma.vehicle_types`: Exposes CRUD operations for the **vehicle_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_types
    * const vehicle_types = await prisma.vehicle_types.findMany()
    * ```
    */
  get vehicle_types(): Prisma.vehicle_typesDelegate<GlobalReject>;

  /**
   * `prisma.sub_services`: Exposes CRUD operations for the **sub_services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sub_services
    * const sub_services = await prisma.sub_services.findMany()
    * ```
    */
  get sub_services(): Prisma.sub_servicesDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.11.0
   * Query Engine version: 8fde8fef4033376662cad983758335009d522acb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    activations: 'activations',
    activity_log: 'activity_log',
    airlines: 'airlines',
    airport_services: 'airport_services',
    airports: 'airports',
    blog_categories: 'blog_categories',
    blog_comments: 'blog_comments',
    blogs: 'blogs',
    body_types: 'body_types',
    car_features: 'car_features',
    car_price_types: 'car_price_types',
    car_prices: 'car_prices',
    cars: 'cars',
    city_tours: 'city_tours',
    countries: 'countries',
    coupons: 'coupons',
    datatables: 'datatables',
    drivers: 'drivers',
    features: 'features',
    files: 'files',
    fuel_types: 'fuel_types',
    gratuities: 'gratuities',
    hourly_services: 'hourly_services',
    locations: 'locations',
    manufacturers: 'manufacturers',
    migrations: 'migrations',
    package_types: 'package_types',
    persistences: 'persistences',
    point_to_point_services: 'point_to_point_services',
    reminders: 'reminders',
    reservations: 'reservations',
    role_users: 'role_users',
    roles: 'roles',
    services: 'services',
    sys_settings: 'sys_settings',
    taggable_tags: 'taggable_tags',
    tasks: 'tasks',
    throttle: 'throttle',
    tours: 'tours',
    transmissions: 'transmissions',
    users: 'users',
    location_exceptions: 'location_exceptions',
    package_serivce: 'package_serivce',
    slabs: 'slabs',
    timeslots: 'timeslots',
    vehicle_types: 'vehicle_types',
    sub_services: 'sub_services'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Body_typesCountOutputType
   */


  export type Body_typesCountOutputType = {
    cars: number
  }

  export type Body_typesCountOutputTypeSelect = {
    cars?: boolean
  }

  export type Body_typesCountOutputTypeGetPayload<S extends boolean | null | undefined | Body_typesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Body_typesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Body_typesCountOutputTypeArgs)
    ? Body_typesCountOutputType 
    : S extends { select: any } & (Body_typesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Body_typesCountOutputType ? Body_typesCountOutputType[P] : never
  } 
      : Body_typesCountOutputType




  // Custom InputTypes

  /**
   * Body_typesCountOutputType without action
   */
  export type Body_typesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Body_typesCountOutputType
     */
    select?: Body_typesCountOutputTypeSelect | null
  }



  /**
   * Count Type Car_price_typesCountOutputType
   */


  export type Car_price_typesCountOutputType = {
    car_prices: number
  }

  export type Car_price_typesCountOutputTypeSelect = {
    car_prices?: boolean
  }

  export type Car_price_typesCountOutputTypeGetPayload<S extends boolean | null | undefined | Car_price_typesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Car_price_typesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Car_price_typesCountOutputTypeArgs)
    ? Car_price_typesCountOutputType 
    : S extends { select: any } & (Car_price_typesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Car_price_typesCountOutputType ? Car_price_typesCountOutputType[P] : never
  } 
      : Car_price_typesCountOutputType




  // Custom InputTypes

  /**
   * Car_price_typesCountOutputType without action
   */
  export type Car_price_typesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Car_price_typesCountOutputType
     */
    select?: Car_price_typesCountOutputTypeSelect | null
  }



  /**
   * Count Type CarsCountOutputType
   */


  export type CarsCountOutputType = {
    car_prices: number
    package_serivce: number
    reservations: number
    slabs: number
    sub_services: number
    tours: number
  }

  export type CarsCountOutputTypeSelect = {
    car_prices?: boolean
    package_serivce?: boolean
    reservations?: boolean
    slabs?: boolean
    sub_services?: boolean
    tours?: boolean
  }

  export type CarsCountOutputTypeGetPayload<S extends boolean | null | undefined | CarsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CarsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CarsCountOutputTypeArgs)
    ? CarsCountOutputType 
    : S extends { select: any } & (CarsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CarsCountOutputType ? CarsCountOutputType[P] : never
  } 
      : CarsCountOutputType




  // Custom InputTypes

  /**
   * CarsCountOutputType without action
   */
  export type CarsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CarsCountOutputType
     */
    select?: CarsCountOutputTypeSelect | null
  }



  /**
   * Count Type DriversCountOutputType
   */


  export type DriversCountOutputType = {
    cars: number
  }

  export type DriversCountOutputTypeSelect = {
    cars?: boolean
  }

  export type DriversCountOutputTypeGetPayload<S extends boolean | null | undefined | DriversCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DriversCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DriversCountOutputTypeArgs)
    ? DriversCountOutputType 
    : S extends { select: any } & (DriversCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DriversCountOutputType ? DriversCountOutputType[P] : never
  } 
      : DriversCountOutputType




  // Custom InputTypes

  /**
   * DriversCountOutputType without action
   */
  export type DriversCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DriversCountOutputType
     */
    select?: DriversCountOutputTypeSelect | null
  }



  /**
   * Count Type Fuel_typesCountOutputType
   */


  export type Fuel_typesCountOutputType = {
    cars: number
  }

  export type Fuel_typesCountOutputTypeSelect = {
    cars?: boolean
  }

  export type Fuel_typesCountOutputTypeGetPayload<S extends boolean | null | undefined | Fuel_typesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Fuel_typesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Fuel_typesCountOutputTypeArgs)
    ? Fuel_typesCountOutputType 
    : S extends { select: any } & (Fuel_typesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Fuel_typesCountOutputType ? Fuel_typesCountOutputType[P] : never
  } 
      : Fuel_typesCountOutputType




  // Custom InputTypes

  /**
   * Fuel_typesCountOutputType without action
   */
  export type Fuel_typesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Fuel_typesCountOutputType
     */
    select?: Fuel_typesCountOutputTypeSelect | null
  }



  /**
   * Count Type ManufacturersCountOutputType
   */


  export type ManufacturersCountOutputType = {
    cars: number
  }

  export type ManufacturersCountOutputTypeSelect = {
    cars?: boolean
  }

  export type ManufacturersCountOutputTypeGetPayload<S extends boolean | null | undefined | ManufacturersCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ManufacturersCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ManufacturersCountOutputTypeArgs)
    ? ManufacturersCountOutputType 
    : S extends { select: any } & (ManufacturersCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ManufacturersCountOutputType ? ManufacturersCountOutputType[P] : never
  } 
      : ManufacturersCountOutputType




  // Custom InputTypes

  /**
   * ManufacturersCountOutputType without action
   */
  export type ManufacturersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ManufacturersCountOutputType
     */
    select?: ManufacturersCountOutputTypeSelect | null
  }



  /**
   * Count Type RolesCountOutputType
   */


  export type RolesCountOutputType = {
    role_users: number
  }

  export type RolesCountOutputTypeSelect = {
    role_users?: boolean
  }

  export type RolesCountOutputTypeGetPayload<S extends boolean | null | undefined | RolesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RolesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RolesCountOutputTypeArgs)
    ? RolesCountOutputType 
    : S extends { select: any } & (RolesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RolesCountOutputType ? RolesCountOutputType[P] : never
  } 
      : RolesCountOutputType




  // Custom InputTypes

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect | null
  }



  /**
   * Count Type ServicesCountOutputType
   */


  export type ServicesCountOutputType = {
    airport_services: number
    gratuities: number
    hourly_services: number
    point_to_point_services: number
    sub_services: number
  }

  export type ServicesCountOutputTypeSelect = {
    airport_services?: boolean
    gratuities?: boolean
    hourly_services?: boolean
    point_to_point_services?: boolean
    sub_services?: boolean
  }

  export type ServicesCountOutputTypeGetPayload<S extends boolean | null | undefined | ServicesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ServicesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ServicesCountOutputTypeArgs)
    ? ServicesCountOutputType 
    : S extends { select: any } & (ServicesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ServicesCountOutputType ? ServicesCountOutputType[P] : never
  } 
      : ServicesCountOutputType




  // Custom InputTypes

  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ServicesCountOutputType
     */
    select?: ServicesCountOutputTypeSelect | null
  }



  /**
   * Count Type TransmissionsCountOutputType
   */


  export type TransmissionsCountOutputType = {
    cars: number
  }

  export type TransmissionsCountOutputTypeSelect = {
    cars?: boolean
  }

  export type TransmissionsCountOutputTypeGetPayload<S extends boolean | null | undefined | TransmissionsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TransmissionsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TransmissionsCountOutputTypeArgs)
    ? TransmissionsCountOutputType 
    : S extends { select: any } & (TransmissionsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TransmissionsCountOutputType ? TransmissionsCountOutputType[P] : never
  } 
      : TransmissionsCountOutputType




  // Custom InputTypes

  /**
   * TransmissionsCountOutputType without action
   */
  export type TransmissionsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TransmissionsCountOutputType
     */
    select?: TransmissionsCountOutputTypeSelect | null
  }



  /**
   * Count Type UsersCountOutputType
   */


  export type UsersCountOutputType = {
    role_users: number
  }

  export type UsersCountOutputTypeSelect = {
    role_users?: boolean
  }

  export type UsersCountOutputTypeGetPayload<S extends boolean | null | undefined | UsersCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UsersCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UsersCountOutputTypeArgs)
    ? UsersCountOutputType 
    : S extends { select: any } & (UsersCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UsersCountOutputType ? UsersCountOutputType[P] : never
  } 
      : UsersCountOutputType




  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect | null
  }



  /**
   * Count Type Vehicle_typesCountOutputType
   */


  export type Vehicle_typesCountOutputType = {
    cars: number
  }

  export type Vehicle_typesCountOutputTypeSelect = {
    cars?: boolean
  }

  export type Vehicle_typesCountOutputTypeGetPayload<S extends boolean | null | undefined | Vehicle_typesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Vehicle_typesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Vehicle_typesCountOutputTypeArgs)
    ? Vehicle_typesCountOutputType 
    : S extends { select: any } & (Vehicle_typesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Vehicle_typesCountOutputType ? Vehicle_typesCountOutputType[P] : never
  } 
      : Vehicle_typesCountOutputType




  // Custom InputTypes

  /**
   * Vehicle_typesCountOutputType without action
   */
  export type Vehicle_typesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Vehicle_typesCountOutputType
     */
    select?: Vehicle_typesCountOutputTypeSelect | null
  }



  /**
   * Count Type Sub_servicesCountOutputType
   */


  export type Sub_servicesCountOutputType = {
    reservations: number
    timeslots: number
  }

  export type Sub_servicesCountOutputTypeSelect = {
    reservations?: boolean
    timeslots?: boolean
  }

  export type Sub_servicesCountOutputTypeGetPayload<S extends boolean | null | undefined | Sub_servicesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Sub_servicesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Sub_servicesCountOutputTypeArgs)
    ? Sub_servicesCountOutputType 
    : S extends { select: any } & (Sub_servicesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Sub_servicesCountOutputType ? Sub_servicesCountOutputType[P] : never
  } 
      : Sub_servicesCountOutputType




  // Custom InputTypes

  /**
   * Sub_servicesCountOutputType without action
   */
  export type Sub_servicesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Sub_servicesCountOutputType
     */
    select?: Sub_servicesCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model activations
   */


  export type AggregateActivations = {
    _count: ActivationsCountAggregateOutputType | null
    _avg: ActivationsAvgAggregateOutputType | null
    _sum: ActivationsSumAggregateOutputType | null
    _min: ActivationsMinAggregateOutputType | null
    _max: ActivationsMaxAggregateOutputType | null
  }

  export type ActivationsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ActivationsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ActivationsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    code: string | null
    completed: boolean | null
    completed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivationsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    code: string | null
    completed: boolean | null
    completed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivationsCountAggregateOutputType = {
    id: number
    user_id: number
    code: number
    completed: number
    completed_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ActivationsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ActivationsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ActivationsMinAggregateInputType = {
    id?: true
    user_id?: true
    code?: true
    completed?: true
    completed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    code?: true
    completed?: true
    completed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivationsCountAggregateInputType = {
    id?: true
    user_id?: true
    code?: true
    completed?: true
    completed_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ActivationsAggregateArgs = {
    /**
     * Filter which activations to aggregate.
     */
    where?: activationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activations to fetch.
     */
    orderBy?: Enumerable<activationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: activationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned activations
    **/
    _count?: true | ActivationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivationsMaxAggregateInputType
  }

  export type GetActivationsAggregateType<T extends ActivationsAggregateArgs> = {
        [P in keyof T & keyof AggregateActivations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivations[P]>
      : GetScalarType<T[P], AggregateActivations[P]>
  }




  export type ActivationsGroupByArgs = {
    where?: activationsWhereInput
    orderBy?: Enumerable<activationsOrderByWithAggregationInput>
    by: ActivationsScalarFieldEnum[]
    having?: activationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivationsCountAggregateInputType | true
    _avg?: ActivationsAvgAggregateInputType
    _sum?: ActivationsSumAggregateInputType
    _min?: ActivationsMinAggregateInputType
    _max?: ActivationsMaxAggregateInputType
  }


  export type ActivationsGroupByOutputType = {
    id: number
    user_id: number
    code: string
    completed: boolean
    completed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: ActivationsCountAggregateOutputType | null
    _avg: ActivationsAvgAggregateOutputType | null
    _sum: ActivationsSumAggregateOutputType | null
    _min: ActivationsMinAggregateOutputType | null
    _max: ActivationsMaxAggregateOutputType | null
  }

  type GetActivationsGroupByPayload<T extends ActivationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ActivationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivationsGroupByOutputType[P]>
            : GetScalarType<T[P], ActivationsGroupByOutputType[P]>
        }
      >
    >


  export type activationsSelect = {
    id?: boolean
    user_id?: boolean
    code?: boolean
    completed?: boolean
    completed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type activationsGetPayload<S extends boolean | null | undefined | activationsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? activations :
    S extends undefined ? never :
    S extends { include: any } & (activationsArgs | activationsFindManyArgs)
    ? activations 
    : S extends { select: any } & (activationsArgs | activationsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof activations ? activations[P] : never
  } 
      : activations


  type activationsCountArgs = 
    Omit<activationsFindManyArgs, 'select' | 'include'> & {
      select?: ActivationsCountAggregateInputType | true
    }

  export interface activationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Activations that matches the filter.
     * @param {activationsFindUniqueArgs} args - Arguments to find a Activations
     * @example
     * // Get one Activations
     * const activations = await prisma.activations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends activationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, activationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'activations'> extends True ? Prisma__activationsClient<activationsGetPayload<T>> : Prisma__activationsClient<activationsGetPayload<T> | null, null>

    /**
     * Find one Activations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {activationsFindUniqueOrThrowArgs} args - Arguments to find a Activations
     * @example
     * // Get one Activations
     * const activations = await prisma.activations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends activationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, activationsFindUniqueOrThrowArgs>
    ): Prisma__activationsClient<activationsGetPayload<T>>

    /**
     * Find the first Activations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activationsFindFirstArgs} args - Arguments to find a Activations
     * @example
     * // Get one Activations
     * const activations = await prisma.activations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends activationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, activationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'activations'> extends True ? Prisma__activationsClient<activationsGetPayload<T>> : Prisma__activationsClient<activationsGetPayload<T> | null, null>

    /**
     * Find the first Activations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activationsFindFirstOrThrowArgs} args - Arguments to find a Activations
     * @example
     * // Get one Activations
     * const activations = await prisma.activations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends activationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, activationsFindFirstOrThrowArgs>
    ): Prisma__activationsClient<activationsGetPayload<T>>

    /**
     * Find zero or more Activations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activations
     * const activations = await prisma.activations.findMany()
     * 
     * // Get first 10 Activations
     * const activations = await prisma.activations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activationsWithIdOnly = await prisma.activations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends activationsFindManyArgs>(
      args?: SelectSubset<T, activationsFindManyArgs>
    ): Prisma.PrismaPromise<Array<activationsGetPayload<T>>>

    /**
     * Create a Activations.
     * @param {activationsCreateArgs} args - Arguments to create a Activations.
     * @example
     * // Create one Activations
     * const Activations = await prisma.activations.create({
     *   data: {
     *     // ... data to create a Activations
     *   }
     * })
     * 
    **/
    create<T extends activationsCreateArgs>(
      args: SelectSubset<T, activationsCreateArgs>
    ): Prisma__activationsClient<activationsGetPayload<T>>

    /**
     * Create many Activations.
     *     @param {activationsCreateManyArgs} args - Arguments to create many Activations.
     *     @example
     *     // Create many Activations
     *     const activations = await prisma.activations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends activationsCreateManyArgs>(
      args?: SelectSubset<T, activationsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Activations.
     * @param {activationsDeleteArgs} args - Arguments to delete one Activations.
     * @example
     * // Delete one Activations
     * const Activations = await prisma.activations.delete({
     *   where: {
     *     // ... filter to delete one Activations
     *   }
     * })
     * 
    **/
    delete<T extends activationsDeleteArgs>(
      args: SelectSubset<T, activationsDeleteArgs>
    ): Prisma__activationsClient<activationsGetPayload<T>>

    /**
     * Update one Activations.
     * @param {activationsUpdateArgs} args - Arguments to update one Activations.
     * @example
     * // Update one Activations
     * const activations = await prisma.activations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends activationsUpdateArgs>(
      args: SelectSubset<T, activationsUpdateArgs>
    ): Prisma__activationsClient<activationsGetPayload<T>>

    /**
     * Delete zero or more Activations.
     * @param {activationsDeleteManyArgs} args - Arguments to filter Activations to delete.
     * @example
     * // Delete a few Activations
     * const { count } = await prisma.activations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends activationsDeleteManyArgs>(
      args?: SelectSubset<T, activationsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activations
     * const activations = await prisma.activations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends activationsUpdateManyArgs>(
      args: SelectSubset<T, activationsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activations.
     * @param {activationsUpsertArgs} args - Arguments to update or create a Activations.
     * @example
     * // Update or create a Activations
     * const activations = await prisma.activations.upsert({
     *   create: {
     *     // ... data to create a Activations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activations we want to update
     *   }
     * })
    **/
    upsert<T extends activationsUpsertArgs>(
      args: SelectSubset<T, activationsUpsertArgs>
    ): Prisma__activationsClient<activationsGetPayload<T>>

    /**
     * Count the number of Activations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activationsCountArgs} args - Arguments to filter Activations to count.
     * @example
     * // Count the number of Activations
     * const count = await prisma.activations.count({
     *   where: {
     *     // ... the filter for the Activations we want to count
     *   }
     * })
    **/
    count<T extends activationsCountArgs>(
      args?: Subset<T, activationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivationsAggregateArgs>(args: Subset<T, ActivationsAggregateArgs>): Prisma.PrismaPromise<GetActivationsAggregateType<T>>

    /**
     * Group by Activations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivationsGroupByArgs['orderBy'] }
        : { orderBy?: ActivationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for activations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__activationsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * activations base type for findUnique actions
   */
  export type activationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the activations
     */
    select?: activationsSelect | null
    /**
     * Filter, which activations to fetch.
     */
    where: activationsWhereUniqueInput
  }

  /**
   * activations findUnique
   */
  export interface activationsFindUniqueArgs extends activationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * activations findUniqueOrThrow
   */
  export type activationsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the activations
     */
    select?: activationsSelect | null
    /**
     * Filter, which activations to fetch.
     */
    where: activationsWhereUniqueInput
  }


  /**
   * activations base type for findFirst actions
   */
  export type activationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the activations
     */
    select?: activationsSelect | null
    /**
     * Filter, which activations to fetch.
     */
    where?: activationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activations to fetch.
     */
    orderBy?: Enumerable<activationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activations.
     */
    cursor?: activationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activations.
     */
    distinct?: Enumerable<ActivationsScalarFieldEnum>
  }

  /**
   * activations findFirst
   */
  export interface activationsFindFirstArgs extends activationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * activations findFirstOrThrow
   */
  export type activationsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the activations
     */
    select?: activationsSelect | null
    /**
     * Filter, which activations to fetch.
     */
    where?: activationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activations to fetch.
     */
    orderBy?: Enumerable<activationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activations.
     */
    cursor?: activationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activations.
     */
    distinct?: Enumerable<ActivationsScalarFieldEnum>
  }


  /**
   * activations findMany
   */
  export type activationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the activations
     */
    select?: activationsSelect | null
    /**
     * Filter, which activations to fetch.
     */
    where?: activationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activations to fetch.
     */
    orderBy?: Enumerable<activationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing activations.
     */
    cursor?: activationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activations.
     */
    skip?: number
    distinct?: Enumerable<ActivationsScalarFieldEnum>
  }


  /**
   * activations create
   */
  export type activationsCreateArgs = {
    /**
     * Select specific fields to fetch from the activations
     */
    select?: activationsSelect | null
    /**
     * The data needed to create a activations.
     */
    data: XOR<activationsCreateInput, activationsUncheckedCreateInput>
  }


  /**
   * activations createMany
   */
  export type activationsCreateManyArgs = {
    /**
     * The data used to create many activations.
     */
    data: Enumerable<activationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * activations update
   */
  export type activationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the activations
     */
    select?: activationsSelect | null
    /**
     * The data needed to update a activations.
     */
    data: XOR<activationsUpdateInput, activationsUncheckedUpdateInput>
    /**
     * Choose, which activations to update.
     */
    where: activationsWhereUniqueInput
  }


  /**
   * activations updateMany
   */
  export type activationsUpdateManyArgs = {
    /**
     * The data used to update activations.
     */
    data: XOR<activationsUpdateManyMutationInput, activationsUncheckedUpdateManyInput>
    /**
     * Filter which activations to update
     */
    where?: activationsWhereInput
  }


  /**
   * activations upsert
   */
  export type activationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the activations
     */
    select?: activationsSelect | null
    /**
     * The filter to search for the activations to update in case it exists.
     */
    where: activationsWhereUniqueInput
    /**
     * In case the activations found by the `where` argument doesn't exist, create a new activations with this data.
     */
    create: XOR<activationsCreateInput, activationsUncheckedCreateInput>
    /**
     * In case the activations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<activationsUpdateInput, activationsUncheckedUpdateInput>
  }


  /**
   * activations delete
   */
  export type activationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the activations
     */
    select?: activationsSelect | null
    /**
     * Filter which activations to delete.
     */
    where: activationsWhereUniqueInput
  }


  /**
   * activations deleteMany
   */
  export type activationsDeleteManyArgs = {
    /**
     * Filter which activations to delete
     */
    where?: activationsWhereInput
  }


  /**
   * activations without action
   */
  export type activationsArgs = {
    /**
     * Select specific fields to fetch from the activations
     */
    select?: activationsSelect | null
  }



  /**
   * Model activity_log
   */


  export type AggregateActivity_log = {
    _count: Activity_logCountAggregateOutputType | null
    _avg: Activity_logAvgAggregateOutputType | null
    _sum: Activity_logSumAggregateOutputType | null
    _min: Activity_logMinAggregateOutputType | null
    _max: Activity_logMaxAggregateOutputType | null
  }

  export type Activity_logAvgAggregateOutputType = {
    id: number | null
    subject_id: number | null
    causer_id: number | null
  }

  export type Activity_logSumAggregateOutputType = {
    id: number | null
    subject_id: number | null
    causer_id: number | null
  }

  export type Activity_logMinAggregateOutputType = {
    id: number | null
    log_name: string | null
    description: string | null
    subject_id: number | null
    subject_type: string | null
    causer_id: number | null
    causer_type: string | null
    properties: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Activity_logMaxAggregateOutputType = {
    id: number | null
    log_name: string | null
    description: string | null
    subject_id: number | null
    subject_type: string | null
    causer_id: number | null
    causer_type: string | null
    properties: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Activity_logCountAggregateOutputType = {
    id: number
    log_name: number
    description: number
    subject_id: number
    subject_type: number
    causer_id: number
    causer_type: number
    properties: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Activity_logAvgAggregateInputType = {
    id?: true
    subject_id?: true
    causer_id?: true
  }

  export type Activity_logSumAggregateInputType = {
    id?: true
    subject_id?: true
    causer_id?: true
  }

  export type Activity_logMinAggregateInputType = {
    id?: true
    log_name?: true
    description?: true
    subject_id?: true
    subject_type?: true
    causer_id?: true
    causer_type?: true
    properties?: true
    created_at?: true
    updated_at?: true
  }

  export type Activity_logMaxAggregateInputType = {
    id?: true
    log_name?: true
    description?: true
    subject_id?: true
    subject_type?: true
    causer_id?: true
    causer_type?: true
    properties?: true
    created_at?: true
    updated_at?: true
  }

  export type Activity_logCountAggregateInputType = {
    id?: true
    log_name?: true
    description?: true
    subject_id?: true
    subject_type?: true
    causer_id?: true
    causer_type?: true
    properties?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Activity_logAggregateArgs = {
    /**
     * Filter which activity_log to aggregate.
     */
    where?: activity_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activity_logs to fetch.
     */
    orderBy?: Enumerable<activity_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: activity_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activity_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned activity_logs
    **/
    _count?: true | Activity_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Activity_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Activity_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Activity_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Activity_logMaxAggregateInputType
  }

  export type GetActivity_logAggregateType<T extends Activity_logAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity_log[P]>
      : GetScalarType<T[P], AggregateActivity_log[P]>
  }




  export type Activity_logGroupByArgs = {
    where?: activity_logWhereInput
    orderBy?: Enumerable<activity_logOrderByWithAggregationInput>
    by: Activity_logScalarFieldEnum[]
    having?: activity_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Activity_logCountAggregateInputType | true
    _avg?: Activity_logAvgAggregateInputType
    _sum?: Activity_logSumAggregateInputType
    _min?: Activity_logMinAggregateInputType
    _max?: Activity_logMaxAggregateInputType
  }


  export type Activity_logGroupByOutputType = {
    id: number
    log_name: string | null
    description: string
    subject_id: number | null
    subject_type: string | null
    causer_id: number | null
    causer_type: string | null
    properties: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Activity_logCountAggregateOutputType | null
    _avg: Activity_logAvgAggregateOutputType | null
    _sum: Activity_logSumAggregateOutputType | null
    _min: Activity_logMinAggregateOutputType | null
    _max: Activity_logMaxAggregateOutputType | null
  }

  type GetActivity_logGroupByPayload<T extends Activity_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Activity_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Activity_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Activity_logGroupByOutputType[P]>
            : GetScalarType<T[P], Activity_logGroupByOutputType[P]>
        }
      >
    >


  export type activity_logSelect = {
    id?: boolean
    log_name?: boolean
    description?: boolean
    subject_id?: boolean
    subject_type?: boolean
    causer_id?: boolean
    causer_type?: boolean
    properties?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type activity_logGetPayload<S extends boolean | null | undefined | activity_logArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? activity_log :
    S extends undefined ? never :
    S extends { include: any } & (activity_logArgs | activity_logFindManyArgs)
    ? activity_log 
    : S extends { select: any } & (activity_logArgs | activity_logFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof activity_log ? activity_log[P] : never
  } 
      : activity_log


  type activity_logCountArgs = 
    Omit<activity_logFindManyArgs, 'select' | 'include'> & {
      select?: Activity_logCountAggregateInputType | true
    }

  export interface activity_logDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Activity_log that matches the filter.
     * @param {activity_logFindUniqueArgs} args - Arguments to find a Activity_log
     * @example
     * // Get one Activity_log
     * const activity_log = await prisma.activity_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends activity_logFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, activity_logFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'activity_log'> extends True ? Prisma__activity_logClient<activity_logGetPayload<T>> : Prisma__activity_logClient<activity_logGetPayload<T> | null, null>

    /**
     * Find one Activity_log that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {activity_logFindUniqueOrThrowArgs} args - Arguments to find a Activity_log
     * @example
     * // Get one Activity_log
     * const activity_log = await prisma.activity_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends activity_logFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, activity_logFindUniqueOrThrowArgs>
    ): Prisma__activity_logClient<activity_logGetPayload<T>>

    /**
     * Find the first Activity_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logFindFirstArgs} args - Arguments to find a Activity_log
     * @example
     * // Get one Activity_log
     * const activity_log = await prisma.activity_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends activity_logFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, activity_logFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'activity_log'> extends True ? Prisma__activity_logClient<activity_logGetPayload<T>> : Prisma__activity_logClient<activity_logGetPayload<T> | null, null>

    /**
     * Find the first Activity_log that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logFindFirstOrThrowArgs} args - Arguments to find a Activity_log
     * @example
     * // Get one Activity_log
     * const activity_log = await prisma.activity_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends activity_logFindFirstOrThrowArgs>(
      args?: SelectSubset<T, activity_logFindFirstOrThrowArgs>
    ): Prisma__activity_logClient<activity_logGetPayload<T>>

    /**
     * Find zero or more Activity_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activity_logs
     * const activity_logs = await prisma.activity_log.findMany()
     * 
     * // Get first 10 Activity_logs
     * const activity_logs = await prisma.activity_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activity_logWithIdOnly = await prisma.activity_log.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends activity_logFindManyArgs>(
      args?: SelectSubset<T, activity_logFindManyArgs>
    ): Prisma.PrismaPromise<Array<activity_logGetPayload<T>>>

    /**
     * Create a Activity_log.
     * @param {activity_logCreateArgs} args - Arguments to create a Activity_log.
     * @example
     * // Create one Activity_log
     * const Activity_log = await prisma.activity_log.create({
     *   data: {
     *     // ... data to create a Activity_log
     *   }
     * })
     * 
    **/
    create<T extends activity_logCreateArgs>(
      args: SelectSubset<T, activity_logCreateArgs>
    ): Prisma__activity_logClient<activity_logGetPayload<T>>

    /**
     * Create many Activity_logs.
     *     @param {activity_logCreateManyArgs} args - Arguments to create many Activity_logs.
     *     @example
     *     // Create many Activity_logs
     *     const activity_log = await prisma.activity_log.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends activity_logCreateManyArgs>(
      args?: SelectSubset<T, activity_logCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Activity_log.
     * @param {activity_logDeleteArgs} args - Arguments to delete one Activity_log.
     * @example
     * // Delete one Activity_log
     * const Activity_log = await prisma.activity_log.delete({
     *   where: {
     *     // ... filter to delete one Activity_log
     *   }
     * })
     * 
    **/
    delete<T extends activity_logDeleteArgs>(
      args: SelectSubset<T, activity_logDeleteArgs>
    ): Prisma__activity_logClient<activity_logGetPayload<T>>

    /**
     * Update one Activity_log.
     * @param {activity_logUpdateArgs} args - Arguments to update one Activity_log.
     * @example
     * // Update one Activity_log
     * const activity_log = await prisma.activity_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends activity_logUpdateArgs>(
      args: SelectSubset<T, activity_logUpdateArgs>
    ): Prisma__activity_logClient<activity_logGetPayload<T>>

    /**
     * Delete zero or more Activity_logs.
     * @param {activity_logDeleteManyArgs} args - Arguments to filter Activity_logs to delete.
     * @example
     * // Delete a few Activity_logs
     * const { count } = await prisma.activity_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends activity_logDeleteManyArgs>(
      args?: SelectSubset<T, activity_logDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activity_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activity_logs
     * const activity_log = await prisma.activity_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends activity_logUpdateManyArgs>(
      args: SelectSubset<T, activity_logUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity_log.
     * @param {activity_logUpsertArgs} args - Arguments to update or create a Activity_log.
     * @example
     * // Update or create a Activity_log
     * const activity_log = await prisma.activity_log.upsert({
     *   create: {
     *     // ... data to create a Activity_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity_log we want to update
     *   }
     * })
    **/
    upsert<T extends activity_logUpsertArgs>(
      args: SelectSubset<T, activity_logUpsertArgs>
    ): Prisma__activity_logClient<activity_logGetPayload<T>>

    /**
     * Count the number of Activity_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logCountArgs} args - Arguments to filter Activity_logs to count.
     * @example
     * // Count the number of Activity_logs
     * const count = await prisma.activity_log.count({
     *   where: {
     *     // ... the filter for the Activity_logs we want to count
     *   }
     * })
    **/
    count<T extends activity_logCountArgs>(
      args?: Subset<T, activity_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Activity_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Activity_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Activity_logAggregateArgs>(args: Subset<T, Activity_logAggregateArgs>): Prisma.PrismaPromise<GetActivity_logAggregateType<T>>

    /**
     * Group by Activity_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Activity_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Activity_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Activity_logGroupByArgs['orderBy'] }
        : { orderBy?: Activity_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Activity_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivity_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for activity_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__activity_logClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * activity_log base type for findUnique actions
   */
  export type activity_logFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect | null
    /**
     * Filter, which activity_log to fetch.
     */
    where: activity_logWhereUniqueInput
  }

  /**
   * activity_log findUnique
   */
  export interface activity_logFindUniqueArgs extends activity_logFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * activity_log findUniqueOrThrow
   */
  export type activity_logFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect | null
    /**
     * Filter, which activity_log to fetch.
     */
    where: activity_logWhereUniqueInput
  }


  /**
   * activity_log base type for findFirst actions
   */
  export type activity_logFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect | null
    /**
     * Filter, which activity_log to fetch.
     */
    where?: activity_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activity_logs to fetch.
     */
    orderBy?: Enumerable<activity_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activity_logs.
     */
    cursor?: activity_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activity_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activity_logs.
     */
    distinct?: Enumerable<Activity_logScalarFieldEnum>
  }

  /**
   * activity_log findFirst
   */
  export interface activity_logFindFirstArgs extends activity_logFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * activity_log findFirstOrThrow
   */
  export type activity_logFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect | null
    /**
     * Filter, which activity_log to fetch.
     */
    where?: activity_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activity_logs to fetch.
     */
    orderBy?: Enumerable<activity_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activity_logs.
     */
    cursor?: activity_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activity_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activity_logs.
     */
    distinct?: Enumerable<Activity_logScalarFieldEnum>
  }


  /**
   * activity_log findMany
   */
  export type activity_logFindManyArgs = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect | null
    /**
     * Filter, which activity_logs to fetch.
     */
    where?: activity_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activity_logs to fetch.
     */
    orderBy?: Enumerable<activity_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing activity_logs.
     */
    cursor?: activity_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activity_logs.
     */
    skip?: number
    distinct?: Enumerable<Activity_logScalarFieldEnum>
  }


  /**
   * activity_log create
   */
  export type activity_logCreateArgs = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect | null
    /**
     * The data needed to create a activity_log.
     */
    data: XOR<activity_logCreateInput, activity_logUncheckedCreateInput>
  }


  /**
   * activity_log createMany
   */
  export type activity_logCreateManyArgs = {
    /**
     * The data used to create many activity_logs.
     */
    data: Enumerable<activity_logCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * activity_log update
   */
  export type activity_logUpdateArgs = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect | null
    /**
     * The data needed to update a activity_log.
     */
    data: XOR<activity_logUpdateInput, activity_logUncheckedUpdateInput>
    /**
     * Choose, which activity_log to update.
     */
    where: activity_logWhereUniqueInput
  }


  /**
   * activity_log updateMany
   */
  export type activity_logUpdateManyArgs = {
    /**
     * The data used to update activity_logs.
     */
    data: XOR<activity_logUpdateManyMutationInput, activity_logUncheckedUpdateManyInput>
    /**
     * Filter which activity_logs to update
     */
    where?: activity_logWhereInput
  }


  /**
   * activity_log upsert
   */
  export type activity_logUpsertArgs = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect | null
    /**
     * The filter to search for the activity_log to update in case it exists.
     */
    where: activity_logWhereUniqueInput
    /**
     * In case the activity_log found by the `where` argument doesn't exist, create a new activity_log with this data.
     */
    create: XOR<activity_logCreateInput, activity_logUncheckedCreateInput>
    /**
     * In case the activity_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<activity_logUpdateInput, activity_logUncheckedUpdateInput>
  }


  /**
   * activity_log delete
   */
  export type activity_logDeleteArgs = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect | null
    /**
     * Filter which activity_log to delete.
     */
    where: activity_logWhereUniqueInput
  }


  /**
   * activity_log deleteMany
   */
  export type activity_logDeleteManyArgs = {
    /**
     * Filter which activity_logs to delete
     */
    where?: activity_logWhereInput
  }


  /**
   * activity_log without action
   */
  export type activity_logArgs = {
    /**
     * Select specific fields to fetch from the activity_log
     */
    select?: activity_logSelect | null
  }



  /**
   * Model airlines
   */


  export type AggregateAirlines = {
    _count: AirlinesCountAggregateOutputType | null
    _avg: AirlinesAvgAggregateOutputType | null
    _sum: AirlinesSumAggregateOutputType | null
    _min: AirlinesMinAggregateOutputType | null
    _max: AirlinesMaxAggregateOutputType | null
  }

  export type AirlinesAvgAggregateOutputType = {
    id: number | null
  }

  export type AirlinesSumAggregateOutputType = {
    id: number | null
  }

  export type AirlinesMinAggregateOutputType = {
    id: number | null
    name: string | null
    alias: string | null
    iata: string | null
    icao: string | null
    callsign: string | null
    country: string | null
    active: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AirlinesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    alias: string | null
    iata: string | null
    icao: string | null
    callsign: string | null
    country: string | null
    active: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AirlinesCountAggregateOutputType = {
    id: number
    name: number
    alias: number
    iata: number
    icao: number
    callsign: number
    country: number
    active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AirlinesAvgAggregateInputType = {
    id?: true
  }

  export type AirlinesSumAggregateInputType = {
    id?: true
  }

  export type AirlinesMinAggregateInputType = {
    id?: true
    name?: true
    alias?: true
    iata?: true
    icao?: true
    callsign?: true
    country?: true
    active?: true
    created_at?: true
    updated_at?: true
  }

  export type AirlinesMaxAggregateInputType = {
    id?: true
    name?: true
    alias?: true
    iata?: true
    icao?: true
    callsign?: true
    country?: true
    active?: true
    created_at?: true
    updated_at?: true
  }

  export type AirlinesCountAggregateInputType = {
    id?: true
    name?: true
    alias?: true
    iata?: true
    icao?: true
    callsign?: true
    country?: true
    active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AirlinesAggregateArgs = {
    /**
     * Filter which airlines to aggregate.
     */
    where?: airlinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airlines to fetch.
     */
    orderBy?: Enumerable<airlinesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: airlinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned airlines
    **/
    _count?: true | AirlinesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AirlinesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AirlinesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AirlinesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AirlinesMaxAggregateInputType
  }

  export type GetAirlinesAggregateType<T extends AirlinesAggregateArgs> = {
        [P in keyof T & keyof AggregateAirlines]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAirlines[P]>
      : GetScalarType<T[P], AggregateAirlines[P]>
  }




  export type AirlinesGroupByArgs = {
    where?: airlinesWhereInput
    orderBy?: Enumerable<airlinesOrderByWithAggregationInput>
    by: AirlinesScalarFieldEnum[]
    having?: airlinesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AirlinesCountAggregateInputType | true
    _avg?: AirlinesAvgAggregateInputType
    _sum?: AirlinesSumAggregateInputType
    _min?: AirlinesMinAggregateInputType
    _max?: AirlinesMaxAggregateInputType
  }


  export type AirlinesGroupByOutputType = {
    id: number
    name: string | null
    alias: string | null
    iata: string | null
    icao: string | null
    callsign: string | null
    country: string | null
    active: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: AirlinesCountAggregateOutputType | null
    _avg: AirlinesAvgAggregateOutputType | null
    _sum: AirlinesSumAggregateOutputType | null
    _min: AirlinesMinAggregateOutputType | null
    _max: AirlinesMaxAggregateOutputType | null
  }

  type GetAirlinesGroupByPayload<T extends AirlinesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AirlinesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AirlinesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AirlinesGroupByOutputType[P]>
            : GetScalarType<T[P], AirlinesGroupByOutputType[P]>
        }
      >
    >


  export type airlinesSelect = {
    id?: boolean
    name?: boolean
    alias?: boolean
    iata?: boolean
    icao?: boolean
    callsign?: boolean
    country?: boolean
    active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type airlinesGetPayload<S extends boolean | null | undefined | airlinesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? airlines :
    S extends undefined ? never :
    S extends { include: any } & (airlinesArgs | airlinesFindManyArgs)
    ? airlines 
    : S extends { select: any } & (airlinesArgs | airlinesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof airlines ? airlines[P] : never
  } 
      : airlines


  type airlinesCountArgs = 
    Omit<airlinesFindManyArgs, 'select' | 'include'> & {
      select?: AirlinesCountAggregateInputType | true
    }

  export interface airlinesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Airlines that matches the filter.
     * @param {airlinesFindUniqueArgs} args - Arguments to find a Airlines
     * @example
     * // Get one Airlines
     * const airlines = await prisma.airlines.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends airlinesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, airlinesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'airlines'> extends True ? Prisma__airlinesClient<airlinesGetPayload<T>> : Prisma__airlinesClient<airlinesGetPayload<T> | null, null>

    /**
     * Find one Airlines that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {airlinesFindUniqueOrThrowArgs} args - Arguments to find a Airlines
     * @example
     * // Get one Airlines
     * const airlines = await prisma.airlines.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends airlinesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, airlinesFindUniqueOrThrowArgs>
    ): Prisma__airlinesClient<airlinesGetPayload<T>>

    /**
     * Find the first Airlines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airlinesFindFirstArgs} args - Arguments to find a Airlines
     * @example
     * // Get one Airlines
     * const airlines = await prisma.airlines.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends airlinesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, airlinesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'airlines'> extends True ? Prisma__airlinesClient<airlinesGetPayload<T>> : Prisma__airlinesClient<airlinesGetPayload<T> | null, null>

    /**
     * Find the first Airlines that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airlinesFindFirstOrThrowArgs} args - Arguments to find a Airlines
     * @example
     * // Get one Airlines
     * const airlines = await prisma.airlines.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends airlinesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, airlinesFindFirstOrThrowArgs>
    ): Prisma__airlinesClient<airlinesGetPayload<T>>

    /**
     * Find zero or more Airlines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airlinesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Airlines
     * const airlines = await prisma.airlines.findMany()
     * 
     * // Get first 10 Airlines
     * const airlines = await prisma.airlines.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const airlinesWithIdOnly = await prisma.airlines.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends airlinesFindManyArgs>(
      args?: SelectSubset<T, airlinesFindManyArgs>
    ): Prisma.PrismaPromise<Array<airlinesGetPayload<T>>>

    /**
     * Create a Airlines.
     * @param {airlinesCreateArgs} args - Arguments to create a Airlines.
     * @example
     * // Create one Airlines
     * const Airlines = await prisma.airlines.create({
     *   data: {
     *     // ... data to create a Airlines
     *   }
     * })
     * 
    **/
    create<T extends airlinesCreateArgs>(
      args: SelectSubset<T, airlinesCreateArgs>
    ): Prisma__airlinesClient<airlinesGetPayload<T>>

    /**
     * Create many Airlines.
     *     @param {airlinesCreateManyArgs} args - Arguments to create many Airlines.
     *     @example
     *     // Create many Airlines
     *     const airlines = await prisma.airlines.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends airlinesCreateManyArgs>(
      args?: SelectSubset<T, airlinesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Airlines.
     * @param {airlinesDeleteArgs} args - Arguments to delete one Airlines.
     * @example
     * // Delete one Airlines
     * const Airlines = await prisma.airlines.delete({
     *   where: {
     *     // ... filter to delete one Airlines
     *   }
     * })
     * 
    **/
    delete<T extends airlinesDeleteArgs>(
      args: SelectSubset<T, airlinesDeleteArgs>
    ): Prisma__airlinesClient<airlinesGetPayload<T>>

    /**
     * Update one Airlines.
     * @param {airlinesUpdateArgs} args - Arguments to update one Airlines.
     * @example
     * // Update one Airlines
     * const airlines = await prisma.airlines.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends airlinesUpdateArgs>(
      args: SelectSubset<T, airlinesUpdateArgs>
    ): Prisma__airlinesClient<airlinesGetPayload<T>>

    /**
     * Delete zero or more Airlines.
     * @param {airlinesDeleteManyArgs} args - Arguments to filter Airlines to delete.
     * @example
     * // Delete a few Airlines
     * const { count } = await prisma.airlines.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends airlinesDeleteManyArgs>(
      args?: SelectSubset<T, airlinesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Airlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airlinesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Airlines
     * const airlines = await prisma.airlines.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends airlinesUpdateManyArgs>(
      args: SelectSubset<T, airlinesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Airlines.
     * @param {airlinesUpsertArgs} args - Arguments to update or create a Airlines.
     * @example
     * // Update or create a Airlines
     * const airlines = await prisma.airlines.upsert({
     *   create: {
     *     // ... data to create a Airlines
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Airlines we want to update
     *   }
     * })
    **/
    upsert<T extends airlinesUpsertArgs>(
      args: SelectSubset<T, airlinesUpsertArgs>
    ): Prisma__airlinesClient<airlinesGetPayload<T>>

    /**
     * Count the number of Airlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airlinesCountArgs} args - Arguments to filter Airlines to count.
     * @example
     * // Count the number of Airlines
     * const count = await prisma.airlines.count({
     *   where: {
     *     // ... the filter for the Airlines we want to count
     *   }
     * })
    **/
    count<T extends airlinesCountArgs>(
      args?: Subset<T, airlinesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AirlinesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Airlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirlinesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AirlinesAggregateArgs>(args: Subset<T, AirlinesAggregateArgs>): Prisma.PrismaPromise<GetAirlinesAggregateType<T>>

    /**
     * Group by Airlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirlinesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AirlinesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AirlinesGroupByArgs['orderBy'] }
        : { orderBy?: AirlinesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AirlinesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAirlinesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for airlines.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__airlinesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * airlines base type for findUnique actions
   */
  export type airlinesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the airlines
     */
    select?: airlinesSelect | null
    /**
     * Filter, which airlines to fetch.
     */
    where: airlinesWhereUniqueInput
  }

  /**
   * airlines findUnique
   */
  export interface airlinesFindUniqueArgs extends airlinesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * airlines findUniqueOrThrow
   */
  export type airlinesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the airlines
     */
    select?: airlinesSelect | null
    /**
     * Filter, which airlines to fetch.
     */
    where: airlinesWhereUniqueInput
  }


  /**
   * airlines base type for findFirst actions
   */
  export type airlinesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the airlines
     */
    select?: airlinesSelect | null
    /**
     * Filter, which airlines to fetch.
     */
    where?: airlinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airlines to fetch.
     */
    orderBy?: Enumerable<airlinesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for airlines.
     */
    cursor?: airlinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of airlines.
     */
    distinct?: Enumerable<AirlinesScalarFieldEnum>
  }

  /**
   * airlines findFirst
   */
  export interface airlinesFindFirstArgs extends airlinesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * airlines findFirstOrThrow
   */
  export type airlinesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the airlines
     */
    select?: airlinesSelect | null
    /**
     * Filter, which airlines to fetch.
     */
    where?: airlinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airlines to fetch.
     */
    orderBy?: Enumerable<airlinesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for airlines.
     */
    cursor?: airlinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of airlines.
     */
    distinct?: Enumerable<AirlinesScalarFieldEnum>
  }


  /**
   * airlines findMany
   */
  export type airlinesFindManyArgs = {
    /**
     * Select specific fields to fetch from the airlines
     */
    select?: airlinesSelect | null
    /**
     * Filter, which airlines to fetch.
     */
    where?: airlinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airlines to fetch.
     */
    orderBy?: Enumerable<airlinesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing airlines.
     */
    cursor?: airlinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airlines.
     */
    skip?: number
    distinct?: Enumerable<AirlinesScalarFieldEnum>
  }


  /**
   * airlines create
   */
  export type airlinesCreateArgs = {
    /**
     * Select specific fields to fetch from the airlines
     */
    select?: airlinesSelect | null
    /**
     * The data needed to create a airlines.
     */
    data: XOR<airlinesCreateInput, airlinesUncheckedCreateInput>
  }


  /**
   * airlines createMany
   */
  export type airlinesCreateManyArgs = {
    /**
     * The data used to create many airlines.
     */
    data: Enumerable<airlinesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * airlines update
   */
  export type airlinesUpdateArgs = {
    /**
     * Select specific fields to fetch from the airlines
     */
    select?: airlinesSelect | null
    /**
     * The data needed to update a airlines.
     */
    data: XOR<airlinesUpdateInput, airlinesUncheckedUpdateInput>
    /**
     * Choose, which airlines to update.
     */
    where: airlinesWhereUniqueInput
  }


  /**
   * airlines updateMany
   */
  export type airlinesUpdateManyArgs = {
    /**
     * The data used to update airlines.
     */
    data: XOR<airlinesUpdateManyMutationInput, airlinesUncheckedUpdateManyInput>
    /**
     * Filter which airlines to update
     */
    where?: airlinesWhereInput
  }


  /**
   * airlines upsert
   */
  export type airlinesUpsertArgs = {
    /**
     * Select specific fields to fetch from the airlines
     */
    select?: airlinesSelect | null
    /**
     * The filter to search for the airlines to update in case it exists.
     */
    where: airlinesWhereUniqueInput
    /**
     * In case the airlines found by the `where` argument doesn't exist, create a new airlines with this data.
     */
    create: XOR<airlinesCreateInput, airlinesUncheckedCreateInput>
    /**
     * In case the airlines was found with the provided `where` argument, update it with this data.
     */
    update: XOR<airlinesUpdateInput, airlinesUncheckedUpdateInput>
  }


  /**
   * airlines delete
   */
  export type airlinesDeleteArgs = {
    /**
     * Select specific fields to fetch from the airlines
     */
    select?: airlinesSelect | null
    /**
     * Filter which airlines to delete.
     */
    where: airlinesWhereUniqueInput
  }


  /**
   * airlines deleteMany
   */
  export type airlinesDeleteManyArgs = {
    /**
     * Filter which airlines to delete
     */
    where?: airlinesWhereInput
  }


  /**
   * airlines without action
   */
  export type airlinesArgs = {
    /**
     * Select specific fields to fetch from the airlines
     */
    select?: airlinesSelect | null
  }



  /**
   * Model airport_services
   */


  export type AggregateAirport_services = {
    _count: Airport_servicesCountAggregateOutputType | null
    _avg: Airport_servicesAvgAggregateOutputType | null
    _sum: Airport_servicesSumAggregateOutputType | null
    _min: Airport_servicesMinAggregateOutputType | null
    _max: Airport_servicesMaxAggregateOutputType | null
  }

  export type Airport_servicesAvgAggregateOutputType = {
    id: number | null
    num_passengers: number | null
    service_id: number | null
  }

  export type Airport_servicesSumAggregateOutputType = {
    id: number | null
    num_passengers: number | null
    service_id: number | null
  }

  export type Airport_servicesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    pickup_dropoff: boolean | null
    pickup_date_time: Date | null
    num_passengers: number | null
    pickup_from: string | null
    dropoff_location: string | null
    airline: string | null
    flight_number: string | null
    status: boolean | null
    pick_up_lat: string | null
    drop_off_lat: string | null
    pick_up_lon: string | null
    drop_off_lon: string | null
    service_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Airport_servicesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    pickup_dropoff: boolean | null
    pickup_date_time: Date | null
    num_passengers: number | null
    pickup_from: string | null
    dropoff_location: string | null
    airline: string | null
    flight_number: string | null
    status: boolean | null
    pick_up_lat: string | null
    drop_off_lat: string | null
    pick_up_lon: string | null
    drop_off_lon: string | null
    service_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Airport_servicesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    pickup_dropoff: number
    pickup_date_time: number
    num_passengers: number
    pickup_from: number
    dropoff_location: number
    airline: number
    flight_number: number
    status: number
    pick_up_lat: number
    drop_off_lat: number
    pick_up_lon: number
    drop_off_lon: number
    service_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Airport_servicesAvgAggregateInputType = {
    id?: true
    num_passengers?: true
    service_id?: true
  }

  export type Airport_servicesSumAggregateInputType = {
    id?: true
    num_passengers?: true
    service_id?: true
  }

  export type Airport_servicesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pickup_dropoff?: true
    pickup_date_time?: true
    num_passengers?: true
    pickup_from?: true
    dropoff_location?: true
    airline?: true
    flight_number?: true
    status?: true
    pick_up_lat?: true
    drop_off_lat?: true
    pick_up_lon?: true
    drop_off_lon?: true
    service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Airport_servicesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pickup_dropoff?: true
    pickup_date_time?: true
    num_passengers?: true
    pickup_from?: true
    dropoff_location?: true
    airline?: true
    flight_number?: true
    status?: true
    pick_up_lat?: true
    drop_off_lat?: true
    pick_up_lon?: true
    drop_off_lon?: true
    service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Airport_servicesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pickup_dropoff?: true
    pickup_date_time?: true
    num_passengers?: true
    pickup_from?: true
    dropoff_location?: true
    airline?: true
    flight_number?: true
    status?: true
    pick_up_lat?: true
    drop_off_lat?: true
    pick_up_lon?: true
    drop_off_lon?: true
    service_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Airport_servicesAggregateArgs = {
    /**
     * Filter which airport_services to aggregate.
     */
    where?: airport_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airport_services to fetch.
     */
    orderBy?: Enumerable<airport_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: airport_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airport_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airport_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned airport_services
    **/
    _count?: true | Airport_servicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Airport_servicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Airport_servicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Airport_servicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Airport_servicesMaxAggregateInputType
  }

  export type GetAirport_servicesAggregateType<T extends Airport_servicesAggregateArgs> = {
        [P in keyof T & keyof AggregateAirport_services]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAirport_services[P]>
      : GetScalarType<T[P], AggregateAirport_services[P]>
  }




  export type Airport_servicesGroupByArgs = {
    where?: airport_servicesWhereInput
    orderBy?: Enumerable<airport_servicesOrderByWithAggregationInput>
    by: Airport_servicesScalarFieldEnum[]
    having?: airport_servicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Airport_servicesCountAggregateInputType | true
    _avg?: Airport_servicesAvgAggregateInputType
    _sum?: Airport_servicesSumAggregateInputType
    _min?: Airport_servicesMinAggregateInputType
    _max?: Airport_servicesMaxAggregateInputType
  }


  export type Airport_servicesGroupByOutputType = {
    id: number
    name: string
    description: string | null
    pickup_dropoff: boolean
    pickup_date_time: Date
    num_passengers: number
    pickup_from: string
    dropoff_location: string
    airline: string | null
    flight_number: string | null
    status: boolean
    pick_up_lat: string
    drop_off_lat: string
    pick_up_lon: string
    drop_off_lon: string
    service_id: number
    created_at: Date | null
    updated_at: Date | null
    _count: Airport_servicesCountAggregateOutputType | null
    _avg: Airport_servicesAvgAggregateOutputType | null
    _sum: Airport_servicesSumAggregateOutputType | null
    _min: Airport_servicesMinAggregateOutputType | null
    _max: Airport_servicesMaxAggregateOutputType | null
  }

  type GetAirport_servicesGroupByPayload<T extends Airport_servicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Airport_servicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Airport_servicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Airport_servicesGroupByOutputType[P]>
            : GetScalarType<T[P], Airport_servicesGroupByOutputType[P]>
        }
      >
    >


  export type airport_servicesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    pickup_dropoff?: boolean
    pickup_date_time?: boolean
    num_passengers?: boolean
    pickup_from?: boolean
    dropoff_location?: boolean
    airline?: boolean
    flight_number?: boolean
    status?: boolean
    pick_up_lat?: boolean
    drop_off_lat?: boolean
    pick_up_lon?: boolean
    drop_off_lon?: boolean
    service_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    services?: boolean | servicesArgs
  }


  export type airport_servicesInclude = {
    services?: boolean | servicesArgs
  }

  export type airport_servicesGetPayload<S extends boolean | null | undefined | airport_servicesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? airport_services :
    S extends undefined ? never :
    S extends { include: any } & (airport_servicesArgs | airport_servicesFindManyArgs)
    ? airport_services  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'services' ? servicesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (airport_servicesArgs | airport_servicesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'services' ? servicesGetPayload<S['select'][P]> :  P extends keyof airport_services ? airport_services[P] : never
  } 
      : airport_services


  type airport_servicesCountArgs = 
    Omit<airport_servicesFindManyArgs, 'select' | 'include'> & {
      select?: Airport_servicesCountAggregateInputType | true
    }

  export interface airport_servicesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Airport_services that matches the filter.
     * @param {airport_servicesFindUniqueArgs} args - Arguments to find a Airport_services
     * @example
     * // Get one Airport_services
     * const airport_services = await prisma.airport_services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends airport_servicesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, airport_servicesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'airport_services'> extends True ? Prisma__airport_servicesClient<airport_servicesGetPayload<T>> : Prisma__airport_servicesClient<airport_servicesGetPayload<T> | null, null>

    /**
     * Find one Airport_services that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {airport_servicesFindUniqueOrThrowArgs} args - Arguments to find a Airport_services
     * @example
     * // Get one Airport_services
     * const airport_services = await prisma.airport_services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends airport_servicesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, airport_servicesFindUniqueOrThrowArgs>
    ): Prisma__airport_servicesClient<airport_servicesGetPayload<T>>

    /**
     * Find the first Airport_services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airport_servicesFindFirstArgs} args - Arguments to find a Airport_services
     * @example
     * // Get one Airport_services
     * const airport_services = await prisma.airport_services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends airport_servicesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, airport_servicesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'airport_services'> extends True ? Prisma__airport_servicesClient<airport_servicesGetPayload<T>> : Prisma__airport_servicesClient<airport_servicesGetPayload<T> | null, null>

    /**
     * Find the first Airport_services that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airport_servicesFindFirstOrThrowArgs} args - Arguments to find a Airport_services
     * @example
     * // Get one Airport_services
     * const airport_services = await prisma.airport_services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends airport_servicesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, airport_servicesFindFirstOrThrowArgs>
    ): Prisma__airport_servicesClient<airport_servicesGetPayload<T>>

    /**
     * Find zero or more Airport_services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airport_servicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Airport_services
     * const airport_services = await prisma.airport_services.findMany()
     * 
     * // Get first 10 Airport_services
     * const airport_services = await prisma.airport_services.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const airport_servicesWithIdOnly = await prisma.airport_services.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends airport_servicesFindManyArgs>(
      args?: SelectSubset<T, airport_servicesFindManyArgs>
    ): Prisma.PrismaPromise<Array<airport_servicesGetPayload<T>>>

    /**
     * Create a Airport_services.
     * @param {airport_servicesCreateArgs} args - Arguments to create a Airport_services.
     * @example
     * // Create one Airport_services
     * const Airport_services = await prisma.airport_services.create({
     *   data: {
     *     // ... data to create a Airport_services
     *   }
     * })
     * 
    **/
    create<T extends airport_servicesCreateArgs>(
      args: SelectSubset<T, airport_servicesCreateArgs>
    ): Prisma__airport_servicesClient<airport_servicesGetPayload<T>>

    /**
     * Create many Airport_services.
     *     @param {airport_servicesCreateManyArgs} args - Arguments to create many Airport_services.
     *     @example
     *     // Create many Airport_services
     *     const airport_services = await prisma.airport_services.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends airport_servicesCreateManyArgs>(
      args?: SelectSubset<T, airport_servicesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Airport_services.
     * @param {airport_servicesDeleteArgs} args - Arguments to delete one Airport_services.
     * @example
     * // Delete one Airport_services
     * const Airport_services = await prisma.airport_services.delete({
     *   where: {
     *     // ... filter to delete one Airport_services
     *   }
     * })
     * 
    **/
    delete<T extends airport_servicesDeleteArgs>(
      args: SelectSubset<T, airport_servicesDeleteArgs>
    ): Prisma__airport_servicesClient<airport_servicesGetPayload<T>>

    /**
     * Update one Airport_services.
     * @param {airport_servicesUpdateArgs} args - Arguments to update one Airport_services.
     * @example
     * // Update one Airport_services
     * const airport_services = await prisma.airport_services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends airport_servicesUpdateArgs>(
      args: SelectSubset<T, airport_servicesUpdateArgs>
    ): Prisma__airport_servicesClient<airport_servicesGetPayload<T>>

    /**
     * Delete zero or more Airport_services.
     * @param {airport_servicesDeleteManyArgs} args - Arguments to filter Airport_services to delete.
     * @example
     * // Delete a few Airport_services
     * const { count } = await prisma.airport_services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends airport_servicesDeleteManyArgs>(
      args?: SelectSubset<T, airport_servicesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Airport_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airport_servicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Airport_services
     * const airport_services = await prisma.airport_services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends airport_servicesUpdateManyArgs>(
      args: SelectSubset<T, airport_servicesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Airport_services.
     * @param {airport_servicesUpsertArgs} args - Arguments to update or create a Airport_services.
     * @example
     * // Update or create a Airport_services
     * const airport_services = await prisma.airport_services.upsert({
     *   create: {
     *     // ... data to create a Airport_services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Airport_services we want to update
     *   }
     * })
    **/
    upsert<T extends airport_servicesUpsertArgs>(
      args: SelectSubset<T, airport_servicesUpsertArgs>
    ): Prisma__airport_servicesClient<airport_servicesGetPayload<T>>

    /**
     * Count the number of Airport_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airport_servicesCountArgs} args - Arguments to filter Airport_services to count.
     * @example
     * // Count the number of Airport_services
     * const count = await prisma.airport_services.count({
     *   where: {
     *     // ... the filter for the Airport_services we want to count
     *   }
     * })
    **/
    count<T extends airport_servicesCountArgs>(
      args?: Subset<T, airport_servicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Airport_servicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Airport_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Airport_servicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Airport_servicesAggregateArgs>(args: Subset<T, Airport_servicesAggregateArgs>): Prisma.PrismaPromise<GetAirport_servicesAggregateType<T>>

    /**
     * Group by Airport_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Airport_servicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Airport_servicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Airport_servicesGroupByArgs['orderBy'] }
        : { orderBy?: Airport_servicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Airport_servicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAirport_servicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for airport_services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__airport_servicesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    services<T extends servicesArgs= {}>(args?: Subset<T, servicesArgs>): Prisma__servicesClient<servicesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * airport_services base type for findUnique actions
   */
  export type airport_servicesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the airport_services
     */
    select?: airport_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: airport_servicesInclude | null
    /**
     * Filter, which airport_services to fetch.
     */
    where: airport_servicesWhereUniqueInput
  }

  /**
   * airport_services findUnique
   */
  export interface airport_servicesFindUniqueArgs extends airport_servicesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * airport_services findUniqueOrThrow
   */
  export type airport_servicesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the airport_services
     */
    select?: airport_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: airport_servicesInclude | null
    /**
     * Filter, which airport_services to fetch.
     */
    where: airport_servicesWhereUniqueInput
  }


  /**
   * airport_services base type for findFirst actions
   */
  export type airport_servicesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the airport_services
     */
    select?: airport_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: airport_servicesInclude | null
    /**
     * Filter, which airport_services to fetch.
     */
    where?: airport_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airport_services to fetch.
     */
    orderBy?: Enumerable<airport_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for airport_services.
     */
    cursor?: airport_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airport_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airport_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of airport_services.
     */
    distinct?: Enumerable<Airport_servicesScalarFieldEnum>
  }

  /**
   * airport_services findFirst
   */
  export interface airport_servicesFindFirstArgs extends airport_servicesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * airport_services findFirstOrThrow
   */
  export type airport_servicesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the airport_services
     */
    select?: airport_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: airport_servicesInclude | null
    /**
     * Filter, which airport_services to fetch.
     */
    where?: airport_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airport_services to fetch.
     */
    orderBy?: Enumerable<airport_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for airport_services.
     */
    cursor?: airport_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airport_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airport_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of airport_services.
     */
    distinct?: Enumerable<Airport_servicesScalarFieldEnum>
  }


  /**
   * airport_services findMany
   */
  export type airport_servicesFindManyArgs = {
    /**
     * Select specific fields to fetch from the airport_services
     */
    select?: airport_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: airport_servicesInclude | null
    /**
     * Filter, which airport_services to fetch.
     */
    where?: airport_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airport_services to fetch.
     */
    orderBy?: Enumerable<airport_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing airport_services.
     */
    cursor?: airport_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airport_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airport_services.
     */
    skip?: number
    distinct?: Enumerable<Airport_servicesScalarFieldEnum>
  }


  /**
   * airport_services create
   */
  export type airport_servicesCreateArgs = {
    /**
     * Select specific fields to fetch from the airport_services
     */
    select?: airport_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: airport_servicesInclude | null
    /**
     * The data needed to create a airport_services.
     */
    data: XOR<airport_servicesCreateInput, airport_servicesUncheckedCreateInput>
  }


  /**
   * airport_services createMany
   */
  export type airport_servicesCreateManyArgs = {
    /**
     * The data used to create many airport_services.
     */
    data: Enumerable<airport_servicesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * airport_services update
   */
  export type airport_servicesUpdateArgs = {
    /**
     * Select specific fields to fetch from the airport_services
     */
    select?: airport_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: airport_servicesInclude | null
    /**
     * The data needed to update a airport_services.
     */
    data: XOR<airport_servicesUpdateInput, airport_servicesUncheckedUpdateInput>
    /**
     * Choose, which airport_services to update.
     */
    where: airport_servicesWhereUniqueInput
  }


  /**
   * airport_services updateMany
   */
  export type airport_servicesUpdateManyArgs = {
    /**
     * The data used to update airport_services.
     */
    data: XOR<airport_servicesUpdateManyMutationInput, airport_servicesUncheckedUpdateManyInput>
    /**
     * Filter which airport_services to update
     */
    where?: airport_servicesWhereInput
  }


  /**
   * airport_services upsert
   */
  export type airport_servicesUpsertArgs = {
    /**
     * Select specific fields to fetch from the airport_services
     */
    select?: airport_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: airport_servicesInclude | null
    /**
     * The filter to search for the airport_services to update in case it exists.
     */
    where: airport_servicesWhereUniqueInput
    /**
     * In case the airport_services found by the `where` argument doesn't exist, create a new airport_services with this data.
     */
    create: XOR<airport_servicesCreateInput, airport_servicesUncheckedCreateInput>
    /**
     * In case the airport_services was found with the provided `where` argument, update it with this data.
     */
    update: XOR<airport_servicesUpdateInput, airport_servicesUncheckedUpdateInput>
  }


  /**
   * airport_services delete
   */
  export type airport_servicesDeleteArgs = {
    /**
     * Select specific fields to fetch from the airport_services
     */
    select?: airport_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: airport_servicesInclude | null
    /**
     * Filter which airport_services to delete.
     */
    where: airport_servicesWhereUniqueInput
  }


  /**
   * airport_services deleteMany
   */
  export type airport_servicesDeleteManyArgs = {
    /**
     * Filter which airport_services to delete
     */
    where?: airport_servicesWhereInput
  }


  /**
   * airport_services without action
   */
  export type airport_servicesArgs = {
    /**
     * Select specific fields to fetch from the airport_services
     */
    select?: airport_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: airport_servicesInclude | null
  }



  /**
   * Model airports
   */


  export type AggregateAirports = {
    _count: AirportsCountAggregateOutputType | null
    _avg: AirportsAvgAggregateOutputType | null
    _sum: AirportsSumAggregateOutputType | null
    _min: AirportsMinAggregateOutputType | null
    _max: AirportsMaxAggregateOutputType | null
  }

  export type AirportsAvgAggregateOutputType = {
    id: number | null
  }

  export type AirportsSumAggregateOutputType = {
    id: number | null
  }

  export type AirportsMinAggregateOutputType = {
    id: number | null
    name: string | null
    city: string | null
    country: string | null
    iata: string | null
    icao: string | null
    latitude: string | null
    longitude: string | null
    altitude: string | null
    timezone: string | null
    dst: string | null
    tz_database_time_zone: string | null
    Type: string | null
    Source: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AirportsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    city: string | null
    country: string | null
    iata: string | null
    icao: string | null
    latitude: string | null
    longitude: string | null
    altitude: string | null
    timezone: string | null
    dst: string | null
    tz_database_time_zone: string | null
    Type: string | null
    Source: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AirportsCountAggregateOutputType = {
    id: number
    name: number
    city: number
    country: number
    iata: number
    icao: number
    latitude: number
    longitude: number
    altitude: number
    timezone: number
    dst: number
    tz_database_time_zone: number
    Type: number
    Source: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AirportsAvgAggregateInputType = {
    id?: true
  }

  export type AirportsSumAggregateInputType = {
    id?: true
  }

  export type AirportsMinAggregateInputType = {
    id?: true
    name?: true
    city?: true
    country?: true
    iata?: true
    icao?: true
    latitude?: true
    longitude?: true
    altitude?: true
    timezone?: true
    dst?: true
    tz_database_time_zone?: true
    Type?: true
    Source?: true
    created_at?: true
    updated_at?: true
  }

  export type AirportsMaxAggregateInputType = {
    id?: true
    name?: true
    city?: true
    country?: true
    iata?: true
    icao?: true
    latitude?: true
    longitude?: true
    altitude?: true
    timezone?: true
    dst?: true
    tz_database_time_zone?: true
    Type?: true
    Source?: true
    created_at?: true
    updated_at?: true
  }

  export type AirportsCountAggregateInputType = {
    id?: true
    name?: true
    city?: true
    country?: true
    iata?: true
    icao?: true
    latitude?: true
    longitude?: true
    altitude?: true
    timezone?: true
    dst?: true
    tz_database_time_zone?: true
    Type?: true
    Source?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AirportsAggregateArgs = {
    /**
     * Filter which airports to aggregate.
     */
    where?: airportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     */
    orderBy?: Enumerable<airportsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: airportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned airports
    **/
    _count?: true | AirportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AirportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AirportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AirportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AirportsMaxAggregateInputType
  }

  export type GetAirportsAggregateType<T extends AirportsAggregateArgs> = {
        [P in keyof T & keyof AggregateAirports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAirports[P]>
      : GetScalarType<T[P], AggregateAirports[P]>
  }




  export type AirportsGroupByArgs = {
    where?: airportsWhereInput
    orderBy?: Enumerable<airportsOrderByWithAggregationInput>
    by: AirportsScalarFieldEnum[]
    having?: airportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AirportsCountAggregateInputType | true
    _avg?: AirportsAvgAggregateInputType
    _sum?: AirportsSumAggregateInputType
    _min?: AirportsMinAggregateInputType
    _max?: AirportsMaxAggregateInputType
  }


  export type AirportsGroupByOutputType = {
    id: number
    name: string | null
    city: string | null
    country: string | null
    iata: string | null
    icao: string | null
    latitude: string | null
    longitude: string | null
    altitude: string | null
    timezone: string | null
    dst: string | null
    tz_database_time_zone: string | null
    Type: string | null
    Source: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: AirportsCountAggregateOutputType | null
    _avg: AirportsAvgAggregateOutputType | null
    _sum: AirportsSumAggregateOutputType | null
    _min: AirportsMinAggregateOutputType | null
    _max: AirportsMaxAggregateOutputType | null
  }

  type GetAirportsGroupByPayload<T extends AirportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AirportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AirportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AirportsGroupByOutputType[P]>
            : GetScalarType<T[P], AirportsGroupByOutputType[P]>
        }
      >
    >


  export type airportsSelect = {
    id?: boolean
    name?: boolean
    city?: boolean
    country?: boolean
    iata?: boolean
    icao?: boolean
    latitude?: boolean
    longitude?: boolean
    altitude?: boolean
    timezone?: boolean
    dst?: boolean
    tz_database_time_zone?: boolean
    Type?: boolean
    Source?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type airportsGetPayload<S extends boolean | null | undefined | airportsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? airports :
    S extends undefined ? never :
    S extends { include: any } & (airportsArgs | airportsFindManyArgs)
    ? airports 
    : S extends { select: any } & (airportsArgs | airportsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof airports ? airports[P] : never
  } 
      : airports


  type airportsCountArgs = 
    Omit<airportsFindManyArgs, 'select' | 'include'> & {
      select?: AirportsCountAggregateInputType | true
    }

  export interface airportsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Airports that matches the filter.
     * @param {airportsFindUniqueArgs} args - Arguments to find a Airports
     * @example
     * // Get one Airports
     * const airports = await prisma.airports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends airportsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, airportsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'airports'> extends True ? Prisma__airportsClient<airportsGetPayload<T>> : Prisma__airportsClient<airportsGetPayload<T> | null, null>

    /**
     * Find one Airports that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {airportsFindUniqueOrThrowArgs} args - Arguments to find a Airports
     * @example
     * // Get one Airports
     * const airports = await prisma.airports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends airportsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, airportsFindUniqueOrThrowArgs>
    ): Prisma__airportsClient<airportsGetPayload<T>>

    /**
     * Find the first Airports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportsFindFirstArgs} args - Arguments to find a Airports
     * @example
     * // Get one Airports
     * const airports = await prisma.airports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends airportsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, airportsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'airports'> extends True ? Prisma__airportsClient<airportsGetPayload<T>> : Prisma__airportsClient<airportsGetPayload<T> | null, null>

    /**
     * Find the first Airports that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportsFindFirstOrThrowArgs} args - Arguments to find a Airports
     * @example
     * // Get one Airports
     * const airports = await prisma.airports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends airportsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, airportsFindFirstOrThrowArgs>
    ): Prisma__airportsClient<airportsGetPayload<T>>

    /**
     * Find zero or more Airports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Airports
     * const airports = await prisma.airports.findMany()
     * 
     * // Get first 10 Airports
     * const airports = await prisma.airports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const airportsWithIdOnly = await prisma.airports.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends airportsFindManyArgs>(
      args?: SelectSubset<T, airportsFindManyArgs>
    ): Prisma.PrismaPromise<Array<airportsGetPayload<T>>>

    /**
     * Create a Airports.
     * @param {airportsCreateArgs} args - Arguments to create a Airports.
     * @example
     * // Create one Airports
     * const Airports = await prisma.airports.create({
     *   data: {
     *     // ... data to create a Airports
     *   }
     * })
     * 
    **/
    create<T extends airportsCreateArgs>(
      args: SelectSubset<T, airportsCreateArgs>
    ): Prisma__airportsClient<airportsGetPayload<T>>

    /**
     * Create many Airports.
     *     @param {airportsCreateManyArgs} args - Arguments to create many Airports.
     *     @example
     *     // Create many Airports
     *     const airports = await prisma.airports.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends airportsCreateManyArgs>(
      args?: SelectSubset<T, airportsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Airports.
     * @param {airportsDeleteArgs} args - Arguments to delete one Airports.
     * @example
     * // Delete one Airports
     * const Airports = await prisma.airports.delete({
     *   where: {
     *     // ... filter to delete one Airports
     *   }
     * })
     * 
    **/
    delete<T extends airportsDeleteArgs>(
      args: SelectSubset<T, airportsDeleteArgs>
    ): Prisma__airportsClient<airportsGetPayload<T>>

    /**
     * Update one Airports.
     * @param {airportsUpdateArgs} args - Arguments to update one Airports.
     * @example
     * // Update one Airports
     * const airports = await prisma.airports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends airportsUpdateArgs>(
      args: SelectSubset<T, airportsUpdateArgs>
    ): Prisma__airportsClient<airportsGetPayload<T>>

    /**
     * Delete zero or more Airports.
     * @param {airportsDeleteManyArgs} args - Arguments to filter Airports to delete.
     * @example
     * // Delete a few Airports
     * const { count } = await prisma.airports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends airportsDeleteManyArgs>(
      args?: SelectSubset<T, airportsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Airports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Airports
     * const airports = await prisma.airports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends airportsUpdateManyArgs>(
      args: SelectSubset<T, airportsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Airports.
     * @param {airportsUpsertArgs} args - Arguments to update or create a Airports.
     * @example
     * // Update or create a Airports
     * const airports = await prisma.airports.upsert({
     *   create: {
     *     // ... data to create a Airports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Airports we want to update
     *   }
     * })
    **/
    upsert<T extends airportsUpsertArgs>(
      args: SelectSubset<T, airportsUpsertArgs>
    ): Prisma__airportsClient<airportsGetPayload<T>>

    /**
     * Count the number of Airports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportsCountArgs} args - Arguments to filter Airports to count.
     * @example
     * // Count the number of Airports
     * const count = await prisma.airports.count({
     *   where: {
     *     // ... the filter for the Airports we want to count
     *   }
     * })
    **/
    count<T extends airportsCountArgs>(
      args?: Subset<T, airportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AirportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Airports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AirportsAggregateArgs>(args: Subset<T, AirportsAggregateArgs>): Prisma.PrismaPromise<GetAirportsAggregateType<T>>

    /**
     * Group by Airports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AirportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AirportsGroupByArgs['orderBy'] }
        : { orderBy?: AirportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AirportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAirportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for airports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__airportsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * airports base type for findUnique actions
   */
  export type airportsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the airports
     */
    select?: airportsSelect | null
    /**
     * Filter, which airports to fetch.
     */
    where: airportsWhereUniqueInput
  }

  /**
   * airports findUnique
   */
  export interface airportsFindUniqueArgs extends airportsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * airports findUniqueOrThrow
   */
  export type airportsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the airports
     */
    select?: airportsSelect | null
    /**
     * Filter, which airports to fetch.
     */
    where: airportsWhereUniqueInput
  }


  /**
   * airports base type for findFirst actions
   */
  export type airportsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the airports
     */
    select?: airportsSelect | null
    /**
     * Filter, which airports to fetch.
     */
    where?: airportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     */
    orderBy?: Enumerable<airportsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for airports.
     */
    cursor?: airportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of airports.
     */
    distinct?: Enumerable<AirportsScalarFieldEnum>
  }

  /**
   * airports findFirst
   */
  export interface airportsFindFirstArgs extends airportsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * airports findFirstOrThrow
   */
  export type airportsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the airports
     */
    select?: airportsSelect | null
    /**
     * Filter, which airports to fetch.
     */
    where?: airportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     */
    orderBy?: Enumerable<airportsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for airports.
     */
    cursor?: airportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of airports.
     */
    distinct?: Enumerable<AirportsScalarFieldEnum>
  }


  /**
   * airports findMany
   */
  export type airportsFindManyArgs = {
    /**
     * Select specific fields to fetch from the airports
     */
    select?: airportsSelect | null
    /**
     * Filter, which airports to fetch.
     */
    where?: airportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     */
    orderBy?: Enumerable<airportsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing airports.
     */
    cursor?: airportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     */
    skip?: number
    distinct?: Enumerable<AirportsScalarFieldEnum>
  }


  /**
   * airports create
   */
  export type airportsCreateArgs = {
    /**
     * Select specific fields to fetch from the airports
     */
    select?: airportsSelect | null
    /**
     * The data needed to create a airports.
     */
    data: XOR<airportsCreateInput, airportsUncheckedCreateInput>
  }


  /**
   * airports createMany
   */
  export type airportsCreateManyArgs = {
    /**
     * The data used to create many airports.
     */
    data: Enumerable<airportsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * airports update
   */
  export type airportsUpdateArgs = {
    /**
     * Select specific fields to fetch from the airports
     */
    select?: airportsSelect | null
    /**
     * The data needed to update a airports.
     */
    data: XOR<airportsUpdateInput, airportsUncheckedUpdateInput>
    /**
     * Choose, which airports to update.
     */
    where: airportsWhereUniqueInput
  }


  /**
   * airports updateMany
   */
  export type airportsUpdateManyArgs = {
    /**
     * The data used to update airports.
     */
    data: XOR<airportsUpdateManyMutationInput, airportsUncheckedUpdateManyInput>
    /**
     * Filter which airports to update
     */
    where?: airportsWhereInput
  }


  /**
   * airports upsert
   */
  export type airportsUpsertArgs = {
    /**
     * Select specific fields to fetch from the airports
     */
    select?: airportsSelect | null
    /**
     * The filter to search for the airports to update in case it exists.
     */
    where: airportsWhereUniqueInput
    /**
     * In case the airports found by the `where` argument doesn't exist, create a new airports with this data.
     */
    create: XOR<airportsCreateInput, airportsUncheckedCreateInput>
    /**
     * In case the airports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<airportsUpdateInput, airportsUncheckedUpdateInput>
  }


  /**
   * airports delete
   */
  export type airportsDeleteArgs = {
    /**
     * Select specific fields to fetch from the airports
     */
    select?: airportsSelect | null
    /**
     * Filter which airports to delete.
     */
    where: airportsWhereUniqueInput
  }


  /**
   * airports deleteMany
   */
  export type airportsDeleteManyArgs = {
    /**
     * Filter which airports to delete
     */
    where?: airportsWhereInput
  }


  /**
   * airports without action
   */
  export type airportsArgs = {
    /**
     * Select specific fields to fetch from the airports
     */
    select?: airportsSelect | null
  }



  /**
   * Model blog_categories
   */


  export type AggregateBlog_categories = {
    _count: Blog_categoriesCountAggregateOutputType | null
    _avg: Blog_categoriesAvgAggregateOutputType | null
    _sum: Blog_categoriesSumAggregateOutputType | null
    _min: Blog_categoriesMinAggregateOutputType | null
    _max: Blog_categoriesMaxAggregateOutputType | null
  }

  export type Blog_categoriesAvgAggregateOutputType = {
    id: number | null
  }

  export type Blog_categoriesSumAggregateOutputType = {
    id: number | null
  }

  export type Blog_categoriesMinAggregateOutputType = {
    id: number | null
    title: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Blog_categoriesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Blog_categoriesCountAggregateOutputType = {
    id: number
    title: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Blog_categoriesAvgAggregateInputType = {
    id?: true
  }

  export type Blog_categoriesSumAggregateInputType = {
    id?: true
  }

  export type Blog_categoriesMinAggregateInputType = {
    id?: true
    title?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Blog_categoriesMaxAggregateInputType = {
    id?: true
    title?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Blog_categoriesCountAggregateInputType = {
    id?: true
    title?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Blog_categoriesAggregateArgs = {
    /**
     * Filter which blog_categories to aggregate.
     */
    where?: blog_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_categories to fetch.
     */
    orderBy?: Enumerable<blog_categoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blog_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blog_categories
    **/
    _count?: true | Blog_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Blog_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Blog_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Blog_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Blog_categoriesMaxAggregateInputType
  }

  export type GetBlog_categoriesAggregateType<T extends Blog_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog_categories[P]>
      : GetScalarType<T[P], AggregateBlog_categories[P]>
  }




  export type Blog_categoriesGroupByArgs = {
    where?: blog_categoriesWhereInput
    orderBy?: Enumerable<blog_categoriesOrderByWithAggregationInput>
    by: Blog_categoriesScalarFieldEnum[]
    having?: blog_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Blog_categoriesCountAggregateInputType | true
    _avg?: Blog_categoriesAvgAggregateInputType
    _sum?: Blog_categoriesSumAggregateInputType
    _min?: Blog_categoriesMinAggregateInputType
    _max?: Blog_categoriesMaxAggregateInputType
  }


  export type Blog_categoriesGroupByOutputType = {
    id: number
    title: string
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: Blog_categoriesCountAggregateOutputType | null
    _avg: Blog_categoriesAvgAggregateOutputType | null
    _sum: Blog_categoriesSumAggregateOutputType | null
    _min: Blog_categoriesMinAggregateOutputType | null
    _max: Blog_categoriesMaxAggregateOutputType | null
  }

  type GetBlog_categoriesGroupByPayload<T extends Blog_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Blog_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Blog_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Blog_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Blog_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type blog_categoriesSelect = {
    id?: boolean
    title?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }


  export type blog_categoriesGetPayload<S extends boolean | null | undefined | blog_categoriesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? blog_categories :
    S extends undefined ? never :
    S extends { include: any } & (blog_categoriesArgs | blog_categoriesFindManyArgs)
    ? blog_categories 
    : S extends { select: any } & (blog_categoriesArgs | blog_categoriesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof blog_categories ? blog_categories[P] : never
  } 
      : blog_categories


  type blog_categoriesCountArgs = 
    Omit<blog_categoriesFindManyArgs, 'select' | 'include'> & {
      select?: Blog_categoriesCountAggregateInputType | true
    }

  export interface blog_categoriesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Blog_categories that matches the filter.
     * @param {blog_categoriesFindUniqueArgs} args - Arguments to find a Blog_categories
     * @example
     * // Get one Blog_categories
     * const blog_categories = await prisma.blog_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends blog_categoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, blog_categoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'blog_categories'> extends True ? Prisma__blog_categoriesClient<blog_categoriesGetPayload<T>> : Prisma__blog_categoriesClient<blog_categoriesGetPayload<T> | null, null>

    /**
     * Find one Blog_categories that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {blog_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Blog_categories
     * @example
     * // Get one Blog_categories
     * const blog_categories = await prisma.blog_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends blog_categoriesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, blog_categoriesFindUniqueOrThrowArgs>
    ): Prisma__blog_categoriesClient<blog_categoriesGetPayload<T>>

    /**
     * Find the first Blog_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_categoriesFindFirstArgs} args - Arguments to find a Blog_categories
     * @example
     * // Get one Blog_categories
     * const blog_categories = await prisma.blog_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends blog_categoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, blog_categoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'blog_categories'> extends True ? Prisma__blog_categoriesClient<blog_categoriesGetPayload<T>> : Prisma__blog_categoriesClient<blog_categoriesGetPayload<T> | null, null>

    /**
     * Find the first Blog_categories that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_categoriesFindFirstOrThrowArgs} args - Arguments to find a Blog_categories
     * @example
     * // Get one Blog_categories
     * const blog_categories = await prisma.blog_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends blog_categoriesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, blog_categoriesFindFirstOrThrowArgs>
    ): Prisma__blog_categoriesClient<blog_categoriesGetPayload<T>>

    /**
     * Find zero or more Blog_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_categoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blog_categories
     * const blog_categories = await prisma.blog_categories.findMany()
     * 
     * // Get first 10 Blog_categories
     * const blog_categories = await prisma.blog_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blog_categoriesWithIdOnly = await prisma.blog_categories.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends blog_categoriesFindManyArgs>(
      args?: SelectSubset<T, blog_categoriesFindManyArgs>
    ): Prisma.PrismaPromise<Array<blog_categoriesGetPayload<T>>>

    /**
     * Create a Blog_categories.
     * @param {blog_categoriesCreateArgs} args - Arguments to create a Blog_categories.
     * @example
     * // Create one Blog_categories
     * const Blog_categories = await prisma.blog_categories.create({
     *   data: {
     *     // ... data to create a Blog_categories
     *   }
     * })
     * 
    **/
    create<T extends blog_categoriesCreateArgs>(
      args: SelectSubset<T, blog_categoriesCreateArgs>
    ): Prisma__blog_categoriesClient<blog_categoriesGetPayload<T>>

    /**
     * Create many Blog_categories.
     *     @param {blog_categoriesCreateManyArgs} args - Arguments to create many Blog_categories.
     *     @example
     *     // Create many Blog_categories
     *     const blog_categories = await prisma.blog_categories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends blog_categoriesCreateManyArgs>(
      args?: SelectSubset<T, blog_categoriesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blog_categories.
     * @param {blog_categoriesDeleteArgs} args - Arguments to delete one Blog_categories.
     * @example
     * // Delete one Blog_categories
     * const Blog_categories = await prisma.blog_categories.delete({
     *   where: {
     *     // ... filter to delete one Blog_categories
     *   }
     * })
     * 
    **/
    delete<T extends blog_categoriesDeleteArgs>(
      args: SelectSubset<T, blog_categoriesDeleteArgs>
    ): Prisma__blog_categoriesClient<blog_categoriesGetPayload<T>>

    /**
     * Update one Blog_categories.
     * @param {blog_categoriesUpdateArgs} args - Arguments to update one Blog_categories.
     * @example
     * // Update one Blog_categories
     * const blog_categories = await prisma.blog_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends blog_categoriesUpdateArgs>(
      args: SelectSubset<T, blog_categoriesUpdateArgs>
    ): Prisma__blog_categoriesClient<blog_categoriesGetPayload<T>>

    /**
     * Delete zero or more Blog_categories.
     * @param {blog_categoriesDeleteManyArgs} args - Arguments to filter Blog_categories to delete.
     * @example
     * // Delete a few Blog_categories
     * const { count } = await prisma.blog_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends blog_categoriesDeleteManyArgs>(
      args?: SelectSubset<T, blog_categoriesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blog_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blog_categories
     * const blog_categories = await prisma.blog_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends blog_categoriesUpdateManyArgs>(
      args: SelectSubset<T, blog_categoriesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog_categories.
     * @param {blog_categoriesUpsertArgs} args - Arguments to update or create a Blog_categories.
     * @example
     * // Update or create a Blog_categories
     * const blog_categories = await prisma.blog_categories.upsert({
     *   create: {
     *     // ... data to create a Blog_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog_categories we want to update
     *   }
     * })
    **/
    upsert<T extends blog_categoriesUpsertArgs>(
      args: SelectSubset<T, blog_categoriesUpsertArgs>
    ): Prisma__blog_categoriesClient<blog_categoriesGetPayload<T>>

    /**
     * Count the number of Blog_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_categoriesCountArgs} args - Arguments to filter Blog_categories to count.
     * @example
     * // Count the number of Blog_categories
     * const count = await prisma.blog_categories.count({
     *   where: {
     *     // ... the filter for the Blog_categories we want to count
     *   }
     * })
    **/
    count<T extends blog_categoriesCountArgs>(
      args?: Subset<T, blog_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Blog_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Blog_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Blog_categoriesAggregateArgs>(args: Subset<T, Blog_categoriesAggregateArgs>): Prisma.PrismaPromise<GetBlog_categoriesAggregateType<T>>

    /**
     * Group by Blog_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Blog_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Blog_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Blog_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: Blog_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Blog_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlog_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for blog_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__blog_categoriesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * blog_categories base type for findUnique actions
   */
  export type blog_categoriesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect | null
    /**
     * Filter, which blog_categories to fetch.
     */
    where: blog_categoriesWhereUniqueInput
  }

  /**
   * blog_categories findUnique
   */
  export interface blog_categoriesFindUniqueArgs extends blog_categoriesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * blog_categories findUniqueOrThrow
   */
  export type blog_categoriesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect | null
    /**
     * Filter, which blog_categories to fetch.
     */
    where: blog_categoriesWhereUniqueInput
  }


  /**
   * blog_categories base type for findFirst actions
   */
  export type blog_categoriesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect | null
    /**
     * Filter, which blog_categories to fetch.
     */
    where?: blog_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_categories to fetch.
     */
    orderBy?: Enumerable<blog_categoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_categories.
     */
    cursor?: blog_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_categories.
     */
    distinct?: Enumerable<Blog_categoriesScalarFieldEnum>
  }

  /**
   * blog_categories findFirst
   */
  export interface blog_categoriesFindFirstArgs extends blog_categoriesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * blog_categories findFirstOrThrow
   */
  export type blog_categoriesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect | null
    /**
     * Filter, which blog_categories to fetch.
     */
    where?: blog_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_categories to fetch.
     */
    orderBy?: Enumerable<blog_categoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_categories.
     */
    cursor?: blog_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_categories.
     */
    distinct?: Enumerable<Blog_categoriesScalarFieldEnum>
  }


  /**
   * blog_categories findMany
   */
  export type blog_categoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect | null
    /**
     * Filter, which blog_categories to fetch.
     */
    where?: blog_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_categories to fetch.
     */
    orderBy?: Enumerable<blog_categoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blog_categories.
     */
    cursor?: blog_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_categories.
     */
    skip?: number
    distinct?: Enumerable<Blog_categoriesScalarFieldEnum>
  }


  /**
   * blog_categories create
   */
  export type blog_categoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect | null
    /**
     * The data needed to create a blog_categories.
     */
    data: XOR<blog_categoriesCreateInput, blog_categoriesUncheckedCreateInput>
  }


  /**
   * blog_categories createMany
   */
  export type blog_categoriesCreateManyArgs = {
    /**
     * The data used to create many blog_categories.
     */
    data: Enumerable<blog_categoriesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * blog_categories update
   */
  export type blog_categoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect | null
    /**
     * The data needed to update a blog_categories.
     */
    data: XOR<blog_categoriesUpdateInput, blog_categoriesUncheckedUpdateInput>
    /**
     * Choose, which blog_categories to update.
     */
    where: blog_categoriesWhereUniqueInput
  }


  /**
   * blog_categories updateMany
   */
  export type blog_categoriesUpdateManyArgs = {
    /**
     * The data used to update blog_categories.
     */
    data: XOR<blog_categoriesUpdateManyMutationInput, blog_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which blog_categories to update
     */
    where?: blog_categoriesWhereInput
  }


  /**
   * blog_categories upsert
   */
  export type blog_categoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect | null
    /**
     * The filter to search for the blog_categories to update in case it exists.
     */
    where: blog_categoriesWhereUniqueInput
    /**
     * In case the blog_categories found by the `where` argument doesn't exist, create a new blog_categories with this data.
     */
    create: XOR<blog_categoriesCreateInput, blog_categoriesUncheckedCreateInput>
    /**
     * In case the blog_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blog_categoriesUpdateInput, blog_categoriesUncheckedUpdateInput>
  }


  /**
   * blog_categories delete
   */
  export type blog_categoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect | null
    /**
     * Filter which blog_categories to delete.
     */
    where: blog_categoriesWhereUniqueInput
  }


  /**
   * blog_categories deleteMany
   */
  export type blog_categoriesDeleteManyArgs = {
    /**
     * Filter which blog_categories to delete
     */
    where?: blog_categoriesWhereInput
  }


  /**
   * blog_categories without action
   */
  export type blog_categoriesArgs = {
    /**
     * Select specific fields to fetch from the blog_categories
     */
    select?: blog_categoriesSelect | null
  }



  /**
   * Model blog_comments
   */


  export type AggregateBlog_comments = {
    _count: Blog_commentsCountAggregateOutputType | null
    _avg: Blog_commentsAvgAggregateOutputType | null
    _sum: Blog_commentsSumAggregateOutputType | null
    _min: Blog_commentsMinAggregateOutputType | null
    _max: Blog_commentsMaxAggregateOutputType | null
  }

  export type Blog_commentsAvgAggregateOutputType = {
    id: number | null
    blog_id: number | null
  }

  export type Blog_commentsSumAggregateOutputType = {
    id: number | null
    blog_id: number | null
  }

  export type Blog_commentsMinAggregateOutputType = {
    id: number | null
    blog_id: number | null
    name: string | null
    email: string | null
    website: string | null
    comment: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Blog_commentsMaxAggregateOutputType = {
    id: number | null
    blog_id: number | null
    name: string | null
    email: string | null
    website: string | null
    comment: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Blog_commentsCountAggregateOutputType = {
    id: number
    blog_id: number
    name: number
    email: number
    website: number
    comment: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Blog_commentsAvgAggregateInputType = {
    id?: true
    blog_id?: true
  }

  export type Blog_commentsSumAggregateInputType = {
    id?: true
    blog_id?: true
  }

  export type Blog_commentsMinAggregateInputType = {
    id?: true
    blog_id?: true
    name?: true
    email?: true
    website?: true
    comment?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Blog_commentsMaxAggregateInputType = {
    id?: true
    blog_id?: true
    name?: true
    email?: true
    website?: true
    comment?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Blog_commentsCountAggregateInputType = {
    id?: true
    blog_id?: true
    name?: true
    email?: true
    website?: true
    comment?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Blog_commentsAggregateArgs = {
    /**
     * Filter which blog_comments to aggregate.
     */
    where?: blog_commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_comments to fetch.
     */
    orderBy?: Enumerable<blog_commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blog_commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blog_comments
    **/
    _count?: true | Blog_commentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Blog_commentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Blog_commentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Blog_commentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Blog_commentsMaxAggregateInputType
  }

  export type GetBlog_commentsAggregateType<T extends Blog_commentsAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog_comments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog_comments[P]>
      : GetScalarType<T[P], AggregateBlog_comments[P]>
  }




  export type Blog_commentsGroupByArgs = {
    where?: blog_commentsWhereInput
    orderBy?: Enumerable<blog_commentsOrderByWithAggregationInput>
    by: Blog_commentsScalarFieldEnum[]
    having?: blog_commentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Blog_commentsCountAggregateInputType | true
    _avg?: Blog_commentsAvgAggregateInputType
    _sum?: Blog_commentsSumAggregateInputType
    _min?: Blog_commentsMinAggregateInputType
    _max?: Blog_commentsMaxAggregateInputType
  }


  export type Blog_commentsGroupByOutputType = {
    id: number
    blog_id: number
    name: string
    email: string
    website: string | null
    comment: string
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: Blog_commentsCountAggregateOutputType | null
    _avg: Blog_commentsAvgAggregateOutputType | null
    _sum: Blog_commentsSumAggregateOutputType | null
    _min: Blog_commentsMinAggregateOutputType | null
    _max: Blog_commentsMaxAggregateOutputType | null
  }

  type GetBlog_commentsGroupByPayload<T extends Blog_commentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Blog_commentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Blog_commentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Blog_commentsGroupByOutputType[P]>
            : GetScalarType<T[P], Blog_commentsGroupByOutputType[P]>
        }
      >
    >


  export type blog_commentsSelect = {
    id?: boolean
    blog_id?: boolean
    name?: boolean
    email?: boolean
    website?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }


  export type blog_commentsGetPayload<S extends boolean | null | undefined | blog_commentsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? blog_comments :
    S extends undefined ? never :
    S extends { include: any } & (blog_commentsArgs | blog_commentsFindManyArgs)
    ? blog_comments 
    : S extends { select: any } & (blog_commentsArgs | blog_commentsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof blog_comments ? blog_comments[P] : never
  } 
      : blog_comments


  type blog_commentsCountArgs = 
    Omit<blog_commentsFindManyArgs, 'select' | 'include'> & {
      select?: Blog_commentsCountAggregateInputType | true
    }

  export interface blog_commentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Blog_comments that matches the filter.
     * @param {blog_commentsFindUniqueArgs} args - Arguments to find a Blog_comments
     * @example
     * // Get one Blog_comments
     * const blog_comments = await prisma.blog_comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends blog_commentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, blog_commentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'blog_comments'> extends True ? Prisma__blog_commentsClient<blog_commentsGetPayload<T>> : Prisma__blog_commentsClient<blog_commentsGetPayload<T> | null, null>

    /**
     * Find one Blog_comments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {blog_commentsFindUniqueOrThrowArgs} args - Arguments to find a Blog_comments
     * @example
     * // Get one Blog_comments
     * const blog_comments = await prisma.blog_comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends blog_commentsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, blog_commentsFindUniqueOrThrowArgs>
    ): Prisma__blog_commentsClient<blog_commentsGetPayload<T>>

    /**
     * Find the first Blog_comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_commentsFindFirstArgs} args - Arguments to find a Blog_comments
     * @example
     * // Get one Blog_comments
     * const blog_comments = await prisma.blog_comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends blog_commentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, blog_commentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'blog_comments'> extends True ? Prisma__blog_commentsClient<blog_commentsGetPayload<T>> : Prisma__blog_commentsClient<blog_commentsGetPayload<T> | null, null>

    /**
     * Find the first Blog_comments that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_commentsFindFirstOrThrowArgs} args - Arguments to find a Blog_comments
     * @example
     * // Get one Blog_comments
     * const blog_comments = await prisma.blog_comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends blog_commentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, blog_commentsFindFirstOrThrowArgs>
    ): Prisma__blog_commentsClient<blog_commentsGetPayload<T>>

    /**
     * Find zero or more Blog_comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_commentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blog_comments
     * const blog_comments = await prisma.blog_comments.findMany()
     * 
     * // Get first 10 Blog_comments
     * const blog_comments = await prisma.blog_comments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blog_commentsWithIdOnly = await prisma.blog_comments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends blog_commentsFindManyArgs>(
      args?: SelectSubset<T, blog_commentsFindManyArgs>
    ): Prisma.PrismaPromise<Array<blog_commentsGetPayload<T>>>

    /**
     * Create a Blog_comments.
     * @param {blog_commentsCreateArgs} args - Arguments to create a Blog_comments.
     * @example
     * // Create one Blog_comments
     * const Blog_comments = await prisma.blog_comments.create({
     *   data: {
     *     // ... data to create a Blog_comments
     *   }
     * })
     * 
    **/
    create<T extends blog_commentsCreateArgs>(
      args: SelectSubset<T, blog_commentsCreateArgs>
    ): Prisma__blog_commentsClient<blog_commentsGetPayload<T>>

    /**
     * Create many Blog_comments.
     *     @param {blog_commentsCreateManyArgs} args - Arguments to create many Blog_comments.
     *     @example
     *     // Create many Blog_comments
     *     const blog_comments = await prisma.blog_comments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends blog_commentsCreateManyArgs>(
      args?: SelectSubset<T, blog_commentsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blog_comments.
     * @param {blog_commentsDeleteArgs} args - Arguments to delete one Blog_comments.
     * @example
     * // Delete one Blog_comments
     * const Blog_comments = await prisma.blog_comments.delete({
     *   where: {
     *     // ... filter to delete one Blog_comments
     *   }
     * })
     * 
    **/
    delete<T extends blog_commentsDeleteArgs>(
      args: SelectSubset<T, blog_commentsDeleteArgs>
    ): Prisma__blog_commentsClient<blog_commentsGetPayload<T>>

    /**
     * Update one Blog_comments.
     * @param {blog_commentsUpdateArgs} args - Arguments to update one Blog_comments.
     * @example
     * // Update one Blog_comments
     * const blog_comments = await prisma.blog_comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends blog_commentsUpdateArgs>(
      args: SelectSubset<T, blog_commentsUpdateArgs>
    ): Prisma__blog_commentsClient<blog_commentsGetPayload<T>>

    /**
     * Delete zero or more Blog_comments.
     * @param {blog_commentsDeleteManyArgs} args - Arguments to filter Blog_comments to delete.
     * @example
     * // Delete a few Blog_comments
     * const { count } = await prisma.blog_comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends blog_commentsDeleteManyArgs>(
      args?: SelectSubset<T, blog_commentsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blog_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_commentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blog_comments
     * const blog_comments = await prisma.blog_comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends blog_commentsUpdateManyArgs>(
      args: SelectSubset<T, blog_commentsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog_comments.
     * @param {blog_commentsUpsertArgs} args - Arguments to update or create a Blog_comments.
     * @example
     * // Update or create a Blog_comments
     * const blog_comments = await prisma.blog_comments.upsert({
     *   create: {
     *     // ... data to create a Blog_comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog_comments we want to update
     *   }
     * })
    **/
    upsert<T extends blog_commentsUpsertArgs>(
      args: SelectSubset<T, blog_commentsUpsertArgs>
    ): Prisma__blog_commentsClient<blog_commentsGetPayload<T>>

    /**
     * Count the number of Blog_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blog_commentsCountArgs} args - Arguments to filter Blog_comments to count.
     * @example
     * // Count the number of Blog_comments
     * const count = await prisma.blog_comments.count({
     *   where: {
     *     // ... the filter for the Blog_comments we want to count
     *   }
     * })
    **/
    count<T extends blog_commentsCountArgs>(
      args?: Subset<T, blog_commentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Blog_commentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Blog_commentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Blog_commentsAggregateArgs>(args: Subset<T, Blog_commentsAggregateArgs>): Prisma.PrismaPromise<GetBlog_commentsAggregateType<T>>

    /**
     * Group by Blog_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Blog_commentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Blog_commentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Blog_commentsGroupByArgs['orderBy'] }
        : { orderBy?: Blog_commentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Blog_commentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlog_commentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for blog_comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__blog_commentsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * blog_comments base type for findUnique actions
   */
  export type blog_commentsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the blog_comments
     */
    select?: blog_commentsSelect | null
    /**
     * Filter, which blog_comments to fetch.
     */
    where: blog_commentsWhereUniqueInput
  }

  /**
   * blog_comments findUnique
   */
  export interface blog_commentsFindUniqueArgs extends blog_commentsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * blog_comments findUniqueOrThrow
   */
  export type blog_commentsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the blog_comments
     */
    select?: blog_commentsSelect | null
    /**
     * Filter, which blog_comments to fetch.
     */
    where: blog_commentsWhereUniqueInput
  }


  /**
   * blog_comments base type for findFirst actions
   */
  export type blog_commentsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the blog_comments
     */
    select?: blog_commentsSelect | null
    /**
     * Filter, which blog_comments to fetch.
     */
    where?: blog_commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_comments to fetch.
     */
    orderBy?: Enumerable<blog_commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_comments.
     */
    cursor?: blog_commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_comments.
     */
    distinct?: Enumerable<Blog_commentsScalarFieldEnum>
  }

  /**
   * blog_comments findFirst
   */
  export interface blog_commentsFindFirstArgs extends blog_commentsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * blog_comments findFirstOrThrow
   */
  export type blog_commentsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the blog_comments
     */
    select?: blog_commentsSelect | null
    /**
     * Filter, which blog_comments to fetch.
     */
    where?: blog_commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_comments to fetch.
     */
    orderBy?: Enumerable<blog_commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blog_comments.
     */
    cursor?: blog_commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blog_comments.
     */
    distinct?: Enumerable<Blog_commentsScalarFieldEnum>
  }


  /**
   * blog_comments findMany
   */
  export type blog_commentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the blog_comments
     */
    select?: blog_commentsSelect | null
    /**
     * Filter, which blog_comments to fetch.
     */
    where?: blog_commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blog_comments to fetch.
     */
    orderBy?: Enumerable<blog_commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blog_comments.
     */
    cursor?: blog_commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blog_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blog_comments.
     */
    skip?: number
    distinct?: Enumerable<Blog_commentsScalarFieldEnum>
  }


  /**
   * blog_comments create
   */
  export type blog_commentsCreateArgs = {
    /**
     * Select specific fields to fetch from the blog_comments
     */
    select?: blog_commentsSelect | null
    /**
     * The data needed to create a blog_comments.
     */
    data: XOR<blog_commentsCreateInput, blog_commentsUncheckedCreateInput>
  }


  /**
   * blog_comments createMany
   */
  export type blog_commentsCreateManyArgs = {
    /**
     * The data used to create many blog_comments.
     */
    data: Enumerable<blog_commentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * blog_comments update
   */
  export type blog_commentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the blog_comments
     */
    select?: blog_commentsSelect | null
    /**
     * The data needed to update a blog_comments.
     */
    data: XOR<blog_commentsUpdateInput, blog_commentsUncheckedUpdateInput>
    /**
     * Choose, which blog_comments to update.
     */
    where: blog_commentsWhereUniqueInput
  }


  /**
   * blog_comments updateMany
   */
  export type blog_commentsUpdateManyArgs = {
    /**
     * The data used to update blog_comments.
     */
    data: XOR<blog_commentsUpdateManyMutationInput, blog_commentsUncheckedUpdateManyInput>
    /**
     * Filter which blog_comments to update
     */
    where?: blog_commentsWhereInput
  }


  /**
   * blog_comments upsert
   */
  export type blog_commentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the blog_comments
     */
    select?: blog_commentsSelect | null
    /**
     * The filter to search for the blog_comments to update in case it exists.
     */
    where: blog_commentsWhereUniqueInput
    /**
     * In case the blog_comments found by the `where` argument doesn't exist, create a new blog_comments with this data.
     */
    create: XOR<blog_commentsCreateInput, blog_commentsUncheckedCreateInput>
    /**
     * In case the blog_comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blog_commentsUpdateInput, blog_commentsUncheckedUpdateInput>
  }


  /**
   * blog_comments delete
   */
  export type blog_commentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the blog_comments
     */
    select?: blog_commentsSelect | null
    /**
     * Filter which blog_comments to delete.
     */
    where: blog_commentsWhereUniqueInput
  }


  /**
   * blog_comments deleteMany
   */
  export type blog_commentsDeleteManyArgs = {
    /**
     * Filter which blog_comments to delete
     */
    where?: blog_commentsWhereInput
  }


  /**
   * blog_comments without action
   */
  export type blog_commentsArgs = {
    /**
     * Select specific fields to fetch from the blog_comments
     */
    select?: blog_commentsSelect | null
  }



  /**
   * Model blogs
   */


  export type AggregateBlogs = {
    _count: BlogsCountAggregateOutputType | null
    _avg: BlogsAvgAggregateOutputType | null
    _sum: BlogsSumAggregateOutputType | null
    _min: BlogsMinAggregateOutputType | null
    _max: BlogsMaxAggregateOutputType | null
  }

  export type BlogsAvgAggregateOutputType = {
    id: number | null
    blog_category_id: number | null
    user_id: number | null
    views: number | null
  }

  export type BlogsSumAggregateOutputType = {
    id: number | null
    blog_category_id: number | null
    user_id: number | null
    views: number | null
  }

  export type BlogsMinAggregateOutputType = {
    id: number | null
    blog_category_id: number | null
    user_id: number | null
    title: string | null
    slug: string | null
    content: string | null
    image: string | null
    views: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type BlogsMaxAggregateOutputType = {
    id: number | null
    blog_category_id: number | null
    user_id: number | null
    title: string | null
    slug: string | null
    content: string | null
    image: string | null
    views: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type BlogsCountAggregateOutputType = {
    id: number
    blog_category_id: number
    user_id: number
    title: number
    slug: number
    content: number
    image: number
    views: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type BlogsAvgAggregateInputType = {
    id?: true
    blog_category_id?: true
    user_id?: true
    views?: true
  }

  export type BlogsSumAggregateInputType = {
    id?: true
    blog_category_id?: true
    user_id?: true
    views?: true
  }

  export type BlogsMinAggregateInputType = {
    id?: true
    blog_category_id?: true
    user_id?: true
    title?: true
    slug?: true
    content?: true
    image?: true
    views?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type BlogsMaxAggregateInputType = {
    id?: true
    blog_category_id?: true
    user_id?: true
    title?: true
    slug?: true
    content?: true
    image?: true
    views?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type BlogsCountAggregateInputType = {
    id?: true
    blog_category_id?: true
    user_id?: true
    title?: true
    slug?: true
    content?: true
    image?: true
    views?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type BlogsAggregateArgs = {
    /**
     * Filter which blogs to aggregate.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: Enumerable<blogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blogs
    **/
    _count?: true | BlogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogsMaxAggregateInputType
  }

  export type GetBlogsAggregateType<T extends BlogsAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogs[P]>
      : GetScalarType<T[P], AggregateBlogs[P]>
  }




  export type BlogsGroupByArgs = {
    where?: blogsWhereInput
    orderBy?: Enumerable<blogsOrderByWithAggregationInput>
    by: BlogsScalarFieldEnum[]
    having?: blogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogsCountAggregateInputType | true
    _avg?: BlogsAvgAggregateInputType
    _sum?: BlogsSumAggregateInputType
    _min?: BlogsMinAggregateInputType
    _max?: BlogsMaxAggregateInputType
  }


  export type BlogsGroupByOutputType = {
    id: number
    blog_category_id: number
    user_id: number
    title: string
    slug: string | null
    content: string
    image: string | null
    views: number
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: BlogsCountAggregateOutputType | null
    _avg: BlogsAvgAggregateOutputType | null
    _sum: BlogsSumAggregateOutputType | null
    _min: BlogsMinAggregateOutputType | null
    _max: BlogsMaxAggregateOutputType | null
  }

  type GetBlogsGroupByPayload<T extends BlogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BlogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogsGroupByOutputType[P]>
            : GetScalarType<T[P], BlogsGroupByOutputType[P]>
        }
      >
    >


  export type blogsSelect = {
    id?: boolean
    blog_category_id?: boolean
    user_id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    image?: boolean
    views?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }


  export type blogsGetPayload<S extends boolean | null | undefined | blogsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? blogs :
    S extends undefined ? never :
    S extends { include: any } & (blogsArgs | blogsFindManyArgs)
    ? blogs 
    : S extends { select: any } & (blogsArgs | blogsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof blogs ? blogs[P] : never
  } 
      : blogs


  type blogsCountArgs = 
    Omit<blogsFindManyArgs, 'select' | 'include'> & {
      select?: BlogsCountAggregateInputType | true
    }

  export interface blogsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Blogs that matches the filter.
     * @param {blogsFindUniqueArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends blogsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, blogsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'blogs'> extends True ? Prisma__blogsClient<blogsGetPayload<T>> : Prisma__blogsClient<blogsGetPayload<T> | null, null>

    /**
     * Find one Blogs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {blogsFindUniqueOrThrowArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends blogsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, blogsFindUniqueOrThrowArgs>
    ): Prisma__blogsClient<blogsGetPayload<T>>

    /**
     * Find the first Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsFindFirstArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends blogsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, blogsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'blogs'> extends True ? Prisma__blogsClient<blogsGetPayload<T>> : Prisma__blogsClient<blogsGetPayload<T> | null, null>

    /**
     * Find the first Blogs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsFindFirstOrThrowArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends blogsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, blogsFindFirstOrThrowArgs>
    ): Prisma__blogsClient<blogsGetPayload<T>>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blogs.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blogs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogsWithIdOnly = await prisma.blogs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends blogsFindManyArgs>(
      args?: SelectSubset<T, blogsFindManyArgs>
    ): Prisma.PrismaPromise<Array<blogsGetPayload<T>>>

    /**
     * Create a Blogs.
     * @param {blogsCreateArgs} args - Arguments to create a Blogs.
     * @example
     * // Create one Blogs
     * const Blogs = await prisma.blogs.create({
     *   data: {
     *     // ... data to create a Blogs
     *   }
     * })
     * 
    **/
    create<T extends blogsCreateArgs>(
      args: SelectSubset<T, blogsCreateArgs>
    ): Prisma__blogsClient<blogsGetPayload<T>>

    /**
     * Create many Blogs.
     *     @param {blogsCreateManyArgs} args - Arguments to create many Blogs.
     *     @example
     *     // Create many Blogs
     *     const blogs = await prisma.blogs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends blogsCreateManyArgs>(
      args?: SelectSubset<T, blogsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blogs.
     * @param {blogsDeleteArgs} args - Arguments to delete one Blogs.
     * @example
     * // Delete one Blogs
     * const Blogs = await prisma.blogs.delete({
     *   where: {
     *     // ... filter to delete one Blogs
     *   }
     * })
     * 
    **/
    delete<T extends blogsDeleteArgs>(
      args: SelectSubset<T, blogsDeleteArgs>
    ): Prisma__blogsClient<blogsGetPayload<T>>

    /**
     * Update one Blogs.
     * @param {blogsUpdateArgs} args - Arguments to update one Blogs.
     * @example
     * // Update one Blogs
     * const blogs = await prisma.blogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends blogsUpdateArgs>(
      args: SelectSubset<T, blogsUpdateArgs>
    ): Prisma__blogsClient<blogsGetPayload<T>>

    /**
     * Delete zero or more Blogs.
     * @param {blogsDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends blogsDeleteManyArgs>(
      args?: SelectSubset<T, blogsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blogs = await prisma.blogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends blogsUpdateManyArgs>(
      args: SelectSubset<T, blogsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blogs.
     * @param {blogsUpsertArgs} args - Arguments to update or create a Blogs.
     * @example
     * // Update or create a Blogs
     * const blogs = await prisma.blogs.upsert({
     *   create: {
     *     // ... data to create a Blogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blogs we want to update
     *   }
     * })
    **/
    upsert<T extends blogsUpsertArgs>(
      args: SelectSubset<T, blogsUpsertArgs>
    ): Prisma__blogsClient<blogsGetPayload<T>>

    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blogs.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends blogsCountArgs>(
      args?: Subset<T, blogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogsAggregateArgs>(args: Subset<T, BlogsAggregateArgs>): Prisma.PrismaPromise<GetBlogsAggregateType<T>>

    /**
     * Group by Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogsGroupByArgs['orderBy'] }
        : { orderBy?: BlogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for blogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__blogsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * blogs base type for findUnique actions
   */
  export type blogsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect | null
    /**
     * Filter, which blogs to fetch.
     */
    where: blogsWhereUniqueInput
  }

  /**
   * blogs findUnique
   */
  export interface blogsFindUniqueArgs extends blogsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * blogs findUniqueOrThrow
   */
  export type blogsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect | null
    /**
     * Filter, which blogs to fetch.
     */
    where: blogsWhereUniqueInput
  }


  /**
   * blogs base type for findFirst actions
   */
  export type blogsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect | null
    /**
     * Filter, which blogs to fetch.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: Enumerable<blogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blogs.
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blogs.
     */
    distinct?: Enumerable<BlogsScalarFieldEnum>
  }

  /**
   * blogs findFirst
   */
  export interface blogsFindFirstArgs extends blogsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * blogs findFirstOrThrow
   */
  export type blogsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect | null
    /**
     * Filter, which blogs to fetch.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: Enumerable<blogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blogs.
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blogs.
     */
    distinct?: Enumerable<BlogsScalarFieldEnum>
  }


  /**
   * blogs findMany
   */
  export type blogsFindManyArgs = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect | null
    /**
     * Filter, which blogs to fetch.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: Enumerable<blogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blogs.
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    distinct?: Enumerable<BlogsScalarFieldEnum>
  }


  /**
   * blogs create
   */
  export type blogsCreateArgs = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect | null
    /**
     * The data needed to create a blogs.
     */
    data: XOR<blogsCreateInput, blogsUncheckedCreateInput>
  }


  /**
   * blogs createMany
   */
  export type blogsCreateManyArgs = {
    /**
     * The data used to create many blogs.
     */
    data: Enumerable<blogsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * blogs update
   */
  export type blogsUpdateArgs = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect | null
    /**
     * The data needed to update a blogs.
     */
    data: XOR<blogsUpdateInput, blogsUncheckedUpdateInput>
    /**
     * Choose, which blogs to update.
     */
    where: blogsWhereUniqueInput
  }


  /**
   * blogs updateMany
   */
  export type blogsUpdateManyArgs = {
    /**
     * The data used to update blogs.
     */
    data: XOR<blogsUpdateManyMutationInput, blogsUncheckedUpdateManyInput>
    /**
     * Filter which blogs to update
     */
    where?: blogsWhereInput
  }


  /**
   * blogs upsert
   */
  export type blogsUpsertArgs = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect | null
    /**
     * The filter to search for the blogs to update in case it exists.
     */
    where: blogsWhereUniqueInput
    /**
     * In case the blogs found by the `where` argument doesn't exist, create a new blogs with this data.
     */
    create: XOR<blogsCreateInput, blogsUncheckedCreateInput>
    /**
     * In case the blogs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blogsUpdateInput, blogsUncheckedUpdateInput>
  }


  /**
   * blogs delete
   */
  export type blogsDeleteArgs = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect | null
    /**
     * Filter which blogs to delete.
     */
    where: blogsWhereUniqueInput
  }


  /**
   * blogs deleteMany
   */
  export type blogsDeleteManyArgs = {
    /**
     * Filter which blogs to delete
     */
    where?: blogsWhereInput
  }


  /**
   * blogs without action
   */
  export type blogsArgs = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect | null
  }



  /**
   * Model body_types
   */


  export type AggregateBody_types = {
    _count: Body_typesCountAggregateOutputType | null
    _avg: Body_typesAvgAggregateOutputType | null
    _sum: Body_typesSumAggregateOutputType | null
    _min: Body_typesMinAggregateOutputType | null
    _max: Body_typesMaxAggregateOutputType | null
  }

  export type Body_typesAvgAggregateOutputType = {
    id: number | null
  }

  export type Body_typesSumAggregateOutputType = {
    id: number | null
  }

  export type Body_typesMinAggregateOutputType = {
    id: number | null
    body_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Body_typesMaxAggregateOutputType = {
    id: number | null
    body_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Body_typesCountAggregateOutputType = {
    id: number
    body_type: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Body_typesAvgAggregateInputType = {
    id?: true
  }

  export type Body_typesSumAggregateInputType = {
    id?: true
  }

  export type Body_typesMinAggregateInputType = {
    id?: true
    body_type?: true
    created_at?: true
    updated_at?: true
  }

  export type Body_typesMaxAggregateInputType = {
    id?: true
    body_type?: true
    created_at?: true
    updated_at?: true
  }

  export type Body_typesCountAggregateInputType = {
    id?: true
    body_type?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Body_typesAggregateArgs = {
    /**
     * Filter which body_types to aggregate.
     */
    where?: body_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of body_types to fetch.
     */
    orderBy?: Enumerable<body_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: body_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` body_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` body_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned body_types
    **/
    _count?: true | Body_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Body_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Body_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Body_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Body_typesMaxAggregateInputType
  }

  export type GetBody_typesAggregateType<T extends Body_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateBody_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBody_types[P]>
      : GetScalarType<T[P], AggregateBody_types[P]>
  }




  export type Body_typesGroupByArgs = {
    where?: body_typesWhereInput
    orderBy?: Enumerable<body_typesOrderByWithAggregationInput>
    by: Body_typesScalarFieldEnum[]
    having?: body_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Body_typesCountAggregateInputType | true
    _avg?: Body_typesAvgAggregateInputType
    _sum?: Body_typesSumAggregateInputType
    _min?: Body_typesMinAggregateInputType
    _max?: Body_typesMaxAggregateInputType
  }


  export type Body_typesGroupByOutputType = {
    id: number
    body_type: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Body_typesCountAggregateOutputType | null
    _avg: Body_typesAvgAggregateOutputType | null
    _sum: Body_typesSumAggregateOutputType | null
    _min: Body_typesMinAggregateOutputType | null
    _max: Body_typesMaxAggregateOutputType | null
  }

  type GetBody_typesGroupByPayload<T extends Body_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Body_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Body_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Body_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Body_typesGroupByOutputType[P]>
        }
      >
    >


  export type body_typesSelect = {
    id?: boolean
    body_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    cars?: boolean | body_types$carsArgs
    _count?: boolean | Body_typesCountOutputTypeArgs
  }


  export type body_typesInclude = {
    cars?: boolean | body_types$carsArgs
    _count?: boolean | Body_typesCountOutputTypeArgs
  }

  export type body_typesGetPayload<S extends boolean | null | undefined | body_typesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? body_types :
    S extends undefined ? never :
    S extends { include: any } & (body_typesArgs | body_typesFindManyArgs)
    ? body_types  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'cars' ? Array < carsGetPayload<S['include'][P]>>  :
        P extends '_count' ? Body_typesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (body_typesArgs | body_typesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'cars' ? Array < carsGetPayload<S['select'][P]>>  :
        P extends '_count' ? Body_typesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof body_types ? body_types[P] : never
  } 
      : body_types


  type body_typesCountArgs = 
    Omit<body_typesFindManyArgs, 'select' | 'include'> & {
      select?: Body_typesCountAggregateInputType | true
    }

  export interface body_typesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Body_types that matches the filter.
     * @param {body_typesFindUniqueArgs} args - Arguments to find a Body_types
     * @example
     * // Get one Body_types
     * const body_types = await prisma.body_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends body_typesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, body_typesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'body_types'> extends True ? Prisma__body_typesClient<body_typesGetPayload<T>> : Prisma__body_typesClient<body_typesGetPayload<T> | null, null>

    /**
     * Find one Body_types that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {body_typesFindUniqueOrThrowArgs} args - Arguments to find a Body_types
     * @example
     * // Get one Body_types
     * const body_types = await prisma.body_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends body_typesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, body_typesFindUniqueOrThrowArgs>
    ): Prisma__body_typesClient<body_typesGetPayload<T>>

    /**
     * Find the first Body_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {body_typesFindFirstArgs} args - Arguments to find a Body_types
     * @example
     * // Get one Body_types
     * const body_types = await prisma.body_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends body_typesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, body_typesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'body_types'> extends True ? Prisma__body_typesClient<body_typesGetPayload<T>> : Prisma__body_typesClient<body_typesGetPayload<T> | null, null>

    /**
     * Find the first Body_types that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {body_typesFindFirstOrThrowArgs} args - Arguments to find a Body_types
     * @example
     * // Get one Body_types
     * const body_types = await prisma.body_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends body_typesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, body_typesFindFirstOrThrowArgs>
    ): Prisma__body_typesClient<body_typesGetPayload<T>>

    /**
     * Find zero or more Body_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {body_typesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Body_types
     * const body_types = await prisma.body_types.findMany()
     * 
     * // Get first 10 Body_types
     * const body_types = await prisma.body_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const body_typesWithIdOnly = await prisma.body_types.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends body_typesFindManyArgs>(
      args?: SelectSubset<T, body_typesFindManyArgs>
    ): Prisma.PrismaPromise<Array<body_typesGetPayload<T>>>

    /**
     * Create a Body_types.
     * @param {body_typesCreateArgs} args - Arguments to create a Body_types.
     * @example
     * // Create one Body_types
     * const Body_types = await prisma.body_types.create({
     *   data: {
     *     // ... data to create a Body_types
     *   }
     * })
     * 
    **/
    create<T extends body_typesCreateArgs>(
      args: SelectSubset<T, body_typesCreateArgs>
    ): Prisma__body_typesClient<body_typesGetPayload<T>>

    /**
     * Create many Body_types.
     *     @param {body_typesCreateManyArgs} args - Arguments to create many Body_types.
     *     @example
     *     // Create many Body_types
     *     const body_types = await prisma.body_types.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends body_typesCreateManyArgs>(
      args?: SelectSubset<T, body_typesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Body_types.
     * @param {body_typesDeleteArgs} args - Arguments to delete one Body_types.
     * @example
     * // Delete one Body_types
     * const Body_types = await prisma.body_types.delete({
     *   where: {
     *     // ... filter to delete one Body_types
     *   }
     * })
     * 
    **/
    delete<T extends body_typesDeleteArgs>(
      args: SelectSubset<T, body_typesDeleteArgs>
    ): Prisma__body_typesClient<body_typesGetPayload<T>>

    /**
     * Update one Body_types.
     * @param {body_typesUpdateArgs} args - Arguments to update one Body_types.
     * @example
     * // Update one Body_types
     * const body_types = await prisma.body_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends body_typesUpdateArgs>(
      args: SelectSubset<T, body_typesUpdateArgs>
    ): Prisma__body_typesClient<body_typesGetPayload<T>>

    /**
     * Delete zero or more Body_types.
     * @param {body_typesDeleteManyArgs} args - Arguments to filter Body_types to delete.
     * @example
     * // Delete a few Body_types
     * const { count } = await prisma.body_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends body_typesDeleteManyArgs>(
      args?: SelectSubset<T, body_typesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Body_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {body_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Body_types
     * const body_types = await prisma.body_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends body_typesUpdateManyArgs>(
      args: SelectSubset<T, body_typesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Body_types.
     * @param {body_typesUpsertArgs} args - Arguments to update or create a Body_types.
     * @example
     * // Update or create a Body_types
     * const body_types = await prisma.body_types.upsert({
     *   create: {
     *     // ... data to create a Body_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Body_types we want to update
     *   }
     * })
    **/
    upsert<T extends body_typesUpsertArgs>(
      args: SelectSubset<T, body_typesUpsertArgs>
    ): Prisma__body_typesClient<body_typesGetPayload<T>>

    /**
     * Count the number of Body_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {body_typesCountArgs} args - Arguments to filter Body_types to count.
     * @example
     * // Count the number of Body_types
     * const count = await prisma.body_types.count({
     *   where: {
     *     // ... the filter for the Body_types we want to count
     *   }
     * })
    **/
    count<T extends body_typesCountArgs>(
      args?: Subset<T, body_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Body_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Body_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Body_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Body_typesAggregateArgs>(args: Subset<T, Body_typesAggregateArgs>): Prisma.PrismaPromise<GetBody_typesAggregateType<T>>

    /**
     * Group by Body_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Body_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Body_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Body_typesGroupByArgs['orderBy'] }
        : { orderBy?: Body_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Body_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBody_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for body_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__body_typesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cars<T extends body_types$carsArgs= {}>(args?: Subset<T, body_types$carsArgs>): Prisma.PrismaPromise<Array<carsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * body_types base type for findUnique actions
   */
  export type body_typesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the body_types
     */
    select?: body_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: body_typesInclude | null
    /**
     * Filter, which body_types to fetch.
     */
    where: body_typesWhereUniqueInput
  }

  /**
   * body_types findUnique
   */
  export interface body_typesFindUniqueArgs extends body_typesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * body_types findUniqueOrThrow
   */
  export type body_typesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the body_types
     */
    select?: body_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: body_typesInclude | null
    /**
     * Filter, which body_types to fetch.
     */
    where: body_typesWhereUniqueInput
  }


  /**
   * body_types base type for findFirst actions
   */
  export type body_typesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the body_types
     */
    select?: body_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: body_typesInclude | null
    /**
     * Filter, which body_types to fetch.
     */
    where?: body_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of body_types to fetch.
     */
    orderBy?: Enumerable<body_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for body_types.
     */
    cursor?: body_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` body_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` body_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of body_types.
     */
    distinct?: Enumerable<Body_typesScalarFieldEnum>
  }

  /**
   * body_types findFirst
   */
  export interface body_typesFindFirstArgs extends body_typesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * body_types findFirstOrThrow
   */
  export type body_typesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the body_types
     */
    select?: body_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: body_typesInclude | null
    /**
     * Filter, which body_types to fetch.
     */
    where?: body_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of body_types to fetch.
     */
    orderBy?: Enumerable<body_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for body_types.
     */
    cursor?: body_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` body_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` body_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of body_types.
     */
    distinct?: Enumerable<Body_typesScalarFieldEnum>
  }


  /**
   * body_types findMany
   */
  export type body_typesFindManyArgs = {
    /**
     * Select specific fields to fetch from the body_types
     */
    select?: body_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: body_typesInclude | null
    /**
     * Filter, which body_types to fetch.
     */
    where?: body_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of body_types to fetch.
     */
    orderBy?: Enumerable<body_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing body_types.
     */
    cursor?: body_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` body_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` body_types.
     */
    skip?: number
    distinct?: Enumerable<Body_typesScalarFieldEnum>
  }


  /**
   * body_types create
   */
  export type body_typesCreateArgs = {
    /**
     * Select specific fields to fetch from the body_types
     */
    select?: body_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: body_typesInclude | null
    /**
     * The data needed to create a body_types.
     */
    data: XOR<body_typesCreateInput, body_typesUncheckedCreateInput>
  }


  /**
   * body_types createMany
   */
  export type body_typesCreateManyArgs = {
    /**
     * The data used to create many body_types.
     */
    data: Enumerable<body_typesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * body_types update
   */
  export type body_typesUpdateArgs = {
    /**
     * Select specific fields to fetch from the body_types
     */
    select?: body_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: body_typesInclude | null
    /**
     * The data needed to update a body_types.
     */
    data: XOR<body_typesUpdateInput, body_typesUncheckedUpdateInput>
    /**
     * Choose, which body_types to update.
     */
    where: body_typesWhereUniqueInput
  }


  /**
   * body_types updateMany
   */
  export type body_typesUpdateManyArgs = {
    /**
     * The data used to update body_types.
     */
    data: XOR<body_typesUpdateManyMutationInput, body_typesUncheckedUpdateManyInput>
    /**
     * Filter which body_types to update
     */
    where?: body_typesWhereInput
  }


  /**
   * body_types upsert
   */
  export type body_typesUpsertArgs = {
    /**
     * Select specific fields to fetch from the body_types
     */
    select?: body_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: body_typesInclude | null
    /**
     * The filter to search for the body_types to update in case it exists.
     */
    where: body_typesWhereUniqueInput
    /**
     * In case the body_types found by the `where` argument doesn't exist, create a new body_types with this data.
     */
    create: XOR<body_typesCreateInput, body_typesUncheckedCreateInput>
    /**
     * In case the body_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<body_typesUpdateInput, body_typesUncheckedUpdateInput>
  }


  /**
   * body_types delete
   */
  export type body_typesDeleteArgs = {
    /**
     * Select specific fields to fetch from the body_types
     */
    select?: body_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: body_typesInclude | null
    /**
     * Filter which body_types to delete.
     */
    where: body_typesWhereUniqueInput
  }


  /**
   * body_types deleteMany
   */
  export type body_typesDeleteManyArgs = {
    /**
     * Filter which body_types to delete
     */
    where?: body_typesWhereInput
  }


  /**
   * body_types.cars
   */
  export type body_types$carsArgs = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    where?: carsWhereInput
    orderBy?: Enumerable<carsOrderByWithRelationInput>
    cursor?: carsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CarsScalarFieldEnum>
  }


  /**
   * body_types without action
   */
  export type body_typesArgs = {
    /**
     * Select specific fields to fetch from the body_types
     */
    select?: body_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: body_typesInclude | null
  }



  /**
   * Model car_features
   */


  export type AggregateCar_features = {
    _count: Car_featuresCountAggregateOutputType | null
    _avg: Car_featuresAvgAggregateOutputType | null
    _sum: Car_featuresSumAggregateOutputType | null
    _min: Car_featuresMinAggregateOutputType | null
    _max: Car_featuresMaxAggregateOutputType | null
  }

  export type Car_featuresAvgAggregateOutputType = {
    id: number | null
    car_id: number | null
    feature_id: number | null
  }

  export type Car_featuresSumAggregateOutputType = {
    id: number | null
    car_id: number | null
    feature_id: number | null
  }

  export type Car_featuresMinAggregateOutputType = {
    id: number | null
    car_id: number | null
    feature_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Car_featuresMaxAggregateOutputType = {
    id: number | null
    car_id: number | null
    feature_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Car_featuresCountAggregateOutputType = {
    id: number
    car_id: number
    feature_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Car_featuresAvgAggregateInputType = {
    id?: true
    car_id?: true
    feature_id?: true
  }

  export type Car_featuresSumAggregateInputType = {
    id?: true
    car_id?: true
    feature_id?: true
  }

  export type Car_featuresMinAggregateInputType = {
    id?: true
    car_id?: true
    feature_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Car_featuresMaxAggregateInputType = {
    id?: true
    car_id?: true
    feature_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Car_featuresCountAggregateInputType = {
    id?: true
    car_id?: true
    feature_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Car_featuresAggregateArgs = {
    /**
     * Filter which car_features to aggregate.
     */
    where?: car_featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of car_features to fetch.
     */
    orderBy?: Enumerable<car_featuresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: car_featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` car_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` car_features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned car_features
    **/
    _count?: true | Car_featuresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Car_featuresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Car_featuresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Car_featuresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Car_featuresMaxAggregateInputType
  }

  export type GetCar_featuresAggregateType<T extends Car_featuresAggregateArgs> = {
        [P in keyof T & keyof AggregateCar_features]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCar_features[P]>
      : GetScalarType<T[P], AggregateCar_features[P]>
  }




  export type Car_featuresGroupByArgs = {
    where?: car_featuresWhereInput
    orderBy?: Enumerable<car_featuresOrderByWithAggregationInput>
    by: Car_featuresScalarFieldEnum[]
    having?: car_featuresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Car_featuresCountAggregateInputType | true
    _avg?: Car_featuresAvgAggregateInputType
    _sum?: Car_featuresSumAggregateInputType
    _min?: Car_featuresMinAggregateInputType
    _max?: Car_featuresMaxAggregateInputType
  }


  export type Car_featuresGroupByOutputType = {
    id: number
    car_id: number
    feature_id: number
    created_at: Date | null
    updated_at: Date | null
    _count: Car_featuresCountAggregateOutputType | null
    _avg: Car_featuresAvgAggregateOutputType | null
    _sum: Car_featuresSumAggregateOutputType | null
    _min: Car_featuresMinAggregateOutputType | null
    _max: Car_featuresMaxAggregateOutputType | null
  }

  type GetCar_featuresGroupByPayload<T extends Car_featuresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Car_featuresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Car_featuresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Car_featuresGroupByOutputType[P]>
            : GetScalarType<T[P], Car_featuresGroupByOutputType[P]>
        }
      >
    >


  export type car_featuresSelect = {
    id?: boolean
    car_id?: boolean
    feature_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type car_featuresGetPayload<S extends boolean | null | undefined | car_featuresArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? car_features :
    S extends undefined ? never :
    S extends { include: any } & (car_featuresArgs | car_featuresFindManyArgs)
    ? car_features 
    : S extends { select: any } & (car_featuresArgs | car_featuresFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof car_features ? car_features[P] : never
  } 
      : car_features


  type car_featuresCountArgs = 
    Omit<car_featuresFindManyArgs, 'select' | 'include'> & {
      select?: Car_featuresCountAggregateInputType | true
    }

  export interface car_featuresDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Car_features that matches the filter.
     * @param {car_featuresFindUniqueArgs} args - Arguments to find a Car_features
     * @example
     * // Get one Car_features
     * const car_features = await prisma.car_features.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends car_featuresFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, car_featuresFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'car_features'> extends True ? Prisma__car_featuresClient<car_featuresGetPayload<T>> : Prisma__car_featuresClient<car_featuresGetPayload<T> | null, null>

    /**
     * Find one Car_features that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {car_featuresFindUniqueOrThrowArgs} args - Arguments to find a Car_features
     * @example
     * // Get one Car_features
     * const car_features = await prisma.car_features.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends car_featuresFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, car_featuresFindUniqueOrThrowArgs>
    ): Prisma__car_featuresClient<car_featuresGetPayload<T>>

    /**
     * Find the first Car_features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_featuresFindFirstArgs} args - Arguments to find a Car_features
     * @example
     * // Get one Car_features
     * const car_features = await prisma.car_features.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends car_featuresFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, car_featuresFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'car_features'> extends True ? Prisma__car_featuresClient<car_featuresGetPayload<T>> : Prisma__car_featuresClient<car_featuresGetPayload<T> | null, null>

    /**
     * Find the first Car_features that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_featuresFindFirstOrThrowArgs} args - Arguments to find a Car_features
     * @example
     * // Get one Car_features
     * const car_features = await prisma.car_features.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends car_featuresFindFirstOrThrowArgs>(
      args?: SelectSubset<T, car_featuresFindFirstOrThrowArgs>
    ): Prisma__car_featuresClient<car_featuresGetPayload<T>>

    /**
     * Find zero or more Car_features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_featuresFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Car_features
     * const car_features = await prisma.car_features.findMany()
     * 
     * // Get first 10 Car_features
     * const car_features = await prisma.car_features.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const car_featuresWithIdOnly = await prisma.car_features.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends car_featuresFindManyArgs>(
      args?: SelectSubset<T, car_featuresFindManyArgs>
    ): Prisma.PrismaPromise<Array<car_featuresGetPayload<T>>>

    /**
     * Create a Car_features.
     * @param {car_featuresCreateArgs} args - Arguments to create a Car_features.
     * @example
     * // Create one Car_features
     * const Car_features = await prisma.car_features.create({
     *   data: {
     *     // ... data to create a Car_features
     *   }
     * })
     * 
    **/
    create<T extends car_featuresCreateArgs>(
      args: SelectSubset<T, car_featuresCreateArgs>
    ): Prisma__car_featuresClient<car_featuresGetPayload<T>>

    /**
     * Create many Car_features.
     *     @param {car_featuresCreateManyArgs} args - Arguments to create many Car_features.
     *     @example
     *     // Create many Car_features
     *     const car_features = await prisma.car_features.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends car_featuresCreateManyArgs>(
      args?: SelectSubset<T, car_featuresCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Car_features.
     * @param {car_featuresDeleteArgs} args - Arguments to delete one Car_features.
     * @example
     * // Delete one Car_features
     * const Car_features = await prisma.car_features.delete({
     *   where: {
     *     // ... filter to delete one Car_features
     *   }
     * })
     * 
    **/
    delete<T extends car_featuresDeleteArgs>(
      args: SelectSubset<T, car_featuresDeleteArgs>
    ): Prisma__car_featuresClient<car_featuresGetPayload<T>>

    /**
     * Update one Car_features.
     * @param {car_featuresUpdateArgs} args - Arguments to update one Car_features.
     * @example
     * // Update one Car_features
     * const car_features = await prisma.car_features.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends car_featuresUpdateArgs>(
      args: SelectSubset<T, car_featuresUpdateArgs>
    ): Prisma__car_featuresClient<car_featuresGetPayload<T>>

    /**
     * Delete zero or more Car_features.
     * @param {car_featuresDeleteManyArgs} args - Arguments to filter Car_features to delete.
     * @example
     * // Delete a few Car_features
     * const { count } = await prisma.car_features.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends car_featuresDeleteManyArgs>(
      args?: SelectSubset<T, car_featuresDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Car_features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_featuresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Car_features
     * const car_features = await prisma.car_features.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends car_featuresUpdateManyArgs>(
      args: SelectSubset<T, car_featuresUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Car_features.
     * @param {car_featuresUpsertArgs} args - Arguments to update or create a Car_features.
     * @example
     * // Update or create a Car_features
     * const car_features = await prisma.car_features.upsert({
     *   create: {
     *     // ... data to create a Car_features
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Car_features we want to update
     *   }
     * })
    **/
    upsert<T extends car_featuresUpsertArgs>(
      args: SelectSubset<T, car_featuresUpsertArgs>
    ): Prisma__car_featuresClient<car_featuresGetPayload<T>>

    /**
     * Count the number of Car_features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_featuresCountArgs} args - Arguments to filter Car_features to count.
     * @example
     * // Count the number of Car_features
     * const count = await prisma.car_features.count({
     *   where: {
     *     // ... the filter for the Car_features we want to count
     *   }
     * })
    **/
    count<T extends car_featuresCountArgs>(
      args?: Subset<T, car_featuresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Car_featuresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Car_features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Car_featuresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Car_featuresAggregateArgs>(args: Subset<T, Car_featuresAggregateArgs>): Prisma.PrismaPromise<GetCar_featuresAggregateType<T>>

    /**
     * Group by Car_features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Car_featuresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Car_featuresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Car_featuresGroupByArgs['orderBy'] }
        : { orderBy?: Car_featuresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Car_featuresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCar_featuresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for car_features.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__car_featuresClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * car_features base type for findUnique actions
   */
  export type car_featuresFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the car_features
     */
    select?: car_featuresSelect | null
    /**
     * Filter, which car_features to fetch.
     */
    where: car_featuresWhereUniqueInput
  }

  /**
   * car_features findUnique
   */
  export interface car_featuresFindUniqueArgs extends car_featuresFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * car_features findUniqueOrThrow
   */
  export type car_featuresFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the car_features
     */
    select?: car_featuresSelect | null
    /**
     * Filter, which car_features to fetch.
     */
    where: car_featuresWhereUniqueInput
  }


  /**
   * car_features base type for findFirst actions
   */
  export type car_featuresFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the car_features
     */
    select?: car_featuresSelect | null
    /**
     * Filter, which car_features to fetch.
     */
    where?: car_featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of car_features to fetch.
     */
    orderBy?: Enumerable<car_featuresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for car_features.
     */
    cursor?: car_featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` car_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` car_features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of car_features.
     */
    distinct?: Enumerable<Car_featuresScalarFieldEnum>
  }

  /**
   * car_features findFirst
   */
  export interface car_featuresFindFirstArgs extends car_featuresFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * car_features findFirstOrThrow
   */
  export type car_featuresFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the car_features
     */
    select?: car_featuresSelect | null
    /**
     * Filter, which car_features to fetch.
     */
    where?: car_featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of car_features to fetch.
     */
    orderBy?: Enumerable<car_featuresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for car_features.
     */
    cursor?: car_featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` car_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` car_features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of car_features.
     */
    distinct?: Enumerable<Car_featuresScalarFieldEnum>
  }


  /**
   * car_features findMany
   */
  export type car_featuresFindManyArgs = {
    /**
     * Select specific fields to fetch from the car_features
     */
    select?: car_featuresSelect | null
    /**
     * Filter, which car_features to fetch.
     */
    where?: car_featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of car_features to fetch.
     */
    orderBy?: Enumerable<car_featuresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing car_features.
     */
    cursor?: car_featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` car_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` car_features.
     */
    skip?: number
    distinct?: Enumerable<Car_featuresScalarFieldEnum>
  }


  /**
   * car_features create
   */
  export type car_featuresCreateArgs = {
    /**
     * Select specific fields to fetch from the car_features
     */
    select?: car_featuresSelect | null
    /**
     * The data needed to create a car_features.
     */
    data: XOR<car_featuresCreateInput, car_featuresUncheckedCreateInput>
  }


  /**
   * car_features createMany
   */
  export type car_featuresCreateManyArgs = {
    /**
     * The data used to create many car_features.
     */
    data: Enumerable<car_featuresCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * car_features update
   */
  export type car_featuresUpdateArgs = {
    /**
     * Select specific fields to fetch from the car_features
     */
    select?: car_featuresSelect | null
    /**
     * The data needed to update a car_features.
     */
    data: XOR<car_featuresUpdateInput, car_featuresUncheckedUpdateInput>
    /**
     * Choose, which car_features to update.
     */
    where: car_featuresWhereUniqueInput
  }


  /**
   * car_features updateMany
   */
  export type car_featuresUpdateManyArgs = {
    /**
     * The data used to update car_features.
     */
    data: XOR<car_featuresUpdateManyMutationInput, car_featuresUncheckedUpdateManyInput>
    /**
     * Filter which car_features to update
     */
    where?: car_featuresWhereInput
  }


  /**
   * car_features upsert
   */
  export type car_featuresUpsertArgs = {
    /**
     * Select specific fields to fetch from the car_features
     */
    select?: car_featuresSelect | null
    /**
     * The filter to search for the car_features to update in case it exists.
     */
    where: car_featuresWhereUniqueInput
    /**
     * In case the car_features found by the `where` argument doesn't exist, create a new car_features with this data.
     */
    create: XOR<car_featuresCreateInput, car_featuresUncheckedCreateInput>
    /**
     * In case the car_features was found with the provided `where` argument, update it with this data.
     */
    update: XOR<car_featuresUpdateInput, car_featuresUncheckedUpdateInput>
  }


  /**
   * car_features delete
   */
  export type car_featuresDeleteArgs = {
    /**
     * Select specific fields to fetch from the car_features
     */
    select?: car_featuresSelect | null
    /**
     * Filter which car_features to delete.
     */
    where: car_featuresWhereUniqueInput
  }


  /**
   * car_features deleteMany
   */
  export type car_featuresDeleteManyArgs = {
    /**
     * Filter which car_features to delete
     */
    where?: car_featuresWhereInput
  }


  /**
   * car_features without action
   */
  export type car_featuresArgs = {
    /**
     * Select specific fields to fetch from the car_features
     */
    select?: car_featuresSelect | null
  }



  /**
   * Model car_price_types
   */


  export type AggregateCar_price_types = {
    _count: Car_price_typesCountAggregateOutputType | null
    _avg: Car_price_typesAvgAggregateOutputType | null
    _sum: Car_price_typesSumAggregateOutputType | null
    _min: Car_price_typesMinAggregateOutputType | null
    _max: Car_price_typesMaxAggregateOutputType | null
  }

  export type Car_price_typesAvgAggregateOutputType = {
    id: number | null
  }

  export type Car_price_typesSumAggregateOutputType = {
    id: number | null
  }

  export type Car_price_typesMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Car_price_typesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Car_price_typesCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Car_price_typesAvgAggregateInputType = {
    id?: true
  }

  export type Car_price_typesSumAggregateInputType = {
    id?: true
  }

  export type Car_price_typesMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type Car_price_typesMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type Car_price_typesCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Car_price_typesAggregateArgs = {
    /**
     * Filter which car_price_types to aggregate.
     */
    where?: car_price_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of car_price_types to fetch.
     */
    orderBy?: Enumerable<car_price_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: car_price_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` car_price_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` car_price_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned car_price_types
    **/
    _count?: true | Car_price_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Car_price_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Car_price_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Car_price_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Car_price_typesMaxAggregateInputType
  }

  export type GetCar_price_typesAggregateType<T extends Car_price_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateCar_price_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCar_price_types[P]>
      : GetScalarType<T[P], AggregateCar_price_types[P]>
  }




  export type Car_price_typesGroupByArgs = {
    where?: car_price_typesWhereInput
    orderBy?: Enumerable<car_price_typesOrderByWithAggregationInput>
    by: Car_price_typesScalarFieldEnum[]
    having?: car_price_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Car_price_typesCountAggregateInputType | true
    _avg?: Car_price_typesAvgAggregateInputType
    _sum?: Car_price_typesSumAggregateInputType
    _min?: Car_price_typesMinAggregateInputType
    _max?: Car_price_typesMaxAggregateInputType
  }


  export type Car_price_typesGroupByOutputType = {
    id: number
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Car_price_typesCountAggregateOutputType | null
    _avg: Car_price_typesAvgAggregateOutputType | null
    _sum: Car_price_typesSumAggregateOutputType | null
    _min: Car_price_typesMinAggregateOutputType | null
    _max: Car_price_typesMaxAggregateOutputType | null
  }

  type GetCar_price_typesGroupByPayload<T extends Car_price_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Car_price_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Car_price_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Car_price_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Car_price_typesGroupByOutputType[P]>
        }
      >
    >


  export type car_price_typesSelect = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    car_prices?: boolean | car_price_types$car_pricesArgs
    _count?: boolean | Car_price_typesCountOutputTypeArgs
  }


  export type car_price_typesInclude = {
    car_prices?: boolean | car_price_types$car_pricesArgs
    _count?: boolean | Car_price_typesCountOutputTypeArgs
  }

  export type car_price_typesGetPayload<S extends boolean | null | undefined | car_price_typesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? car_price_types :
    S extends undefined ? never :
    S extends { include: any } & (car_price_typesArgs | car_price_typesFindManyArgs)
    ? car_price_types  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'car_prices' ? Array < car_pricesGetPayload<S['include'][P]>>  :
        P extends '_count' ? Car_price_typesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (car_price_typesArgs | car_price_typesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'car_prices' ? Array < car_pricesGetPayload<S['select'][P]>>  :
        P extends '_count' ? Car_price_typesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof car_price_types ? car_price_types[P] : never
  } 
      : car_price_types


  type car_price_typesCountArgs = 
    Omit<car_price_typesFindManyArgs, 'select' | 'include'> & {
      select?: Car_price_typesCountAggregateInputType | true
    }

  export interface car_price_typesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Car_price_types that matches the filter.
     * @param {car_price_typesFindUniqueArgs} args - Arguments to find a Car_price_types
     * @example
     * // Get one Car_price_types
     * const car_price_types = await prisma.car_price_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends car_price_typesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, car_price_typesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'car_price_types'> extends True ? Prisma__car_price_typesClient<car_price_typesGetPayload<T>> : Prisma__car_price_typesClient<car_price_typesGetPayload<T> | null, null>

    /**
     * Find one Car_price_types that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {car_price_typesFindUniqueOrThrowArgs} args - Arguments to find a Car_price_types
     * @example
     * // Get one Car_price_types
     * const car_price_types = await prisma.car_price_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends car_price_typesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, car_price_typesFindUniqueOrThrowArgs>
    ): Prisma__car_price_typesClient<car_price_typesGetPayload<T>>

    /**
     * Find the first Car_price_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_price_typesFindFirstArgs} args - Arguments to find a Car_price_types
     * @example
     * // Get one Car_price_types
     * const car_price_types = await prisma.car_price_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends car_price_typesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, car_price_typesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'car_price_types'> extends True ? Prisma__car_price_typesClient<car_price_typesGetPayload<T>> : Prisma__car_price_typesClient<car_price_typesGetPayload<T> | null, null>

    /**
     * Find the first Car_price_types that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_price_typesFindFirstOrThrowArgs} args - Arguments to find a Car_price_types
     * @example
     * // Get one Car_price_types
     * const car_price_types = await prisma.car_price_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends car_price_typesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, car_price_typesFindFirstOrThrowArgs>
    ): Prisma__car_price_typesClient<car_price_typesGetPayload<T>>

    /**
     * Find zero or more Car_price_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_price_typesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Car_price_types
     * const car_price_types = await prisma.car_price_types.findMany()
     * 
     * // Get first 10 Car_price_types
     * const car_price_types = await prisma.car_price_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const car_price_typesWithIdOnly = await prisma.car_price_types.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends car_price_typesFindManyArgs>(
      args?: SelectSubset<T, car_price_typesFindManyArgs>
    ): Prisma.PrismaPromise<Array<car_price_typesGetPayload<T>>>

    /**
     * Create a Car_price_types.
     * @param {car_price_typesCreateArgs} args - Arguments to create a Car_price_types.
     * @example
     * // Create one Car_price_types
     * const Car_price_types = await prisma.car_price_types.create({
     *   data: {
     *     // ... data to create a Car_price_types
     *   }
     * })
     * 
    **/
    create<T extends car_price_typesCreateArgs>(
      args: SelectSubset<T, car_price_typesCreateArgs>
    ): Prisma__car_price_typesClient<car_price_typesGetPayload<T>>

    /**
     * Create many Car_price_types.
     *     @param {car_price_typesCreateManyArgs} args - Arguments to create many Car_price_types.
     *     @example
     *     // Create many Car_price_types
     *     const car_price_types = await prisma.car_price_types.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends car_price_typesCreateManyArgs>(
      args?: SelectSubset<T, car_price_typesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Car_price_types.
     * @param {car_price_typesDeleteArgs} args - Arguments to delete one Car_price_types.
     * @example
     * // Delete one Car_price_types
     * const Car_price_types = await prisma.car_price_types.delete({
     *   where: {
     *     // ... filter to delete one Car_price_types
     *   }
     * })
     * 
    **/
    delete<T extends car_price_typesDeleteArgs>(
      args: SelectSubset<T, car_price_typesDeleteArgs>
    ): Prisma__car_price_typesClient<car_price_typesGetPayload<T>>

    /**
     * Update one Car_price_types.
     * @param {car_price_typesUpdateArgs} args - Arguments to update one Car_price_types.
     * @example
     * // Update one Car_price_types
     * const car_price_types = await prisma.car_price_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends car_price_typesUpdateArgs>(
      args: SelectSubset<T, car_price_typesUpdateArgs>
    ): Prisma__car_price_typesClient<car_price_typesGetPayload<T>>

    /**
     * Delete zero or more Car_price_types.
     * @param {car_price_typesDeleteManyArgs} args - Arguments to filter Car_price_types to delete.
     * @example
     * // Delete a few Car_price_types
     * const { count } = await prisma.car_price_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends car_price_typesDeleteManyArgs>(
      args?: SelectSubset<T, car_price_typesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Car_price_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_price_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Car_price_types
     * const car_price_types = await prisma.car_price_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends car_price_typesUpdateManyArgs>(
      args: SelectSubset<T, car_price_typesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Car_price_types.
     * @param {car_price_typesUpsertArgs} args - Arguments to update or create a Car_price_types.
     * @example
     * // Update or create a Car_price_types
     * const car_price_types = await prisma.car_price_types.upsert({
     *   create: {
     *     // ... data to create a Car_price_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Car_price_types we want to update
     *   }
     * })
    **/
    upsert<T extends car_price_typesUpsertArgs>(
      args: SelectSubset<T, car_price_typesUpsertArgs>
    ): Prisma__car_price_typesClient<car_price_typesGetPayload<T>>

    /**
     * Count the number of Car_price_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_price_typesCountArgs} args - Arguments to filter Car_price_types to count.
     * @example
     * // Count the number of Car_price_types
     * const count = await prisma.car_price_types.count({
     *   where: {
     *     // ... the filter for the Car_price_types we want to count
     *   }
     * })
    **/
    count<T extends car_price_typesCountArgs>(
      args?: Subset<T, car_price_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Car_price_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Car_price_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Car_price_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Car_price_typesAggregateArgs>(args: Subset<T, Car_price_typesAggregateArgs>): Prisma.PrismaPromise<GetCar_price_typesAggregateType<T>>

    /**
     * Group by Car_price_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Car_price_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Car_price_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Car_price_typesGroupByArgs['orderBy'] }
        : { orderBy?: Car_price_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Car_price_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCar_price_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for car_price_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__car_price_typesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    car_prices<T extends car_price_types$car_pricesArgs= {}>(args?: Subset<T, car_price_types$car_pricesArgs>): Prisma.PrismaPromise<Array<car_pricesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * car_price_types base type for findUnique actions
   */
  export type car_price_typesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the car_price_types
     */
    select?: car_price_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_price_typesInclude | null
    /**
     * Filter, which car_price_types to fetch.
     */
    where: car_price_typesWhereUniqueInput
  }

  /**
   * car_price_types findUnique
   */
  export interface car_price_typesFindUniqueArgs extends car_price_typesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * car_price_types findUniqueOrThrow
   */
  export type car_price_typesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the car_price_types
     */
    select?: car_price_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_price_typesInclude | null
    /**
     * Filter, which car_price_types to fetch.
     */
    where: car_price_typesWhereUniqueInput
  }


  /**
   * car_price_types base type for findFirst actions
   */
  export type car_price_typesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the car_price_types
     */
    select?: car_price_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_price_typesInclude | null
    /**
     * Filter, which car_price_types to fetch.
     */
    where?: car_price_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of car_price_types to fetch.
     */
    orderBy?: Enumerable<car_price_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for car_price_types.
     */
    cursor?: car_price_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` car_price_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` car_price_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of car_price_types.
     */
    distinct?: Enumerable<Car_price_typesScalarFieldEnum>
  }

  /**
   * car_price_types findFirst
   */
  export interface car_price_typesFindFirstArgs extends car_price_typesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * car_price_types findFirstOrThrow
   */
  export type car_price_typesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the car_price_types
     */
    select?: car_price_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_price_typesInclude | null
    /**
     * Filter, which car_price_types to fetch.
     */
    where?: car_price_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of car_price_types to fetch.
     */
    orderBy?: Enumerable<car_price_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for car_price_types.
     */
    cursor?: car_price_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` car_price_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` car_price_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of car_price_types.
     */
    distinct?: Enumerable<Car_price_typesScalarFieldEnum>
  }


  /**
   * car_price_types findMany
   */
  export type car_price_typesFindManyArgs = {
    /**
     * Select specific fields to fetch from the car_price_types
     */
    select?: car_price_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_price_typesInclude | null
    /**
     * Filter, which car_price_types to fetch.
     */
    where?: car_price_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of car_price_types to fetch.
     */
    orderBy?: Enumerable<car_price_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing car_price_types.
     */
    cursor?: car_price_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` car_price_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` car_price_types.
     */
    skip?: number
    distinct?: Enumerable<Car_price_typesScalarFieldEnum>
  }


  /**
   * car_price_types create
   */
  export type car_price_typesCreateArgs = {
    /**
     * Select specific fields to fetch from the car_price_types
     */
    select?: car_price_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_price_typesInclude | null
    /**
     * The data needed to create a car_price_types.
     */
    data: XOR<car_price_typesCreateInput, car_price_typesUncheckedCreateInput>
  }


  /**
   * car_price_types createMany
   */
  export type car_price_typesCreateManyArgs = {
    /**
     * The data used to create many car_price_types.
     */
    data: Enumerable<car_price_typesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * car_price_types update
   */
  export type car_price_typesUpdateArgs = {
    /**
     * Select specific fields to fetch from the car_price_types
     */
    select?: car_price_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_price_typesInclude | null
    /**
     * The data needed to update a car_price_types.
     */
    data: XOR<car_price_typesUpdateInput, car_price_typesUncheckedUpdateInput>
    /**
     * Choose, which car_price_types to update.
     */
    where: car_price_typesWhereUniqueInput
  }


  /**
   * car_price_types updateMany
   */
  export type car_price_typesUpdateManyArgs = {
    /**
     * The data used to update car_price_types.
     */
    data: XOR<car_price_typesUpdateManyMutationInput, car_price_typesUncheckedUpdateManyInput>
    /**
     * Filter which car_price_types to update
     */
    where?: car_price_typesWhereInput
  }


  /**
   * car_price_types upsert
   */
  export type car_price_typesUpsertArgs = {
    /**
     * Select specific fields to fetch from the car_price_types
     */
    select?: car_price_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_price_typesInclude | null
    /**
     * The filter to search for the car_price_types to update in case it exists.
     */
    where: car_price_typesWhereUniqueInput
    /**
     * In case the car_price_types found by the `where` argument doesn't exist, create a new car_price_types with this data.
     */
    create: XOR<car_price_typesCreateInput, car_price_typesUncheckedCreateInput>
    /**
     * In case the car_price_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<car_price_typesUpdateInput, car_price_typesUncheckedUpdateInput>
  }


  /**
   * car_price_types delete
   */
  export type car_price_typesDeleteArgs = {
    /**
     * Select specific fields to fetch from the car_price_types
     */
    select?: car_price_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_price_typesInclude | null
    /**
     * Filter which car_price_types to delete.
     */
    where: car_price_typesWhereUniqueInput
  }


  /**
   * car_price_types deleteMany
   */
  export type car_price_typesDeleteManyArgs = {
    /**
     * Filter which car_price_types to delete
     */
    where?: car_price_typesWhereInput
  }


  /**
   * car_price_types.car_prices
   */
  export type car_price_types$car_pricesArgs = {
    /**
     * Select specific fields to fetch from the car_prices
     */
    select?: car_pricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_pricesInclude | null
    where?: car_pricesWhereInput
    orderBy?: Enumerable<car_pricesOrderByWithRelationInput>
    cursor?: car_pricesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Car_pricesScalarFieldEnum>
  }


  /**
   * car_price_types without action
   */
  export type car_price_typesArgs = {
    /**
     * Select specific fields to fetch from the car_price_types
     */
    select?: car_price_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_price_typesInclude | null
  }



  /**
   * Model car_prices
   */


  export type AggregateCar_prices = {
    _count: Car_pricesCountAggregateOutputType | null
    _avg: Car_pricesAvgAggregateOutputType | null
    _sum: Car_pricesSumAggregateOutputType | null
    _min: Car_pricesMinAggregateOutputType | null
    _max: Car_pricesMaxAggregateOutputType | null
  }

  export type Car_pricesAvgAggregateOutputType = {
    id: number | null
    car_id: number | null
    car_price_type_id: number | null
    monday: number | null
    tuesday: number | null
    wednesday: number | null
    thursday: number | null
    friday: number | null
    saturday: number | null
    sunday: number | null
  }

  export type Car_pricesSumAggregateOutputType = {
    id: number | null
    car_id: number | null
    car_price_type_id: number | null
    monday: number | null
    tuesday: number | null
    wednesday: number | null
    thursday: number | null
    friday: number | null
    saturday: number | null
    sunday: number | null
  }

  export type Car_pricesMinAggregateOutputType = {
    id: number | null
    car_id: number | null
    car_price_type_id: number | null
    monday: number | null
    tuesday: number | null
    wednesday: number | null
    thursday: number | null
    friday: number | null
    saturday: number | null
    sunday: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Car_pricesMaxAggregateOutputType = {
    id: number | null
    car_id: number | null
    car_price_type_id: number | null
    monday: number | null
    tuesday: number | null
    wednesday: number | null
    thursday: number | null
    friday: number | null
    saturday: number | null
    sunday: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Car_pricesCountAggregateOutputType = {
    id: number
    car_id: number
    car_price_type_id: number
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Car_pricesAvgAggregateInputType = {
    id?: true
    car_id?: true
    car_price_type_id?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
  }

  export type Car_pricesSumAggregateInputType = {
    id?: true
    car_id?: true
    car_price_type_id?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
  }

  export type Car_pricesMinAggregateInputType = {
    id?: true
    car_id?: true
    car_price_type_id?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
    created_at?: true
    updated_at?: true
  }

  export type Car_pricesMaxAggregateInputType = {
    id?: true
    car_id?: true
    car_price_type_id?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
    created_at?: true
    updated_at?: true
  }

  export type Car_pricesCountAggregateInputType = {
    id?: true
    car_id?: true
    car_price_type_id?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Car_pricesAggregateArgs = {
    /**
     * Filter which car_prices to aggregate.
     */
    where?: car_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of car_prices to fetch.
     */
    orderBy?: Enumerable<car_pricesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: car_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` car_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` car_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned car_prices
    **/
    _count?: true | Car_pricesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Car_pricesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Car_pricesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Car_pricesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Car_pricesMaxAggregateInputType
  }

  export type GetCar_pricesAggregateType<T extends Car_pricesAggregateArgs> = {
        [P in keyof T & keyof AggregateCar_prices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCar_prices[P]>
      : GetScalarType<T[P], AggregateCar_prices[P]>
  }




  export type Car_pricesGroupByArgs = {
    where?: car_pricesWhereInput
    orderBy?: Enumerable<car_pricesOrderByWithAggregationInput>
    by: Car_pricesScalarFieldEnum[]
    having?: car_pricesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Car_pricesCountAggregateInputType | true
    _avg?: Car_pricesAvgAggregateInputType
    _sum?: Car_pricesSumAggregateInputType
    _min?: Car_pricesMinAggregateInputType
    _max?: Car_pricesMaxAggregateInputType
  }


  export type Car_pricesGroupByOutputType = {
    id: number
    car_id: number
    car_price_type_id: number
    monday: number | null
    tuesday: number | null
    wednesday: number | null
    thursday: number | null
    friday: number | null
    saturday: number | null
    sunday: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: Car_pricesCountAggregateOutputType | null
    _avg: Car_pricesAvgAggregateOutputType | null
    _sum: Car_pricesSumAggregateOutputType | null
    _min: Car_pricesMinAggregateOutputType | null
    _max: Car_pricesMaxAggregateOutputType | null
  }

  type GetCar_pricesGroupByPayload<T extends Car_pricesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Car_pricesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Car_pricesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Car_pricesGroupByOutputType[P]>
            : GetScalarType<T[P], Car_pricesGroupByOutputType[P]>
        }
      >
    >


  export type car_pricesSelect = {
    id?: boolean
    car_id?: boolean
    car_price_type_id?: boolean
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    created_at?: boolean
    updated_at?: boolean
    cars?: boolean | carsArgs
    car_price_types?: boolean | car_price_typesArgs
  }


  export type car_pricesInclude = {
    cars?: boolean | carsArgs
    car_price_types?: boolean | car_price_typesArgs
  }

  export type car_pricesGetPayload<S extends boolean | null | undefined | car_pricesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? car_prices :
    S extends undefined ? never :
    S extends { include: any } & (car_pricesArgs | car_pricesFindManyArgs)
    ? car_prices  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'cars' ? carsGetPayload<S['include'][P]> :
        P extends 'car_price_types' ? car_price_typesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (car_pricesArgs | car_pricesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'cars' ? carsGetPayload<S['select'][P]> :
        P extends 'car_price_types' ? car_price_typesGetPayload<S['select'][P]> :  P extends keyof car_prices ? car_prices[P] : never
  } 
      : car_prices


  type car_pricesCountArgs = 
    Omit<car_pricesFindManyArgs, 'select' | 'include'> & {
      select?: Car_pricesCountAggregateInputType | true
    }

  export interface car_pricesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Car_prices that matches the filter.
     * @param {car_pricesFindUniqueArgs} args - Arguments to find a Car_prices
     * @example
     * // Get one Car_prices
     * const car_prices = await prisma.car_prices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends car_pricesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, car_pricesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'car_prices'> extends True ? Prisma__car_pricesClient<car_pricesGetPayload<T>> : Prisma__car_pricesClient<car_pricesGetPayload<T> | null, null>

    /**
     * Find one Car_prices that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {car_pricesFindUniqueOrThrowArgs} args - Arguments to find a Car_prices
     * @example
     * // Get one Car_prices
     * const car_prices = await prisma.car_prices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends car_pricesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, car_pricesFindUniqueOrThrowArgs>
    ): Prisma__car_pricesClient<car_pricesGetPayload<T>>

    /**
     * Find the first Car_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_pricesFindFirstArgs} args - Arguments to find a Car_prices
     * @example
     * // Get one Car_prices
     * const car_prices = await prisma.car_prices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends car_pricesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, car_pricesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'car_prices'> extends True ? Prisma__car_pricesClient<car_pricesGetPayload<T>> : Prisma__car_pricesClient<car_pricesGetPayload<T> | null, null>

    /**
     * Find the first Car_prices that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_pricesFindFirstOrThrowArgs} args - Arguments to find a Car_prices
     * @example
     * // Get one Car_prices
     * const car_prices = await prisma.car_prices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends car_pricesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, car_pricesFindFirstOrThrowArgs>
    ): Prisma__car_pricesClient<car_pricesGetPayload<T>>

    /**
     * Find zero or more Car_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_pricesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Car_prices
     * const car_prices = await prisma.car_prices.findMany()
     * 
     * // Get first 10 Car_prices
     * const car_prices = await prisma.car_prices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const car_pricesWithIdOnly = await prisma.car_prices.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends car_pricesFindManyArgs>(
      args?: SelectSubset<T, car_pricesFindManyArgs>
    ): Prisma.PrismaPromise<Array<car_pricesGetPayload<T>>>

    /**
     * Create a Car_prices.
     * @param {car_pricesCreateArgs} args - Arguments to create a Car_prices.
     * @example
     * // Create one Car_prices
     * const Car_prices = await prisma.car_prices.create({
     *   data: {
     *     // ... data to create a Car_prices
     *   }
     * })
     * 
    **/
    create<T extends car_pricesCreateArgs>(
      args: SelectSubset<T, car_pricesCreateArgs>
    ): Prisma__car_pricesClient<car_pricesGetPayload<T>>

    /**
     * Create many Car_prices.
     *     @param {car_pricesCreateManyArgs} args - Arguments to create many Car_prices.
     *     @example
     *     // Create many Car_prices
     *     const car_prices = await prisma.car_prices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends car_pricesCreateManyArgs>(
      args?: SelectSubset<T, car_pricesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Car_prices.
     * @param {car_pricesDeleteArgs} args - Arguments to delete one Car_prices.
     * @example
     * // Delete one Car_prices
     * const Car_prices = await prisma.car_prices.delete({
     *   where: {
     *     // ... filter to delete one Car_prices
     *   }
     * })
     * 
    **/
    delete<T extends car_pricesDeleteArgs>(
      args: SelectSubset<T, car_pricesDeleteArgs>
    ): Prisma__car_pricesClient<car_pricesGetPayload<T>>

    /**
     * Update one Car_prices.
     * @param {car_pricesUpdateArgs} args - Arguments to update one Car_prices.
     * @example
     * // Update one Car_prices
     * const car_prices = await prisma.car_prices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends car_pricesUpdateArgs>(
      args: SelectSubset<T, car_pricesUpdateArgs>
    ): Prisma__car_pricesClient<car_pricesGetPayload<T>>

    /**
     * Delete zero or more Car_prices.
     * @param {car_pricesDeleteManyArgs} args - Arguments to filter Car_prices to delete.
     * @example
     * // Delete a few Car_prices
     * const { count } = await prisma.car_prices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends car_pricesDeleteManyArgs>(
      args?: SelectSubset<T, car_pricesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Car_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_pricesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Car_prices
     * const car_prices = await prisma.car_prices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends car_pricesUpdateManyArgs>(
      args: SelectSubset<T, car_pricesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Car_prices.
     * @param {car_pricesUpsertArgs} args - Arguments to update or create a Car_prices.
     * @example
     * // Update or create a Car_prices
     * const car_prices = await prisma.car_prices.upsert({
     *   create: {
     *     // ... data to create a Car_prices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Car_prices we want to update
     *   }
     * })
    **/
    upsert<T extends car_pricesUpsertArgs>(
      args: SelectSubset<T, car_pricesUpsertArgs>
    ): Prisma__car_pricesClient<car_pricesGetPayload<T>>

    /**
     * Count the number of Car_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {car_pricesCountArgs} args - Arguments to filter Car_prices to count.
     * @example
     * // Count the number of Car_prices
     * const count = await prisma.car_prices.count({
     *   where: {
     *     // ... the filter for the Car_prices we want to count
     *   }
     * })
    **/
    count<T extends car_pricesCountArgs>(
      args?: Subset<T, car_pricesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Car_pricesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Car_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Car_pricesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Car_pricesAggregateArgs>(args: Subset<T, Car_pricesAggregateArgs>): Prisma.PrismaPromise<GetCar_pricesAggregateType<T>>

    /**
     * Group by Car_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Car_pricesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Car_pricesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Car_pricesGroupByArgs['orderBy'] }
        : { orderBy?: Car_pricesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Car_pricesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCar_pricesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for car_prices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__car_pricesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cars<T extends carsArgs= {}>(args?: Subset<T, carsArgs>): Prisma__carsClient<carsGetPayload<T> | Null>;

    car_price_types<T extends car_price_typesArgs= {}>(args?: Subset<T, car_price_typesArgs>): Prisma__car_price_typesClient<car_price_typesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * car_prices base type for findUnique actions
   */
  export type car_pricesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the car_prices
     */
    select?: car_pricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_pricesInclude | null
    /**
     * Filter, which car_prices to fetch.
     */
    where: car_pricesWhereUniqueInput
  }

  /**
   * car_prices findUnique
   */
  export interface car_pricesFindUniqueArgs extends car_pricesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * car_prices findUniqueOrThrow
   */
  export type car_pricesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the car_prices
     */
    select?: car_pricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_pricesInclude | null
    /**
     * Filter, which car_prices to fetch.
     */
    where: car_pricesWhereUniqueInput
  }


  /**
   * car_prices base type for findFirst actions
   */
  export type car_pricesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the car_prices
     */
    select?: car_pricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_pricesInclude | null
    /**
     * Filter, which car_prices to fetch.
     */
    where?: car_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of car_prices to fetch.
     */
    orderBy?: Enumerable<car_pricesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for car_prices.
     */
    cursor?: car_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` car_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` car_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of car_prices.
     */
    distinct?: Enumerable<Car_pricesScalarFieldEnum>
  }

  /**
   * car_prices findFirst
   */
  export interface car_pricesFindFirstArgs extends car_pricesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * car_prices findFirstOrThrow
   */
  export type car_pricesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the car_prices
     */
    select?: car_pricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_pricesInclude | null
    /**
     * Filter, which car_prices to fetch.
     */
    where?: car_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of car_prices to fetch.
     */
    orderBy?: Enumerable<car_pricesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for car_prices.
     */
    cursor?: car_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` car_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` car_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of car_prices.
     */
    distinct?: Enumerable<Car_pricesScalarFieldEnum>
  }


  /**
   * car_prices findMany
   */
  export type car_pricesFindManyArgs = {
    /**
     * Select specific fields to fetch from the car_prices
     */
    select?: car_pricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_pricesInclude | null
    /**
     * Filter, which car_prices to fetch.
     */
    where?: car_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of car_prices to fetch.
     */
    orderBy?: Enumerable<car_pricesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing car_prices.
     */
    cursor?: car_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` car_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` car_prices.
     */
    skip?: number
    distinct?: Enumerable<Car_pricesScalarFieldEnum>
  }


  /**
   * car_prices create
   */
  export type car_pricesCreateArgs = {
    /**
     * Select specific fields to fetch from the car_prices
     */
    select?: car_pricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_pricesInclude | null
    /**
     * The data needed to create a car_prices.
     */
    data: XOR<car_pricesCreateInput, car_pricesUncheckedCreateInput>
  }


  /**
   * car_prices createMany
   */
  export type car_pricesCreateManyArgs = {
    /**
     * The data used to create many car_prices.
     */
    data: Enumerable<car_pricesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * car_prices update
   */
  export type car_pricesUpdateArgs = {
    /**
     * Select specific fields to fetch from the car_prices
     */
    select?: car_pricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_pricesInclude | null
    /**
     * The data needed to update a car_prices.
     */
    data: XOR<car_pricesUpdateInput, car_pricesUncheckedUpdateInput>
    /**
     * Choose, which car_prices to update.
     */
    where: car_pricesWhereUniqueInput
  }


  /**
   * car_prices updateMany
   */
  export type car_pricesUpdateManyArgs = {
    /**
     * The data used to update car_prices.
     */
    data: XOR<car_pricesUpdateManyMutationInput, car_pricesUncheckedUpdateManyInput>
    /**
     * Filter which car_prices to update
     */
    where?: car_pricesWhereInput
  }


  /**
   * car_prices upsert
   */
  export type car_pricesUpsertArgs = {
    /**
     * Select specific fields to fetch from the car_prices
     */
    select?: car_pricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_pricesInclude | null
    /**
     * The filter to search for the car_prices to update in case it exists.
     */
    where: car_pricesWhereUniqueInput
    /**
     * In case the car_prices found by the `where` argument doesn't exist, create a new car_prices with this data.
     */
    create: XOR<car_pricesCreateInput, car_pricesUncheckedCreateInput>
    /**
     * In case the car_prices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<car_pricesUpdateInput, car_pricesUncheckedUpdateInput>
  }


  /**
   * car_prices delete
   */
  export type car_pricesDeleteArgs = {
    /**
     * Select specific fields to fetch from the car_prices
     */
    select?: car_pricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_pricesInclude | null
    /**
     * Filter which car_prices to delete.
     */
    where: car_pricesWhereUniqueInput
  }


  /**
   * car_prices deleteMany
   */
  export type car_pricesDeleteManyArgs = {
    /**
     * Filter which car_prices to delete
     */
    where?: car_pricesWhereInput
  }


  /**
   * car_prices without action
   */
  export type car_pricesArgs = {
    /**
     * Select specific fields to fetch from the car_prices
     */
    select?: car_pricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_pricesInclude | null
  }



  /**
   * Model cars
   */


  export type AggregateCars = {
    _count: CarsCountAggregateOutputType | null
    _avg: CarsAvgAggregateOutputType | null
    _sum: CarsSumAggregateOutputType | null
    _min: CarsMinAggregateOutputType | null
    _max: CarsMaxAggregateOutputType | null
  }

  export type CarsAvgAggregateOutputType = {
    id: number | null
    body_type_id: number | null
    transmission_id: number | null
    manufacturer_id: number | null
    driver_id: number | null
    fuel_id: number | null
    vehicle_type_id: number | null
    passenger_seats: number | null
    maximum_luggage: number | null
    total_doors: number | null
    child_seat: number | null
    per_mile_rate: number | null
    hourly_rate: number | null
    minimum_fare: number | null
    minimum_hours: number | null
    fixed_price: number | null
  }

  export type CarsSumAggregateOutputType = {
    id: number | null
    body_type_id: number | null
    transmission_id: number | null
    manufacturer_id: number | null
    driver_id: number | null
    fuel_id: number | null
    vehicle_type_id: number | null
    passenger_seats: number | null
    maximum_luggage: number | null
    total_doors: number | null
    child_seat: number | null
    per_mile_rate: number | null
    hourly_rate: number | null
    minimum_fare: number | null
    minimum_hours: number | null
    fixed_price: number | null
  }

  export type CarsMinAggregateOutputType = {
    id: number | null
    body_type_id: number | null
    transmission_id: number | null
    manufacturer_id: number | null
    driver_id: number | null
    fuel_id: number | null
    vehicle_type_id: number | null
    car_model: string | null
    name: string | null
    qty: string | null
    passenger_seats: number | null
    maximum_luggage: number | null
    total_doors: number | null
    child_seat: number | null
    image: string | null
    status: boolean | null
    per_mile_rate: number | null
    hourly_rate: number | null
    minimum_fare: number | null
    minimum_hours: number | null
    fixed_price: number | null
    is_slab_enabled: boolean | null
    is_loc_enabled: boolean | null
    created_at: Date | null
    updated_at: Date | null
    isActive: boolean | null
    car_type: cars_car_type | null
  }

  export type CarsMaxAggregateOutputType = {
    id: number | null
    body_type_id: number | null
    transmission_id: number | null
    manufacturer_id: number | null
    driver_id: number | null
    fuel_id: number | null
    vehicle_type_id: number | null
    car_model: string | null
    name: string | null
    qty: string | null
    passenger_seats: number | null
    maximum_luggage: number | null
    total_doors: number | null
    child_seat: number | null
    image: string | null
    status: boolean | null
    per_mile_rate: number | null
    hourly_rate: number | null
    minimum_fare: number | null
    minimum_hours: number | null
    fixed_price: number | null
    is_slab_enabled: boolean | null
    is_loc_enabled: boolean | null
    created_at: Date | null
    updated_at: Date | null
    isActive: boolean | null
    car_type: cars_car_type | null
  }

  export type CarsCountAggregateOutputType = {
    id: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model: number
    name: number
    qty: number
    passenger_seats: number
    maximum_luggage: number
    total_doors: number
    child_seat: number
    image: number
    status: number
    per_mile_rate: number
    hourly_rate: number
    minimum_fare: number
    minimum_hours: number
    fixed_price: number
    is_slab_enabled: number
    is_loc_enabled: number
    created_at: number
    updated_at: number
    isActive: number
    car_type: number
    _all: number
  }


  export type CarsAvgAggregateInputType = {
    id?: true
    body_type_id?: true
    transmission_id?: true
    manufacturer_id?: true
    driver_id?: true
    fuel_id?: true
    vehicle_type_id?: true
    passenger_seats?: true
    maximum_luggage?: true
    total_doors?: true
    child_seat?: true
    per_mile_rate?: true
    hourly_rate?: true
    minimum_fare?: true
    minimum_hours?: true
    fixed_price?: true
  }

  export type CarsSumAggregateInputType = {
    id?: true
    body_type_id?: true
    transmission_id?: true
    manufacturer_id?: true
    driver_id?: true
    fuel_id?: true
    vehicle_type_id?: true
    passenger_seats?: true
    maximum_luggage?: true
    total_doors?: true
    child_seat?: true
    per_mile_rate?: true
    hourly_rate?: true
    minimum_fare?: true
    minimum_hours?: true
    fixed_price?: true
  }

  export type CarsMinAggregateInputType = {
    id?: true
    body_type_id?: true
    transmission_id?: true
    manufacturer_id?: true
    driver_id?: true
    fuel_id?: true
    vehicle_type_id?: true
    car_model?: true
    name?: true
    qty?: true
    passenger_seats?: true
    maximum_luggage?: true
    total_doors?: true
    child_seat?: true
    image?: true
    status?: true
    per_mile_rate?: true
    hourly_rate?: true
    minimum_fare?: true
    minimum_hours?: true
    fixed_price?: true
    is_slab_enabled?: true
    is_loc_enabled?: true
    created_at?: true
    updated_at?: true
    isActive?: true
    car_type?: true
  }

  export type CarsMaxAggregateInputType = {
    id?: true
    body_type_id?: true
    transmission_id?: true
    manufacturer_id?: true
    driver_id?: true
    fuel_id?: true
    vehicle_type_id?: true
    car_model?: true
    name?: true
    qty?: true
    passenger_seats?: true
    maximum_luggage?: true
    total_doors?: true
    child_seat?: true
    image?: true
    status?: true
    per_mile_rate?: true
    hourly_rate?: true
    minimum_fare?: true
    minimum_hours?: true
    fixed_price?: true
    is_slab_enabled?: true
    is_loc_enabled?: true
    created_at?: true
    updated_at?: true
    isActive?: true
    car_type?: true
  }

  export type CarsCountAggregateInputType = {
    id?: true
    body_type_id?: true
    transmission_id?: true
    manufacturer_id?: true
    driver_id?: true
    fuel_id?: true
    vehicle_type_id?: true
    car_model?: true
    name?: true
    qty?: true
    passenger_seats?: true
    maximum_luggage?: true
    total_doors?: true
    child_seat?: true
    image?: true
    status?: true
    per_mile_rate?: true
    hourly_rate?: true
    minimum_fare?: true
    minimum_hours?: true
    fixed_price?: true
    is_slab_enabled?: true
    is_loc_enabled?: true
    created_at?: true
    updated_at?: true
    isActive?: true
    car_type?: true
    _all?: true
  }

  export type CarsAggregateArgs = {
    /**
     * Filter which cars to aggregate.
     */
    where?: carsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cars to fetch.
     */
    orderBy?: Enumerable<carsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: carsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cars
    **/
    _count?: true | CarsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarsMaxAggregateInputType
  }

  export type GetCarsAggregateType<T extends CarsAggregateArgs> = {
        [P in keyof T & keyof AggregateCars]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCars[P]>
      : GetScalarType<T[P], AggregateCars[P]>
  }




  export type CarsGroupByArgs = {
    where?: carsWhereInput
    orderBy?: Enumerable<carsOrderByWithAggregationInput>
    by: CarsScalarFieldEnum[]
    having?: carsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarsCountAggregateInputType | true
    _avg?: CarsAvgAggregateInputType
    _sum?: CarsSumAggregateInputType
    _min?: CarsMinAggregateInputType
    _max?: CarsMaxAggregateInputType
  }


  export type CarsGroupByOutputType = {
    id: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model: string | null
    name: string | null
    qty: string | null
    passenger_seats: number | null
    maximum_luggage: number | null
    total_doors: number | null
    child_seat: number | null
    image: string | null
    status: boolean | null
    per_mile_rate: number | null
    hourly_rate: number | null
    minimum_fare: number | null
    minimum_hours: number | null
    fixed_price: number | null
    is_slab_enabled: boolean | null
    is_loc_enabled: boolean | null
    created_at: Date | null
    updated_at: Date | null
    isActive: boolean | null
    car_type: cars_car_type | null
    _count: CarsCountAggregateOutputType | null
    _avg: CarsAvgAggregateOutputType | null
    _sum: CarsSumAggregateOutputType | null
    _min: CarsMinAggregateOutputType | null
    _max: CarsMaxAggregateOutputType | null
  }

  type GetCarsGroupByPayload<T extends CarsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CarsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarsGroupByOutputType[P]>
            : GetScalarType<T[P], CarsGroupByOutputType[P]>
        }
      >
    >


  export type carsSelect = {
    id?: boolean
    body_type_id?: boolean
    transmission_id?: boolean
    manufacturer_id?: boolean
    driver_id?: boolean
    fuel_id?: boolean
    vehicle_type_id?: boolean
    car_model?: boolean
    name?: boolean
    qty?: boolean
    passenger_seats?: boolean
    maximum_luggage?: boolean
    total_doors?: boolean
    child_seat?: boolean
    image?: boolean
    status?: boolean
    per_mile_rate?: boolean
    hourly_rate?: boolean
    minimum_fare?: boolean
    minimum_hours?: boolean
    fixed_price?: boolean
    is_slab_enabled?: boolean
    is_loc_enabled?: boolean
    created_at?: boolean
    updated_at?: boolean
    isActive?: boolean
    car_type?: boolean
    car_prices?: boolean | cars$car_pricesArgs
    body_types?: boolean | body_typesArgs
    drivers?: boolean | driversArgs
    fuel_types?: boolean | fuel_typesArgs
    manufacturers?: boolean | manufacturersArgs
    transmissions?: boolean | transmissionsArgs
    vehicle_types?: boolean | vehicle_typesArgs
    package_serivce?: boolean | cars$package_serivceArgs
    reservations?: boolean | cars$reservationsArgs
    slabs?: boolean | cars$slabsArgs
    sub_services?: boolean | cars$sub_servicesArgs
    tours?: boolean | cars$toursArgs
    _count?: boolean | CarsCountOutputTypeArgs
  }


  export type carsInclude = {
    car_prices?: boolean | cars$car_pricesArgs
    body_types?: boolean | body_typesArgs
    drivers?: boolean | driversArgs
    fuel_types?: boolean | fuel_typesArgs
    manufacturers?: boolean | manufacturersArgs
    transmissions?: boolean | transmissionsArgs
    vehicle_types?: boolean | vehicle_typesArgs
    package_serivce?: boolean | cars$package_serivceArgs
    reservations?: boolean | cars$reservationsArgs
    slabs?: boolean | cars$slabsArgs
    sub_services?: boolean | cars$sub_servicesArgs
    tours?: boolean | cars$toursArgs
    _count?: boolean | CarsCountOutputTypeArgs
  }

  export type carsGetPayload<S extends boolean | null | undefined | carsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? cars :
    S extends undefined ? never :
    S extends { include: any } & (carsArgs | carsFindManyArgs)
    ? cars  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'car_prices' ? Array < car_pricesGetPayload<S['include'][P]>>  :
        P extends 'body_types' ? body_typesGetPayload<S['include'][P]> :
        P extends 'drivers' ? driversGetPayload<S['include'][P]> :
        P extends 'fuel_types' ? fuel_typesGetPayload<S['include'][P]> :
        P extends 'manufacturers' ? manufacturersGetPayload<S['include'][P]> :
        P extends 'transmissions' ? transmissionsGetPayload<S['include'][P]> :
        P extends 'vehicle_types' ? vehicle_typesGetPayload<S['include'][P]> :
        P extends 'package_serivce' ? Array < package_serivceGetPayload<S['include'][P]>>  :
        P extends 'reservations' ? Array < reservationsGetPayload<S['include'][P]>>  :
        P extends 'slabs' ? Array < slabsGetPayload<S['include'][P]>>  :
        P extends 'sub_services' ? Array < sub_servicesGetPayload<S['include'][P]>>  :
        P extends 'tours' ? Array < toursGetPayload<S['include'][P]>>  :
        P extends '_count' ? CarsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (carsArgs | carsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'car_prices' ? Array < car_pricesGetPayload<S['select'][P]>>  :
        P extends 'body_types' ? body_typesGetPayload<S['select'][P]> :
        P extends 'drivers' ? driversGetPayload<S['select'][P]> :
        P extends 'fuel_types' ? fuel_typesGetPayload<S['select'][P]> :
        P extends 'manufacturers' ? manufacturersGetPayload<S['select'][P]> :
        P extends 'transmissions' ? transmissionsGetPayload<S['select'][P]> :
        P extends 'vehicle_types' ? vehicle_typesGetPayload<S['select'][P]> :
        P extends 'package_serivce' ? Array < package_serivceGetPayload<S['select'][P]>>  :
        P extends 'reservations' ? Array < reservationsGetPayload<S['select'][P]>>  :
        P extends 'slabs' ? Array < slabsGetPayload<S['select'][P]>>  :
        P extends 'sub_services' ? Array < sub_servicesGetPayload<S['select'][P]>>  :
        P extends 'tours' ? Array < toursGetPayload<S['select'][P]>>  :
        P extends '_count' ? CarsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof cars ? cars[P] : never
  } 
      : cars


  type carsCountArgs = 
    Omit<carsFindManyArgs, 'select' | 'include'> & {
      select?: CarsCountAggregateInputType | true
    }

  export interface carsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Cars that matches the filter.
     * @param {carsFindUniqueArgs} args - Arguments to find a Cars
     * @example
     * // Get one Cars
     * const cars = await prisma.cars.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends carsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, carsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cars'> extends True ? Prisma__carsClient<carsGetPayload<T>> : Prisma__carsClient<carsGetPayload<T> | null, null>

    /**
     * Find one Cars that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {carsFindUniqueOrThrowArgs} args - Arguments to find a Cars
     * @example
     * // Get one Cars
     * const cars = await prisma.cars.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends carsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, carsFindUniqueOrThrowArgs>
    ): Prisma__carsClient<carsGetPayload<T>>

    /**
     * Find the first Cars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carsFindFirstArgs} args - Arguments to find a Cars
     * @example
     * // Get one Cars
     * const cars = await prisma.cars.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends carsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, carsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cars'> extends True ? Prisma__carsClient<carsGetPayload<T>> : Prisma__carsClient<carsGetPayload<T> | null, null>

    /**
     * Find the first Cars that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carsFindFirstOrThrowArgs} args - Arguments to find a Cars
     * @example
     * // Get one Cars
     * const cars = await prisma.cars.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends carsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, carsFindFirstOrThrowArgs>
    ): Prisma__carsClient<carsGetPayload<T>>

    /**
     * Find zero or more Cars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cars
     * const cars = await prisma.cars.findMany()
     * 
     * // Get first 10 Cars
     * const cars = await prisma.cars.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carsWithIdOnly = await prisma.cars.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends carsFindManyArgs>(
      args?: SelectSubset<T, carsFindManyArgs>
    ): Prisma.PrismaPromise<Array<carsGetPayload<T>>>

    /**
     * Create a Cars.
     * @param {carsCreateArgs} args - Arguments to create a Cars.
     * @example
     * // Create one Cars
     * const Cars = await prisma.cars.create({
     *   data: {
     *     // ... data to create a Cars
     *   }
     * })
     * 
    **/
    create<T extends carsCreateArgs>(
      args: SelectSubset<T, carsCreateArgs>
    ): Prisma__carsClient<carsGetPayload<T>>

    /**
     * Create many Cars.
     *     @param {carsCreateManyArgs} args - Arguments to create many Cars.
     *     @example
     *     // Create many Cars
     *     const cars = await prisma.cars.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends carsCreateManyArgs>(
      args?: SelectSubset<T, carsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cars.
     * @param {carsDeleteArgs} args - Arguments to delete one Cars.
     * @example
     * // Delete one Cars
     * const Cars = await prisma.cars.delete({
     *   where: {
     *     // ... filter to delete one Cars
     *   }
     * })
     * 
    **/
    delete<T extends carsDeleteArgs>(
      args: SelectSubset<T, carsDeleteArgs>
    ): Prisma__carsClient<carsGetPayload<T>>

    /**
     * Update one Cars.
     * @param {carsUpdateArgs} args - Arguments to update one Cars.
     * @example
     * // Update one Cars
     * const cars = await prisma.cars.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends carsUpdateArgs>(
      args: SelectSubset<T, carsUpdateArgs>
    ): Prisma__carsClient<carsGetPayload<T>>

    /**
     * Delete zero or more Cars.
     * @param {carsDeleteManyArgs} args - Arguments to filter Cars to delete.
     * @example
     * // Delete a few Cars
     * const { count } = await prisma.cars.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends carsDeleteManyArgs>(
      args?: SelectSubset<T, carsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cars
     * const cars = await prisma.cars.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends carsUpdateManyArgs>(
      args: SelectSubset<T, carsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cars.
     * @param {carsUpsertArgs} args - Arguments to update or create a Cars.
     * @example
     * // Update or create a Cars
     * const cars = await prisma.cars.upsert({
     *   create: {
     *     // ... data to create a Cars
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cars we want to update
     *   }
     * })
    **/
    upsert<T extends carsUpsertArgs>(
      args: SelectSubset<T, carsUpsertArgs>
    ): Prisma__carsClient<carsGetPayload<T>>

    /**
     * Count the number of Cars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carsCountArgs} args - Arguments to filter Cars to count.
     * @example
     * // Count the number of Cars
     * const count = await prisma.cars.count({
     *   where: {
     *     // ... the filter for the Cars we want to count
     *   }
     * })
    **/
    count<T extends carsCountArgs>(
      args?: Subset<T, carsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarsAggregateArgs>(args: Subset<T, CarsAggregateArgs>): Prisma.PrismaPromise<GetCarsAggregateType<T>>

    /**
     * Group by Cars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarsGroupByArgs['orderBy'] }
        : { orderBy?: CarsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for cars.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__carsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    car_prices<T extends cars$car_pricesArgs= {}>(args?: Subset<T, cars$car_pricesArgs>): Prisma.PrismaPromise<Array<car_pricesGetPayload<T>>| Null>;

    body_types<T extends body_typesArgs= {}>(args?: Subset<T, body_typesArgs>): Prisma__body_typesClient<body_typesGetPayload<T> | Null>;

    drivers<T extends driversArgs= {}>(args?: Subset<T, driversArgs>): Prisma__driversClient<driversGetPayload<T> | Null>;

    fuel_types<T extends fuel_typesArgs= {}>(args?: Subset<T, fuel_typesArgs>): Prisma__fuel_typesClient<fuel_typesGetPayload<T> | Null>;

    manufacturers<T extends manufacturersArgs= {}>(args?: Subset<T, manufacturersArgs>): Prisma__manufacturersClient<manufacturersGetPayload<T> | Null>;

    transmissions<T extends transmissionsArgs= {}>(args?: Subset<T, transmissionsArgs>): Prisma__transmissionsClient<transmissionsGetPayload<T> | Null>;

    vehicle_types<T extends vehicle_typesArgs= {}>(args?: Subset<T, vehicle_typesArgs>): Prisma__vehicle_typesClient<vehicle_typesGetPayload<T> | Null>;

    package_serivce<T extends cars$package_serivceArgs= {}>(args?: Subset<T, cars$package_serivceArgs>): Prisma.PrismaPromise<Array<package_serivceGetPayload<T>>| Null>;

    reservations<T extends cars$reservationsArgs= {}>(args?: Subset<T, cars$reservationsArgs>): Prisma.PrismaPromise<Array<reservationsGetPayload<T>>| Null>;

    slabs<T extends cars$slabsArgs= {}>(args?: Subset<T, cars$slabsArgs>): Prisma.PrismaPromise<Array<slabsGetPayload<T>>| Null>;

    sub_services<T extends cars$sub_servicesArgs= {}>(args?: Subset<T, cars$sub_servicesArgs>): Prisma.PrismaPromise<Array<sub_servicesGetPayload<T>>| Null>;

    tours<T extends cars$toursArgs= {}>(args?: Subset<T, cars$toursArgs>): Prisma.PrismaPromise<Array<toursGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * cars base type for findUnique actions
   */
  export type carsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    /**
     * Filter, which cars to fetch.
     */
    where: carsWhereUniqueInput
  }

  /**
   * cars findUnique
   */
  export interface carsFindUniqueArgs extends carsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cars findUniqueOrThrow
   */
  export type carsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    /**
     * Filter, which cars to fetch.
     */
    where: carsWhereUniqueInput
  }


  /**
   * cars base type for findFirst actions
   */
  export type carsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    /**
     * Filter, which cars to fetch.
     */
    where?: carsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cars to fetch.
     */
    orderBy?: Enumerable<carsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cars.
     */
    cursor?: carsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cars.
     */
    distinct?: Enumerable<CarsScalarFieldEnum>
  }

  /**
   * cars findFirst
   */
  export interface carsFindFirstArgs extends carsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cars findFirstOrThrow
   */
  export type carsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    /**
     * Filter, which cars to fetch.
     */
    where?: carsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cars to fetch.
     */
    orderBy?: Enumerable<carsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cars.
     */
    cursor?: carsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cars.
     */
    distinct?: Enumerable<CarsScalarFieldEnum>
  }


  /**
   * cars findMany
   */
  export type carsFindManyArgs = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    /**
     * Filter, which cars to fetch.
     */
    where?: carsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cars to fetch.
     */
    orderBy?: Enumerable<carsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cars.
     */
    cursor?: carsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cars.
     */
    skip?: number
    distinct?: Enumerable<CarsScalarFieldEnum>
  }


  /**
   * cars create
   */
  export type carsCreateArgs = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    /**
     * The data needed to create a cars.
     */
    data: XOR<carsCreateInput, carsUncheckedCreateInput>
  }


  /**
   * cars createMany
   */
  export type carsCreateManyArgs = {
    /**
     * The data used to create many cars.
     */
    data: Enumerable<carsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cars update
   */
  export type carsUpdateArgs = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    /**
     * The data needed to update a cars.
     */
    data: XOR<carsUpdateInput, carsUncheckedUpdateInput>
    /**
     * Choose, which cars to update.
     */
    where: carsWhereUniqueInput
  }


  /**
   * cars updateMany
   */
  export type carsUpdateManyArgs = {
    /**
     * The data used to update cars.
     */
    data: XOR<carsUpdateManyMutationInput, carsUncheckedUpdateManyInput>
    /**
     * Filter which cars to update
     */
    where?: carsWhereInput
  }


  /**
   * cars upsert
   */
  export type carsUpsertArgs = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    /**
     * The filter to search for the cars to update in case it exists.
     */
    where: carsWhereUniqueInput
    /**
     * In case the cars found by the `where` argument doesn't exist, create a new cars with this data.
     */
    create: XOR<carsCreateInput, carsUncheckedCreateInput>
    /**
     * In case the cars was found with the provided `where` argument, update it with this data.
     */
    update: XOR<carsUpdateInput, carsUncheckedUpdateInput>
  }


  /**
   * cars delete
   */
  export type carsDeleteArgs = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    /**
     * Filter which cars to delete.
     */
    where: carsWhereUniqueInput
  }


  /**
   * cars deleteMany
   */
  export type carsDeleteManyArgs = {
    /**
     * Filter which cars to delete
     */
    where?: carsWhereInput
  }


  /**
   * cars.car_prices
   */
  export type cars$car_pricesArgs = {
    /**
     * Select specific fields to fetch from the car_prices
     */
    select?: car_pricesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: car_pricesInclude | null
    where?: car_pricesWhereInput
    orderBy?: Enumerable<car_pricesOrderByWithRelationInput>
    cursor?: car_pricesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Car_pricesScalarFieldEnum>
  }


  /**
   * cars.package_serivce
   */
  export type cars$package_serivceArgs = {
    /**
     * Select specific fields to fetch from the package_serivce
     */
    select?: package_serivceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: package_serivceInclude | null
    where?: package_serivceWhereInput
    orderBy?: Enumerable<package_serivceOrderByWithRelationInput>
    cursor?: package_serivceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Package_serivceScalarFieldEnum>
  }


  /**
   * cars.reservations
   */
  export type cars$reservationsArgs = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reservationsInclude | null
    where?: reservationsWhereInput
    orderBy?: Enumerable<reservationsOrderByWithRelationInput>
    cursor?: reservationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReservationsScalarFieldEnum>
  }


  /**
   * cars.slabs
   */
  export type cars$slabsArgs = {
    /**
     * Select specific fields to fetch from the slabs
     */
    select?: slabsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slabsInclude | null
    where?: slabsWhereInput
    orderBy?: Enumerable<slabsOrderByWithRelationInput>
    cursor?: slabsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SlabsScalarFieldEnum>
  }


  /**
   * cars.sub_services
   */
  export type cars$sub_servicesArgs = {
    /**
     * Select specific fields to fetch from the sub_services
     */
    select?: sub_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_servicesInclude | null
    where?: sub_servicesWhereInput
    orderBy?: Enumerable<sub_servicesOrderByWithRelationInput>
    cursor?: sub_servicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Sub_servicesScalarFieldEnum>
  }


  /**
   * cars.tours
   */
  export type cars$toursArgs = {
    /**
     * Select specific fields to fetch from the tours
     */
    select?: toursSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: toursInclude | null
    where?: toursWhereInput
    orderBy?: Enumerable<toursOrderByWithRelationInput>
    cursor?: toursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ToursScalarFieldEnum>
  }


  /**
   * cars without action
   */
  export type carsArgs = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
  }



  /**
   * Model city_tours
   */


  export type AggregateCity_tours = {
    _count: City_toursCountAggregateOutputType | null
    _avg: City_toursAvgAggregateOutputType | null
    _sum: City_toursSumAggregateOutputType | null
    _min: City_toursMinAggregateOutputType | null
    _max: City_toursMaxAggregateOutputType | null
  }

  export type City_toursAvgAggregateOutputType = {
    id: number | null
  }

  export type City_toursSumAggregateOutputType = {
    id: number | null
  }

  export type City_toursMinAggregateOutputType = {
    id: number | null
    city_name: string | null
    pick_up_location: string | null
    Created_on: Date | null
  }

  export type City_toursMaxAggregateOutputType = {
    id: number | null
    city_name: string | null
    pick_up_location: string | null
    Created_on: Date | null
  }

  export type City_toursCountAggregateOutputType = {
    id: number
    city_name: number
    pick_up_location: number
    Created_on: number
    _all: number
  }


  export type City_toursAvgAggregateInputType = {
    id?: true
  }

  export type City_toursSumAggregateInputType = {
    id?: true
  }

  export type City_toursMinAggregateInputType = {
    id?: true
    city_name?: true
    pick_up_location?: true
    Created_on?: true
  }

  export type City_toursMaxAggregateInputType = {
    id?: true
    city_name?: true
    pick_up_location?: true
    Created_on?: true
  }

  export type City_toursCountAggregateInputType = {
    id?: true
    city_name?: true
    pick_up_location?: true
    Created_on?: true
    _all?: true
  }

  export type City_toursAggregateArgs = {
    /**
     * Filter which city_tours to aggregate.
     */
    where?: city_toursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of city_tours to fetch.
     */
    orderBy?: Enumerable<city_toursOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: city_toursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` city_tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` city_tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned city_tours
    **/
    _count?: true | City_toursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: City_toursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: City_toursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: City_toursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: City_toursMaxAggregateInputType
  }

  export type GetCity_toursAggregateType<T extends City_toursAggregateArgs> = {
        [P in keyof T & keyof AggregateCity_tours]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity_tours[P]>
      : GetScalarType<T[P], AggregateCity_tours[P]>
  }




  export type City_toursGroupByArgs = {
    where?: city_toursWhereInput
    orderBy?: Enumerable<city_toursOrderByWithAggregationInput>
    by: City_toursScalarFieldEnum[]
    having?: city_toursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: City_toursCountAggregateInputType | true
    _avg?: City_toursAvgAggregateInputType
    _sum?: City_toursSumAggregateInputType
    _min?: City_toursMinAggregateInputType
    _max?: City_toursMaxAggregateInputType
  }


  export type City_toursGroupByOutputType = {
    id: number
    city_name: string
    pick_up_location: string
    Created_on: Date
    _count: City_toursCountAggregateOutputType | null
    _avg: City_toursAvgAggregateOutputType | null
    _sum: City_toursSumAggregateOutputType | null
    _min: City_toursMinAggregateOutputType | null
    _max: City_toursMaxAggregateOutputType | null
  }

  type GetCity_toursGroupByPayload<T extends City_toursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<City_toursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof City_toursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], City_toursGroupByOutputType[P]>
            : GetScalarType<T[P], City_toursGroupByOutputType[P]>
        }
      >
    >


  export type city_toursSelect = {
    id?: boolean
    city_name?: boolean
    pick_up_location?: boolean
    Created_on?: boolean
  }


  export type city_toursGetPayload<S extends boolean | null | undefined | city_toursArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? city_tours :
    S extends undefined ? never :
    S extends { include: any } & (city_toursArgs | city_toursFindManyArgs)
    ? city_tours 
    : S extends { select: any } & (city_toursArgs | city_toursFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof city_tours ? city_tours[P] : never
  } 
      : city_tours


  type city_toursCountArgs = 
    Omit<city_toursFindManyArgs, 'select' | 'include'> & {
      select?: City_toursCountAggregateInputType | true
    }

  export interface city_toursDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one City_tours that matches the filter.
     * @param {city_toursFindUniqueArgs} args - Arguments to find a City_tours
     * @example
     * // Get one City_tours
     * const city_tours = await prisma.city_tours.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends city_toursFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, city_toursFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'city_tours'> extends True ? Prisma__city_toursClient<city_toursGetPayload<T>> : Prisma__city_toursClient<city_toursGetPayload<T> | null, null>

    /**
     * Find one City_tours that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {city_toursFindUniqueOrThrowArgs} args - Arguments to find a City_tours
     * @example
     * // Get one City_tours
     * const city_tours = await prisma.city_tours.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends city_toursFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, city_toursFindUniqueOrThrowArgs>
    ): Prisma__city_toursClient<city_toursGetPayload<T>>

    /**
     * Find the first City_tours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {city_toursFindFirstArgs} args - Arguments to find a City_tours
     * @example
     * // Get one City_tours
     * const city_tours = await prisma.city_tours.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends city_toursFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, city_toursFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'city_tours'> extends True ? Prisma__city_toursClient<city_toursGetPayload<T>> : Prisma__city_toursClient<city_toursGetPayload<T> | null, null>

    /**
     * Find the first City_tours that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {city_toursFindFirstOrThrowArgs} args - Arguments to find a City_tours
     * @example
     * // Get one City_tours
     * const city_tours = await prisma.city_tours.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends city_toursFindFirstOrThrowArgs>(
      args?: SelectSubset<T, city_toursFindFirstOrThrowArgs>
    ): Prisma__city_toursClient<city_toursGetPayload<T>>

    /**
     * Find zero or more City_tours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {city_toursFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all City_tours
     * const city_tours = await prisma.city_tours.findMany()
     * 
     * // Get first 10 City_tours
     * const city_tours = await prisma.city_tours.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const city_toursWithIdOnly = await prisma.city_tours.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends city_toursFindManyArgs>(
      args?: SelectSubset<T, city_toursFindManyArgs>
    ): Prisma.PrismaPromise<Array<city_toursGetPayload<T>>>

    /**
     * Create a City_tours.
     * @param {city_toursCreateArgs} args - Arguments to create a City_tours.
     * @example
     * // Create one City_tours
     * const City_tours = await prisma.city_tours.create({
     *   data: {
     *     // ... data to create a City_tours
     *   }
     * })
     * 
    **/
    create<T extends city_toursCreateArgs>(
      args: SelectSubset<T, city_toursCreateArgs>
    ): Prisma__city_toursClient<city_toursGetPayload<T>>

    /**
     * Create many City_tours.
     *     @param {city_toursCreateManyArgs} args - Arguments to create many City_tours.
     *     @example
     *     // Create many City_tours
     *     const city_tours = await prisma.city_tours.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends city_toursCreateManyArgs>(
      args?: SelectSubset<T, city_toursCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a City_tours.
     * @param {city_toursDeleteArgs} args - Arguments to delete one City_tours.
     * @example
     * // Delete one City_tours
     * const City_tours = await prisma.city_tours.delete({
     *   where: {
     *     // ... filter to delete one City_tours
     *   }
     * })
     * 
    **/
    delete<T extends city_toursDeleteArgs>(
      args: SelectSubset<T, city_toursDeleteArgs>
    ): Prisma__city_toursClient<city_toursGetPayload<T>>

    /**
     * Update one City_tours.
     * @param {city_toursUpdateArgs} args - Arguments to update one City_tours.
     * @example
     * // Update one City_tours
     * const city_tours = await prisma.city_tours.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends city_toursUpdateArgs>(
      args: SelectSubset<T, city_toursUpdateArgs>
    ): Prisma__city_toursClient<city_toursGetPayload<T>>

    /**
     * Delete zero or more City_tours.
     * @param {city_toursDeleteManyArgs} args - Arguments to filter City_tours to delete.
     * @example
     * // Delete a few City_tours
     * const { count } = await prisma.city_tours.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends city_toursDeleteManyArgs>(
      args?: SelectSubset<T, city_toursDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more City_tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {city_toursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many City_tours
     * const city_tours = await prisma.city_tours.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends city_toursUpdateManyArgs>(
      args: SelectSubset<T, city_toursUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City_tours.
     * @param {city_toursUpsertArgs} args - Arguments to update or create a City_tours.
     * @example
     * // Update or create a City_tours
     * const city_tours = await prisma.city_tours.upsert({
     *   create: {
     *     // ... data to create a City_tours
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City_tours we want to update
     *   }
     * })
    **/
    upsert<T extends city_toursUpsertArgs>(
      args: SelectSubset<T, city_toursUpsertArgs>
    ): Prisma__city_toursClient<city_toursGetPayload<T>>

    /**
     * Count the number of City_tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {city_toursCountArgs} args - Arguments to filter City_tours to count.
     * @example
     * // Count the number of City_tours
     * const count = await prisma.city_tours.count({
     *   where: {
     *     // ... the filter for the City_tours we want to count
     *   }
     * })
    **/
    count<T extends city_toursCountArgs>(
      args?: Subset<T, city_toursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], City_toursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City_tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {City_toursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends City_toursAggregateArgs>(args: Subset<T, City_toursAggregateArgs>): Prisma.PrismaPromise<GetCity_toursAggregateType<T>>

    /**
     * Group by City_tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {City_toursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends City_toursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: City_toursGroupByArgs['orderBy'] }
        : { orderBy?: City_toursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, City_toursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCity_toursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for city_tours.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__city_toursClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * city_tours base type for findUnique actions
   */
  export type city_toursFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the city_tours
     */
    select?: city_toursSelect | null
    /**
     * Filter, which city_tours to fetch.
     */
    where: city_toursWhereUniqueInput
  }

  /**
   * city_tours findUnique
   */
  export interface city_toursFindUniqueArgs extends city_toursFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * city_tours findUniqueOrThrow
   */
  export type city_toursFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the city_tours
     */
    select?: city_toursSelect | null
    /**
     * Filter, which city_tours to fetch.
     */
    where: city_toursWhereUniqueInput
  }


  /**
   * city_tours base type for findFirst actions
   */
  export type city_toursFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the city_tours
     */
    select?: city_toursSelect | null
    /**
     * Filter, which city_tours to fetch.
     */
    where?: city_toursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of city_tours to fetch.
     */
    orderBy?: Enumerable<city_toursOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for city_tours.
     */
    cursor?: city_toursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` city_tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` city_tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of city_tours.
     */
    distinct?: Enumerable<City_toursScalarFieldEnum>
  }

  /**
   * city_tours findFirst
   */
  export interface city_toursFindFirstArgs extends city_toursFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * city_tours findFirstOrThrow
   */
  export type city_toursFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the city_tours
     */
    select?: city_toursSelect | null
    /**
     * Filter, which city_tours to fetch.
     */
    where?: city_toursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of city_tours to fetch.
     */
    orderBy?: Enumerable<city_toursOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for city_tours.
     */
    cursor?: city_toursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` city_tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` city_tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of city_tours.
     */
    distinct?: Enumerable<City_toursScalarFieldEnum>
  }


  /**
   * city_tours findMany
   */
  export type city_toursFindManyArgs = {
    /**
     * Select specific fields to fetch from the city_tours
     */
    select?: city_toursSelect | null
    /**
     * Filter, which city_tours to fetch.
     */
    where?: city_toursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of city_tours to fetch.
     */
    orderBy?: Enumerable<city_toursOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing city_tours.
     */
    cursor?: city_toursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` city_tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` city_tours.
     */
    skip?: number
    distinct?: Enumerable<City_toursScalarFieldEnum>
  }


  /**
   * city_tours create
   */
  export type city_toursCreateArgs = {
    /**
     * Select specific fields to fetch from the city_tours
     */
    select?: city_toursSelect | null
    /**
     * The data needed to create a city_tours.
     */
    data: XOR<city_toursCreateInput, city_toursUncheckedCreateInput>
  }


  /**
   * city_tours createMany
   */
  export type city_toursCreateManyArgs = {
    /**
     * The data used to create many city_tours.
     */
    data: Enumerable<city_toursCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * city_tours update
   */
  export type city_toursUpdateArgs = {
    /**
     * Select specific fields to fetch from the city_tours
     */
    select?: city_toursSelect | null
    /**
     * The data needed to update a city_tours.
     */
    data: XOR<city_toursUpdateInput, city_toursUncheckedUpdateInput>
    /**
     * Choose, which city_tours to update.
     */
    where: city_toursWhereUniqueInput
  }


  /**
   * city_tours updateMany
   */
  export type city_toursUpdateManyArgs = {
    /**
     * The data used to update city_tours.
     */
    data: XOR<city_toursUpdateManyMutationInput, city_toursUncheckedUpdateManyInput>
    /**
     * Filter which city_tours to update
     */
    where?: city_toursWhereInput
  }


  /**
   * city_tours upsert
   */
  export type city_toursUpsertArgs = {
    /**
     * Select specific fields to fetch from the city_tours
     */
    select?: city_toursSelect | null
    /**
     * The filter to search for the city_tours to update in case it exists.
     */
    where: city_toursWhereUniqueInput
    /**
     * In case the city_tours found by the `where` argument doesn't exist, create a new city_tours with this data.
     */
    create: XOR<city_toursCreateInput, city_toursUncheckedCreateInput>
    /**
     * In case the city_tours was found with the provided `where` argument, update it with this data.
     */
    update: XOR<city_toursUpdateInput, city_toursUncheckedUpdateInput>
  }


  /**
   * city_tours delete
   */
  export type city_toursDeleteArgs = {
    /**
     * Select specific fields to fetch from the city_tours
     */
    select?: city_toursSelect | null
    /**
     * Filter which city_tours to delete.
     */
    where: city_toursWhereUniqueInput
  }


  /**
   * city_tours deleteMany
   */
  export type city_toursDeleteManyArgs = {
    /**
     * Filter which city_tours to delete
     */
    where?: city_toursWhereInput
  }


  /**
   * city_tours without action
   */
  export type city_toursArgs = {
    /**
     * Select specific fields to fetch from the city_tours
     */
    select?: city_toursSelect | null
  }



  /**
   * Model countries
   */


  export type AggregateCountries = {
    _count: CountriesCountAggregateOutputType | null
    _avg: CountriesAvgAggregateOutputType | null
    _sum: CountriesSumAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  export type CountriesAvgAggregateOutputType = {
    id: number | null
  }

  export type CountriesSumAggregateOutputType = {
    id: number | null
  }

  export type CountriesMinAggregateOutputType = {
    id: number | null
    sortname: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CountriesMaxAggregateOutputType = {
    id: number | null
    sortname: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CountriesCountAggregateOutputType = {
    id: number
    sortname: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CountriesAvgAggregateInputType = {
    id?: true
  }

  export type CountriesSumAggregateInputType = {
    id?: true
  }

  export type CountriesMinAggregateInputType = {
    id?: true
    sortname?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type CountriesMaxAggregateInputType = {
    id?: true
    sortname?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type CountriesCountAggregateInputType = {
    id?: true
    sortname?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CountriesAggregateArgs = {
    /**
     * Filter which countries to aggregate.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: Enumerable<countriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned countries
    **/
    _count?: true | CountriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountriesMaxAggregateInputType
  }

  export type GetCountriesAggregateType<T extends CountriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCountries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountries[P]>
      : GetScalarType<T[P], AggregateCountries[P]>
  }




  export type CountriesGroupByArgs = {
    where?: countriesWhereInput
    orderBy?: Enumerable<countriesOrderByWithAggregationInput>
    by: CountriesScalarFieldEnum[]
    having?: countriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountriesCountAggregateInputType | true
    _avg?: CountriesAvgAggregateInputType
    _sum?: CountriesSumAggregateInputType
    _min?: CountriesMinAggregateInputType
    _max?: CountriesMaxAggregateInputType
  }


  export type CountriesGroupByOutputType = {
    id: number
    sortname: string
    name: string
    created_at: Date | null
    updated_at: Date | null
    _count: CountriesCountAggregateOutputType | null
    _avg: CountriesAvgAggregateOutputType | null
    _sum: CountriesSumAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  type GetCountriesGroupByPayload<T extends CountriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CountriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountriesGroupByOutputType[P]>
            : GetScalarType<T[P], CountriesGroupByOutputType[P]>
        }
      >
    >


  export type countriesSelect = {
    id?: boolean
    sortname?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type countriesGetPayload<S extends boolean | null | undefined | countriesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? countries :
    S extends undefined ? never :
    S extends { include: any } & (countriesArgs | countriesFindManyArgs)
    ? countries 
    : S extends { select: any } & (countriesArgs | countriesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof countries ? countries[P] : never
  } 
      : countries


  type countriesCountArgs = 
    Omit<countriesFindManyArgs, 'select' | 'include'> & {
      select?: CountriesCountAggregateInputType | true
    }

  export interface countriesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Countries that matches the filter.
     * @param {countriesFindUniqueArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends countriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, countriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'countries'> extends True ? Prisma__countriesClient<countriesGetPayload<T>> : Prisma__countriesClient<countriesGetPayload<T> | null, null>

    /**
     * Find one Countries that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {countriesFindUniqueOrThrowArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends countriesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, countriesFindUniqueOrThrowArgs>
    ): Prisma__countriesClient<countriesGetPayload<T>>

    /**
     * Find the first Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindFirstArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends countriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, countriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'countries'> extends True ? Prisma__countriesClient<countriesGetPayload<T>> : Prisma__countriesClient<countriesGetPayload<T> | null, null>

    /**
     * Find the first Countries that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindFirstOrThrowArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends countriesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, countriesFindFirstOrThrowArgs>
    ): Prisma__countriesClient<countriesGetPayload<T>>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.countries.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.countries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countriesWithIdOnly = await prisma.countries.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends countriesFindManyArgs>(
      args?: SelectSubset<T, countriesFindManyArgs>
    ): Prisma.PrismaPromise<Array<countriesGetPayload<T>>>

    /**
     * Create a Countries.
     * @param {countriesCreateArgs} args - Arguments to create a Countries.
     * @example
     * // Create one Countries
     * const Countries = await prisma.countries.create({
     *   data: {
     *     // ... data to create a Countries
     *   }
     * })
     * 
    **/
    create<T extends countriesCreateArgs>(
      args: SelectSubset<T, countriesCreateArgs>
    ): Prisma__countriesClient<countriesGetPayload<T>>

    /**
     * Create many Countries.
     *     @param {countriesCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const countries = await prisma.countries.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends countriesCreateManyArgs>(
      args?: SelectSubset<T, countriesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Countries.
     * @param {countriesDeleteArgs} args - Arguments to delete one Countries.
     * @example
     * // Delete one Countries
     * const Countries = await prisma.countries.delete({
     *   where: {
     *     // ... filter to delete one Countries
     *   }
     * })
     * 
    **/
    delete<T extends countriesDeleteArgs>(
      args: SelectSubset<T, countriesDeleteArgs>
    ): Prisma__countriesClient<countriesGetPayload<T>>

    /**
     * Update one Countries.
     * @param {countriesUpdateArgs} args - Arguments to update one Countries.
     * @example
     * // Update one Countries
     * const countries = await prisma.countries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends countriesUpdateArgs>(
      args: SelectSubset<T, countriesUpdateArgs>
    ): Prisma__countriesClient<countriesGetPayload<T>>

    /**
     * Delete zero or more Countries.
     * @param {countriesDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.countries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends countriesDeleteManyArgs>(
      args?: SelectSubset<T, countriesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const countries = await prisma.countries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends countriesUpdateManyArgs>(
      args: SelectSubset<T, countriesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Countries.
     * @param {countriesUpsertArgs} args - Arguments to update or create a Countries.
     * @example
     * // Update or create a Countries
     * const countries = await prisma.countries.upsert({
     *   create: {
     *     // ... data to create a Countries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Countries we want to update
     *   }
     * })
    **/
    upsert<T extends countriesUpsertArgs>(
      args: SelectSubset<T, countriesUpsertArgs>
    ): Prisma__countriesClient<countriesGetPayload<T>>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.countries.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends countriesCountArgs>(
      args?: Subset<T, countriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountriesAggregateArgs>(args: Subset<T, CountriesAggregateArgs>): Prisma.PrismaPromise<GetCountriesAggregateType<T>>

    /**
     * Group by Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountriesGroupByArgs['orderBy'] }
        : { orderBy?: CountriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for countries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__countriesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * countries base type for findUnique actions
   */
  export type countriesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect | null
    /**
     * Filter, which countries to fetch.
     */
    where: countriesWhereUniqueInput
  }

  /**
   * countries findUnique
   */
  export interface countriesFindUniqueArgs extends countriesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * countries findUniqueOrThrow
   */
  export type countriesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect | null
    /**
     * Filter, which countries to fetch.
     */
    where: countriesWhereUniqueInput
  }


  /**
   * countries base type for findFirst actions
   */
  export type countriesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: Enumerable<countriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     */
    distinct?: Enumerable<CountriesScalarFieldEnum>
  }

  /**
   * countries findFirst
   */
  export interface countriesFindFirstArgs extends countriesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * countries findFirstOrThrow
   */
  export type countriesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: Enumerable<countriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     */
    distinct?: Enumerable<CountriesScalarFieldEnum>
  }


  /**
   * countries findMany
   */
  export type countriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: Enumerable<countriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing countries.
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    distinct?: Enumerable<CountriesScalarFieldEnum>
  }


  /**
   * countries create
   */
  export type countriesCreateArgs = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect | null
    /**
     * The data needed to create a countries.
     */
    data: XOR<countriesCreateInput, countriesUncheckedCreateInput>
  }


  /**
   * countries createMany
   */
  export type countriesCreateManyArgs = {
    /**
     * The data used to create many countries.
     */
    data: Enumerable<countriesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * countries update
   */
  export type countriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect | null
    /**
     * The data needed to update a countries.
     */
    data: XOR<countriesUpdateInput, countriesUncheckedUpdateInput>
    /**
     * Choose, which countries to update.
     */
    where: countriesWhereUniqueInput
  }


  /**
   * countries updateMany
   */
  export type countriesUpdateManyArgs = {
    /**
     * The data used to update countries.
     */
    data: XOR<countriesUpdateManyMutationInput, countriesUncheckedUpdateManyInput>
    /**
     * Filter which countries to update
     */
    where?: countriesWhereInput
  }


  /**
   * countries upsert
   */
  export type countriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect | null
    /**
     * The filter to search for the countries to update in case it exists.
     */
    where: countriesWhereUniqueInput
    /**
     * In case the countries found by the `where` argument doesn't exist, create a new countries with this data.
     */
    create: XOR<countriesCreateInput, countriesUncheckedCreateInput>
    /**
     * In case the countries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<countriesUpdateInput, countriesUncheckedUpdateInput>
  }


  /**
   * countries delete
   */
  export type countriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect | null
    /**
     * Filter which countries to delete.
     */
    where: countriesWhereUniqueInput
  }


  /**
   * countries deleteMany
   */
  export type countriesDeleteManyArgs = {
    /**
     * Filter which countries to delete
     */
    where?: countriesWhereInput
  }


  /**
   * countries without action
   */
  export type countriesArgs = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect | null
  }



  /**
   * Model coupons
   */


  export type AggregateCoupons = {
    _count: CouponsCountAggregateOutputType | null
    _avg: CouponsAvgAggregateOutputType | null
    _sum: CouponsSumAggregateOutputType | null
    _min: CouponsMinAggregateOutputType | null
    _max: CouponsMaxAggregateOutputType | null
  }

  export type CouponsAvgAggregateOutputType = {
    id: number | null
    percentage: number | null
    price: number | null
  }

  export type CouponsSumAggregateOutputType = {
    id: number | null
    percentage: number | null
    price: number | null
  }

  export type CouponsMinAggregateOutputType = {
    id: number | null
    coupon_name: string | null
    percentage: number | null
    price: number | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CouponsMaxAggregateOutputType = {
    id: number | null
    coupon_name: string | null
    percentage: number | null
    price: number | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CouponsCountAggregateOutputType = {
    id: number
    coupon_name: number
    percentage: number
    price: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CouponsAvgAggregateInputType = {
    id?: true
    percentage?: true
    price?: true
  }

  export type CouponsSumAggregateInputType = {
    id?: true
    percentage?: true
    price?: true
  }

  export type CouponsMinAggregateInputType = {
    id?: true
    coupon_name?: true
    percentage?: true
    price?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type CouponsMaxAggregateInputType = {
    id?: true
    coupon_name?: true
    percentage?: true
    price?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type CouponsCountAggregateInputType = {
    id?: true
    coupon_name?: true
    percentage?: true
    price?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CouponsAggregateArgs = {
    /**
     * Filter which coupons to aggregate.
     */
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: Enumerable<couponsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned coupons
    **/
    _count?: true | CouponsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponsMaxAggregateInputType
  }

  export type GetCouponsAggregateType<T extends CouponsAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupons[P]>
      : GetScalarType<T[P], AggregateCoupons[P]>
  }




  export type CouponsGroupByArgs = {
    where?: couponsWhereInput
    orderBy?: Enumerable<couponsOrderByWithAggregationInput>
    by: CouponsScalarFieldEnum[]
    having?: couponsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponsCountAggregateInputType | true
    _avg?: CouponsAvgAggregateInputType
    _sum?: CouponsSumAggregateInputType
    _min?: CouponsMinAggregateInputType
    _max?: CouponsMaxAggregateInputType
  }


  export type CouponsGroupByOutputType = {
    id: number
    coupon_name: string | null
    percentage: number | null
    price: number | null
    status: boolean
    created_at: Date | null
    updated_at: Date | null
    _count: CouponsCountAggregateOutputType | null
    _avg: CouponsAvgAggregateOutputType | null
    _sum: CouponsSumAggregateOutputType | null
    _min: CouponsMinAggregateOutputType | null
    _max: CouponsMaxAggregateOutputType | null
  }

  type GetCouponsGroupByPayload<T extends CouponsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CouponsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponsGroupByOutputType[P]>
            : GetScalarType<T[P], CouponsGroupByOutputType[P]>
        }
      >
    >


  export type couponsSelect = {
    id?: boolean
    coupon_name?: boolean
    percentage?: boolean
    price?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type couponsGetPayload<S extends boolean | null | undefined | couponsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? coupons :
    S extends undefined ? never :
    S extends { include: any } & (couponsArgs | couponsFindManyArgs)
    ? coupons 
    : S extends { select: any } & (couponsArgs | couponsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof coupons ? coupons[P] : never
  } 
      : coupons


  type couponsCountArgs = 
    Omit<couponsFindManyArgs, 'select' | 'include'> & {
      select?: CouponsCountAggregateInputType | true
    }

  export interface couponsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Coupons that matches the filter.
     * @param {couponsFindUniqueArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends couponsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, couponsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'coupons'> extends True ? Prisma__couponsClient<couponsGetPayload<T>> : Prisma__couponsClient<couponsGetPayload<T> | null, null>

    /**
     * Find one Coupons that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {couponsFindUniqueOrThrowArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends couponsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, couponsFindUniqueOrThrowArgs>
    ): Prisma__couponsClient<couponsGetPayload<T>>

    /**
     * Find the first Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsFindFirstArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends couponsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, couponsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'coupons'> extends True ? Prisma__couponsClient<couponsGetPayload<T>> : Prisma__couponsClient<couponsGetPayload<T> | null, null>

    /**
     * Find the first Coupons that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsFindFirstOrThrowArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends couponsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, couponsFindFirstOrThrowArgs>
    ): Prisma__couponsClient<couponsGetPayload<T>>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupons.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponsWithIdOnly = await prisma.coupons.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends couponsFindManyArgs>(
      args?: SelectSubset<T, couponsFindManyArgs>
    ): Prisma.PrismaPromise<Array<couponsGetPayload<T>>>

    /**
     * Create a Coupons.
     * @param {couponsCreateArgs} args - Arguments to create a Coupons.
     * @example
     * // Create one Coupons
     * const Coupons = await prisma.coupons.create({
     *   data: {
     *     // ... data to create a Coupons
     *   }
     * })
     * 
    **/
    create<T extends couponsCreateArgs>(
      args: SelectSubset<T, couponsCreateArgs>
    ): Prisma__couponsClient<couponsGetPayload<T>>

    /**
     * Create many Coupons.
     *     @param {couponsCreateManyArgs} args - Arguments to create many Coupons.
     *     @example
     *     // Create many Coupons
     *     const coupons = await prisma.coupons.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends couponsCreateManyArgs>(
      args?: SelectSubset<T, couponsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Coupons.
     * @param {couponsDeleteArgs} args - Arguments to delete one Coupons.
     * @example
     * // Delete one Coupons
     * const Coupons = await prisma.coupons.delete({
     *   where: {
     *     // ... filter to delete one Coupons
     *   }
     * })
     * 
    **/
    delete<T extends couponsDeleteArgs>(
      args: SelectSubset<T, couponsDeleteArgs>
    ): Prisma__couponsClient<couponsGetPayload<T>>

    /**
     * Update one Coupons.
     * @param {couponsUpdateArgs} args - Arguments to update one Coupons.
     * @example
     * // Update one Coupons
     * const coupons = await prisma.coupons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends couponsUpdateArgs>(
      args: SelectSubset<T, couponsUpdateArgs>
    ): Prisma__couponsClient<couponsGetPayload<T>>

    /**
     * Delete zero or more Coupons.
     * @param {couponsDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends couponsDeleteManyArgs>(
      args?: SelectSubset<T, couponsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupons = await prisma.coupons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends couponsUpdateManyArgs>(
      args: SelectSubset<T, couponsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Coupons.
     * @param {couponsUpsertArgs} args - Arguments to update or create a Coupons.
     * @example
     * // Update or create a Coupons
     * const coupons = await prisma.coupons.upsert({
     *   create: {
     *     // ... data to create a Coupons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupons we want to update
     *   }
     * })
    **/
    upsert<T extends couponsUpsertArgs>(
      args: SelectSubset<T, couponsUpsertArgs>
    ): Prisma__couponsClient<couponsGetPayload<T>>

    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupons.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends couponsCountArgs>(
      args?: Subset<T, couponsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponsAggregateArgs>(args: Subset<T, CouponsAggregateArgs>): Prisma.PrismaPromise<GetCouponsAggregateType<T>>

    /**
     * Group by Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponsGroupByArgs['orderBy'] }
        : { orderBy?: CouponsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for coupons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__couponsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * coupons base type for findUnique actions
   */
  export type couponsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect | null
    /**
     * Filter, which coupons to fetch.
     */
    where: couponsWhereUniqueInput
  }

  /**
   * coupons findUnique
   */
  export interface couponsFindUniqueArgs extends couponsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * coupons findUniqueOrThrow
   */
  export type couponsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect | null
    /**
     * Filter, which coupons to fetch.
     */
    where: couponsWhereUniqueInput
  }


  /**
   * coupons base type for findFirst actions
   */
  export type couponsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect | null
    /**
     * Filter, which coupons to fetch.
     */
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: Enumerable<couponsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coupons.
     */
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coupons.
     */
    distinct?: Enumerable<CouponsScalarFieldEnum>
  }

  /**
   * coupons findFirst
   */
  export interface couponsFindFirstArgs extends couponsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * coupons findFirstOrThrow
   */
  export type couponsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect | null
    /**
     * Filter, which coupons to fetch.
     */
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: Enumerable<couponsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coupons.
     */
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coupons.
     */
    distinct?: Enumerable<CouponsScalarFieldEnum>
  }


  /**
   * coupons findMany
   */
  export type couponsFindManyArgs = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect | null
    /**
     * Filter, which coupons to fetch.
     */
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: Enumerable<couponsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing coupons.
     */
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    distinct?: Enumerable<CouponsScalarFieldEnum>
  }


  /**
   * coupons create
   */
  export type couponsCreateArgs = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect | null
    /**
     * The data needed to create a coupons.
     */
    data: XOR<couponsCreateInput, couponsUncheckedCreateInput>
  }


  /**
   * coupons createMany
   */
  export type couponsCreateManyArgs = {
    /**
     * The data used to create many coupons.
     */
    data: Enumerable<couponsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * coupons update
   */
  export type couponsUpdateArgs = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect | null
    /**
     * The data needed to update a coupons.
     */
    data: XOR<couponsUpdateInput, couponsUncheckedUpdateInput>
    /**
     * Choose, which coupons to update.
     */
    where: couponsWhereUniqueInput
  }


  /**
   * coupons updateMany
   */
  export type couponsUpdateManyArgs = {
    /**
     * The data used to update coupons.
     */
    data: XOR<couponsUpdateManyMutationInput, couponsUncheckedUpdateManyInput>
    /**
     * Filter which coupons to update
     */
    where?: couponsWhereInput
  }


  /**
   * coupons upsert
   */
  export type couponsUpsertArgs = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect | null
    /**
     * The filter to search for the coupons to update in case it exists.
     */
    where: couponsWhereUniqueInput
    /**
     * In case the coupons found by the `where` argument doesn't exist, create a new coupons with this data.
     */
    create: XOR<couponsCreateInput, couponsUncheckedCreateInput>
    /**
     * In case the coupons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<couponsUpdateInput, couponsUncheckedUpdateInput>
  }


  /**
   * coupons delete
   */
  export type couponsDeleteArgs = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect | null
    /**
     * Filter which coupons to delete.
     */
    where: couponsWhereUniqueInput
  }


  /**
   * coupons deleteMany
   */
  export type couponsDeleteManyArgs = {
    /**
     * Filter which coupons to delete
     */
    where?: couponsWhereInput
  }


  /**
   * coupons without action
   */
  export type couponsArgs = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect | null
  }



  /**
   * Model datatables
   */


  export type AggregateDatatables = {
    _count: DatatablesCountAggregateOutputType | null
    _avg: DatatablesAvgAggregateOutputType | null
    _sum: DatatablesSumAggregateOutputType | null
    _min: DatatablesMinAggregateOutputType | null
    _max: DatatablesMaxAggregateOutputType | null
  }

  export type DatatablesAvgAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type DatatablesSumAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type DatatablesMinAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    points: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
    age: number | null
    job: string | null
    gender: string | null
    country: string | null
    sale_date: string | null
  }

  export type DatatablesMaxAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    points: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
    age: number | null
    job: string | null
    gender: string | null
    country: string | null
    sale_date: string | null
  }

  export type DatatablesCountAggregateOutputType = {
    id: number
    firstname: number
    lastname: number
    email: number
    points: number
    notes: number
    created_at: number
    updated_at: number
    age: number
    job: number
    gender: number
    country: number
    sale_date: number
    _all: number
  }


  export type DatatablesAvgAggregateInputType = {
    id?: true
    age?: true
  }

  export type DatatablesSumAggregateInputType = {
    id?: true
    age?: true
  }

  export type DatatablesMinAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    points?: true
    notes?: true
    created_at?: true
    updated_at?: true
    age?: true
    job?: true
    gender?: true
    country?: true
    sale_date?: true
  }

  export type DatatablesMaxAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    points?: true
    notes?: true
    created_at?: true
    updated_at?: true
    age?: true
    job?: true
    gender?: true
    country?: true
    sale_date?: true
  }

  export type DatatablesCountAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    points?: true
    notes?: true
    created_at?: true
    updated_at?: true
    age?: true
    job?: true
    gender?: true
    country?: true
    sale_date?: true
    _all?: true
  }

  export type DatatablesAggregateArgs = {
    /**
     * Filter which datatables to aggregate.
     */
    where?: datatablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datatables to fetch.
     */
    orderBy?: Enumerable<datatablesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: datatablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datatables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datatables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned datatables
    **/
    _count?: true | DatatablesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DatatablesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DatatablesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatatablesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatatablesMaxAggregateInputType
  }

  export type GetDatatablesAggregateType<T extends DatatablesAggregateArgs> = {
        [P in keyof T & keyof AggregateDatatables]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatatables[P]>
      : GetScalarType<T[P], AggregateDatatables[P]>
  }




  export type DatatablesGroupByArgs = {
    where?: datatablesWhereInput
    orderBy?: Enumerable<datatablesOrderByWithAggregationInput>
    by: DatatablesScalarFieldEnum[]
    having?: datatablesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatatablesCountAggregateInputType | true
    _avg?: DatatablesAvgAggregateInputType
    _sum?: DatatablesSumAggregateInputType
    _min?: DatatablesMinAggregateInputType
    _max?: DatatablesMaxAggregateInputType
  }


  export type DatatablesGroupByOutputType = {
    id: number
    firstname: string | null
    lastname: string | null
    email: string | null
    points: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
    age: number | null
    job: string | null
    gender: string | null
    country: string | null
    sale_date: string | null
    _count: DatatablesCountAggregateOutputType | null
    _avg: DatatablesAvgAggregateOutputType | null
    _sum: DatatablesSumAggregateOutputType | null
    _min: DatatablesMinAggregateOutputType | null
    _max: DatatablesMaxAggregateOutputType | null
  }

  type GetDatatablesGroupByPayload<T extends DatatablesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DatatablesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatatablesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatatablesGroupByOutputType[P]>
            : GetScalarType<T[P], DatatablesGroupByOutputType[P]>
        }
      >
    >


  export type datatablesSelect = {
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    points?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    age?: boolean
    job?: boolean
    gender?: boolean
    country?: boolean
    sale_date?: boolean
  }


  export type datatablesGetPayload<S extends boolean | null | undefined | datatablesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? datatables :
    S extends undefined ? never :
    S extends { include: any } & (datatablesArgs | datatablesFindManyArgs)
    ? datatables 
    : S extends { select: any } & (datatablesArgs | datatablesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof datatables ? datatables[P] : never
  } 
      : datatables


  type datatablesCountArgs = 
    Omit<datatablesFindManyArgs, 'select' | 'include'> & {
      select?: DatatablesCountAggregateInputType | true
    }

  export interface datatablesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Datatables that matches the filter.
     * @param {datatablesFindUniqueArgs} args - Arguments to find a Datatables
     * @example
     * // Get one Datatables
     * const datatables = await prisma.datatables.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends datatablesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, datatablesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'datatables'> extends True ? Prisma__datatablesClient<datatablesGetPayload<T>> : Prisma__datatablesClient<datatablesGetPayload<T> | null, null>

    /**
     * Find one Datatables that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {datatablesFindUniqueOrThrowArgs} args - Arguments to find a Datatables
     * @example
     * // Get one Datatables
     * const datatables = await prisma.datatables.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends datatablesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, datatablesFindUniqueOrThrowArgs>
    ): Prisma__datatablesClient<datatablesGetPayload<T>>

    /**
     * Find the first Datatables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datatablesFindFirstArgs} args - Arguments to find a Datatables
     * @example
     * // Get one Datatables
     * const datatables = await prisma.datatables.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends datatablesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, datatablesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'datatables'> extends True ? Prisma__datatablesClient<datatablesGetPayload<T>> : Prisma__datatablesClient<datatablesGetPayload<T> | null, null>

    /**
     * Find the first Datatables that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datatablesFindFirstOrThrowArgs} args - Arguments to find a Datatables
     * @example
     * // Get one Datatables
     * const datatables = await prisma.datatables.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends datatablesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, datatablesFindFirstOrThrowArgs>
    ): Prisma__datatablesClient<datatablesGetPayload<T>>

    /**
     * Find zero or more Datatables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datatablesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Datatables
     * const datatables = await prisma.datatables.findMany()
     * 
     * // Get first 10 Datatables
     * const datatables = await prisma.datatables.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const datatablesWithIdOnly = await prisma.datatables.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends datatablesFindManyArgs>(
      args?: SelectSubset<T, datatablesFindManyArgs>
    ): Prisma.PrismaPromise<Array<datatablesGetPayload<T>>>

    /**
     * Create a Datatables.
     * @param {datatablesCreateArgs} args - Arguments to create a Datatables.
     * @example
     * // Create one Datatables
     * const Datatables = await prisma.datatables.create({
     *   data: {
     *     // ... data to create a Datatables
     *   }
     * })
     * 
    **/
    create<T extends datatablesCreateArgs>(
      args: SelectSubset<T, datatablesCreateArgs>
    ): Prisma__datatablesClient<datatablesGetPayload<T>>

    /**
     * Create many Datatables.
     *     @param {datatablesCreateManyArgs} args - Arguments to create many Datatables.
     *     @example
     *     // Create many Datatables
     *     const datatables = await prisma.datatables.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends datatablesCreateManyArgs>(
      args?: SelectSubset<T, datatablesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Datatables.
     * @param {datatablesDeleteArgs} args - Arguments to delete one Datatables.
     * @example
     * // Delete one Datatables
     * const Datatables = await prisma.datatables.delete({
     *   where: {
     *     // ... filter to delete one Datatables
     *   }
     * })
     * 
    **/
    delete<T extends datatablesDeleteArgs>(
      args: SelectSubset<T, datatablesDeleteArgs>
    ): Prisma__datatablesClient<datatablesGetPayload<T>>

    /**
     * Update one Datatables.
     * @param {datatablesUpdateArgs} args - Arguments to update one Datatables.
     * @example
     * // Update one Datatables
     * const datatables = await prisma.datatables.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends datatablesUpdateArgs>(
      args: SelectSubset<T, datatablesUpdateArgs>
    ): Prisma__datatablesClient<datatablesGetPayload<T>>

    /**
     * Delete zero or more Datatables.
     * @param {datatablesDeleteManyArgs} args - Arguments to filter Datatables to delete.
     * @example
     * // Delete a few Datatables
     * const { count } = await prisma.datatables.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends datatablesDeleteManyArgs>(
      args?: SelectSubset<T, datatablesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Datatables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datatablesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Datatables
     * const datatables = await prisma.datatables.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends datatablesUpdateManyArgs>(
      args: SelectSubset<T, datatablesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Datatables.
     * @param {datatablesUpsertArgs} args - Arguments to update or create a Datatables.
     * @example
     * // Update or create a Datatables
     * const datatables = await prisma.datatables.upsert({
     *   create: {
     *     // ... data to create a Datatables
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Datatables we want to update
     *   }
     * })
    **/
    upsert<T extends datatablesUpsertArgs>(
      args: SelectSubset<T, datatablesUpsertArgs>
    ): Prisma__datatablesClient<datatablesGetPayload<T>>

    /**
     * Count the number of Datatables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datatablesCountArgs} args - Arguments to filter Datatables to count.
     * @example
     * // Count the number of Datatables
     * const count = await prisma.datatables.count({
     *   where: {
     *     // ... the filter for the Datatables we want to count
     *   }
     * })
    **/
    count<T extends datatablesCountArgs>(
      args?: Subset<T, datatablesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatatablesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Datatables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatatablesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatatablesAggregateArgs>(args: Subset<T, DatatablesAggregateArgs>): Prisma.PrismaPromise<GetDatatablesAggregateType<T>>

    /**
     * Group by Datatables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatatablesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatatablesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatatablesGroupByArgs['orderBy'] }
        : { orderBy?: DatatablesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatatablesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatatablesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for datatables.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__datatablesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * datatables base type for findUnique actions
   */
  export type datatablesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the datatables
     */
    select?: datatablesSelect | null
    /**
     * Filter, which datatables to fetch.
     */
    where: datatablesWhereUniqueInput
  }

  /**
   * datatables findUnique
   */
  export interface datatablesFindUniqueArgs extends datatablesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * datatables findUniqueOrThrow
   */
  export type datatablesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the datatables
     */
    select?: datatablesSelect | null
    /**
     * Filter, which datatables to fetch.
     */
    where: datatablesWhereUniqueInput
  }


  /**
   * datatables base type for findFirst actions
   */
  export type datatablesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the datatables
     */
    select?: datatablesSelect | null
    /**
     * Filter, which datatables to fetch.
     */
    where?: datatablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datatables to fetch.
     */
    orderBy?: Enumerable<datatablesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for datatables.
     */
    cursor?: datatablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datatables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datatables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of datatables.
     */
    distinct?: Enumerable<DatatablesScalarFieldEnum>
  }

  /**
   * datatables findFirst
   */
  export interface datatablesFindFirstArgs extends datatablesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * datatables findFirstOrThrow
   */
  export type datatablesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the datatables
     */
    select?: datatablesSelect | null
    /**
     * Filter, which datatables to fetch.
     */
    where?: datatablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datatables to fetch.
     */
    orderBy?: Enumerable<datatablesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for datatables.
     */
    cursor?: datatablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datatables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datatables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of datatables.
     */
    distinct?: Enumerable<DatatablesScalarFieldEnum>
  }


  /**
   * datatables findMany
   */
  export type datatablesFindManyArgs = {
    /**
     * Select specific fields to fetch from the datatables
     */
    select?: datatablesSelect | null
    /**
     * Filter, which datatables to fetch.
     */
    where?: datatablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datatables to fetch.
     */
    orderBy?: Enumerable<datatablesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing datatables.
     */
    cursor?: datatablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datatables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datatables.
     */
    skip?: number
    distinct?: Enumerable<DatatablesScalarFieldEnum>
  }


  /**
   * datatables create
   */
  export type datatablesCreateArgs = {
    /**
     * Select specific fields to fetch from the datatables
     */
    select?: datatablesSelect | null
    /**
     * The data needed to create a datatables.
     */
    data: XOR<datatablesCreateInput, datatablesUncheckedCreateInput>
  }


  /**
   * datatables createMany
   */
  export type datatablesCreateManyArgs = {
    /**
     * The data used to create many datatables.
     */
    data: Enumerable<datatablesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * datatables update
   */
  export type datatablesUpdateArgs = {
    /**
     * Select specific fields to fetch from the datatables
     */
    select?: datatablesSelect | null
    /**
     * The data needed to update a datatables.
     */
    data: XOR<datatablesUpdateInput, datatablesUncheckedUpdateInput>
    /**
     * Choose, which datatables to update.
     */
    where: datatablesWhereUniqueInput
  }


  /**
   * datatables updateMany
   */
  export type datatablesUpdateManyArgs = {
    /**
     * The data used to update datatables.
     */
    data: XOR<datatablesUpdateManyMutationInput, datatablesUncheckedUpdateManyInput>
    /**
     * Filter which datatables to update
     */
    where?: datatablesWhereInput
  }


  /**
   * datatables upsert
   */
  export type datatablesUpsertArgs = {
    /**
     * Select specific fields to fetch from the datatables
     */
    select?: datatablesSelect | null
    /**
     * The filter to search for the datatables to update in case it exists.
     */
    where: datatablesWhereUniqueInput
    /**
     * In case the datatables found by the `where` argument doesn't exist, create a new datatables with this data.
     */
    create: XOR<datatablesCreateInput, datatablesUncheckedCreateInput>
    /**
     * In case the datatables was found with the provided `where` argument, update it with this data.
     */
    update: XOR<datatablesUpdateInput, datatablesUncheckedUpdateInput>
  }


  /**
   * datatables delete
   */
  export type datatablesDeleteArgs = {
    /**
     * Select specific fields to fetch from the datatables
     */
    select?: datatablesSelect | null
    /**
     * Filter which datatables to delete.
     */
    where: datatablesWhereUniqueInput
  }


  /**
   * datatables deleteMany
   */
  export type datatablesDeleteManyArgs = {
    /**
     * Filter which datatables to delete
     */
    where?: datatablesWhereInput
  }


  /**
   * datatables without action
   */
  export type datatablesArgs = {
    /**
     * Select specific fields to fetch from the datatables
     */
    select?: datatablesSelect | null
  }



  /**
   * Model drivers
   */


  export type AggregateDrivers = {
    _count: DriversCountAggregateOutputType | null
    _avg: DriversAvgAggregateOutputType | null
    _sum: DriversSumAggregateOutputType | null
    _min: DriversMinAggregateOutputType | null
    _max: DriversMaxAggregateOutputType | null
  }

  export type DriversAvgAggregateOutputType = {
    id: number | null
  }

  export type DriversSumAggregateOutputType = {
    id: number | null
  }

  export type DriversMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DriversMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DriversCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DriversAvgAggregateInputType = {
    id?: true
  }

  export type DriversSumAggregateInputType = {
    id?: true
  }

  export type DriversMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type DriversMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type DriversCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DriversAggregateArgs = {
    /**
     * Filter which drivers to aggregate.
     */
    where?: driversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivers to fetch.
     */
    orderBy?: Enumerable<driversOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: driversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned drivers
    **/
    _count?: true | DriversCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriversAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriversSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriversMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriversMaxAggregateInputType
  }

  export type GetDriversAggregateType<T extends DriversAggregateArgs> = {
        [P in keyof T & keyof AggregateDrivers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrivers[P]>
      : GetScalarType<T[P], AggregateDrivers[P]>
  }




  export type DriversGroupByArgs = {
    where?: driversWhereInput
    orderBy?: Enumerable<driversOrderByWithAggregationInput>
    by: DriversScalarFieldEnum[]
    having?: driversScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriversCountAggregateInputType | true
    _avg?: DriversAvgAggregateInputType
    _sum?: DriversSumAggregateInputType
    _min?: DriversMinAggregateInputType
    _max?: DriversMaxAggregateInputType
  }


  export type DriversGroupByOutputType = {
    id: number
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: DriversCountAggregateOutputType | null
    _avg: DriversAvgAggregateOutputType | null
    _sum: DriversSumAggregateOutputType | null
    _min: DriversMinAggregateOutputType | null
    _max: DriversMaxAggregateOutputType | null
  }

  type GetDriversGroupByPayload<T extends DriversGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DriversGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriversGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriversGroupByOutputType[P]>
            : GetScalarType<T[P], DriversGroupByOutputType[P]>
        }
      >
    >


  export type driversSelect = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    cars?: boolean | drivers$carsArgs
    _count?: boolean | DriversCountOutputTypeArgs
  }


  export type driversInclude = {
    cars?: boolean | drivers$carsArgs
    _count?: boolean | DriversCountOutputTypeArgs
  }

  export type driversGetPayload<S extends boolean | null | undefined | driversArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? drivers :
    S extends undefined ? never :
    S extends { include: any } & (driversArgs | driversFindManyArgs)
    ? drivers  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'cars' ? Array < carsGetPayload<S['include'][P]>>  :
        P extends '_count' ? DriversCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (driversArgs | driversFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'cars' ? Array < carsGetPayload<S['select'][P]>>  :
        P extends '_count' ? DriversCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof drivers ? drivers[P] : never
  } 
      : drivers


  type driversCountArgs = 
    Omit<driversFindManyArgs, 'select' | 'include'> & {
      select?: DriversCountAggregateInputType | true
    }

  export interface driversDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Drivers that matches the filter.
     * @param {driversFindUniqueArgs} args - Arguments to find a Drivers
     * @example
     * // Get one Drivers
     * const drivers = await prisma.drivers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends driversFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, driversFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'drivers'> extends True ? Prisma__driversClient<driversGetPayload<T>> : Prisma__driversClient<driversGetPayload<T> | null, null>

    /**
     * Find one Drivers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {driversFindUniqueOrThrowArgs} args - Arguments to find a Drivers
     * @example
     * // Get one Drivers
     * const drivers = await prisma.drivers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends driversFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, driversFindUniqueOrThrowArgs>
    ): Prisma__driversClient<driversGetPayload<T>>

    /**
     * Find the first Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driversFindFirstArgs} args - Arguments to find a Drivers
     * @example
     * // Get one Drivers
     * const drivers = await prisma.drivers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends driversFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, driversFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'drivers'> extends True ? Prisma__driversClient<driversGetPayload<T>> : Prisma__driversClient<driversGetPayload<T> | null, null>

    /**
     * Find the first Drivers that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driversFindFirstOrThrowArgs} args - Arguments to find a Drivers
     * @example
     * // Get one Drivers
     * const drivers = await prisma.drivers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends driversFindFirstOrThrowArgs>(
      args?: SelectSubset<T, driversFindFirstOrThrowArgs>
    ): Prisma__driversClient<driversGetPayload<T>>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driversFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.drivers.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.drivers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driversWithIdOnly = await prisma.drivers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends driversFindManyArgs>(
      args?: SelectSubset<T, driversFindManyArgs>
    ): Prisma.PrismaPromise<Array<driversGetPayload<T>>>

    /**
     * Create a Drivers.
     * @param {driversCreateArgs} args - Arguments to create a Drivers.
     * @example
     * // Create one Drivers
     * const Drivers = await prisma.drivers.create({
     *   data: {
     *     // ... data to create a Drivers
     *   }
     * })
     * 
    **/
    create<T extends driversCreateArgs>(
      args: SelectSubset<T, driversCreateArgs>
    ): Prisma__driversClient<driversGetPayload<T>>

    /**
     * Create many Drivers.
     *     @param {driversCreateManyArgs} args - Arguments to create many Drivers.
     *     @example
     *     // Create many Drivers
     *     const drivers = await prisma.drivers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends driversCreateManyArgs>(
      args?: SelectSubset<T, driversCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Drivers.
     * @param {driversDeleteArgs} args - Arguments to delete one Drivers.
     * @example
     * // Delete one Drivers
     * const Drivers = await prisma.drivers.delete({
     *   where: {
     *     // ... filter to delete one Drivers
     *   }
     * })
     * 
    **/
    delete<T extends driversDeleteArgs>(
      args: SelectSubset<T, driversDeleteArgs>
    ): Prisma__driversClient<driversGetPayload<T>>

    /**
     * Update one Drivers.
     * @param {driversUpdateArgs} args - Arguments to update one Drivers.
     * @example
     * // Update one Drivers
     * const drivers = await prisma.drivers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends driversUpdateArgs>(
      args: SelectSubset<T, driversUpdateArgs>
    ): Prisma__driversClient<driversGetPayload<T>>

    /**
     * Delete zero or more Drivers.
     * @param {driversDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.drivers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends driversDeleteManyArgs>(
      args?: SelectSubset<T, driversDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driversUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const drivers = await prisma.drivers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends driversUpdateManyArgs>(
      args: SelectSubset<T, driversUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Drivers.
     * @param {driversUpsertArgs} args - Arguments to update or create a Drivers.
     * @example
     * // Update or create a Drivers
     * const drivers = await prisma.drivers.upsert({
     *   create: {
     *     // ... data to create a Drivers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drivers we want to update
     *   }
     * })
    **/
    upsert<T extends driversUpsertArgs>(
      args: SelectSubset<T, driversUpsertArgs>
    ): Prisma__driversClient<driversGetPayload<T>>

    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driversCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.drivers.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends driversCountArgs>(
      args?: Subset<T, driversCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriversCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriversAggregateArgs>(args: Subset<T, DriversAggregateArgs>): Prisma.PrismaPromise<GetDriversAggregateType<T>>

    /**
     * Group by Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriversGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriversGroupByArgs['orderBy'] }
        : { orderBy?: DriversGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriversGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriversGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for drivers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__driversClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cars<T extends drivers$carsArgs= {}>(args?: Subset<T, drivers$carsArgs>): Prisma.PrismaPromise<Array<carsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * drivers base type for findUnique actions
   */
  export type driversFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the drivers
     */
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driversInclude | null
    /**
     * Filter, which drivers to fetch.
     */
    where: driversWhereUniqueInput
  }

  /**
   * drivers findUnique
   */
  export interface driversFindUniqueArgs extends driversFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * drivers findUniqueOrThrow
   */
  export type driversFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the drivers
     */
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driversInclude | null
    /**
     * Filter, which drivers to fetch.
     */
    where: driversWhereUniqueInput
  }


  /**
   * drivers base type for findFirst actions
   */
  export type driversFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the drivers
     */
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driversInclude | null
    /**
     * Filter, which drivers to fetch.
     */
    where?: driversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivers to fetch.
     */
    orderBy?: Enumerable<driversOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drivers.
     */
    cursor?: driversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drivers.
     */
    distinct?: Enumerable<DriversScalarFieldEnum>
  }

  /**
   * drivers findFirst
   */
  export interface driversFindFirstArgs extends driversFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * drivers findFirstOrThrow
   */
  export type driversFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the drivers
     */
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driversInclude | null
    /**
     * Filter, which drivers to fetch.
     */
    where?: driversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivers to fetch.
     */
    orderBy?: Enumerable<driversOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drivers.
     */
    cursor?: driversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drivers.
     */
    distinct?: Enumerable<DriversScalarFieldEnum>
  }


  /**
   * drivers findMany
   */
  export type driversFindManyArgs = {
    /**
     * Select specific fields to fetch from the drivers
     */
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driversInclude | null
    /**
     * Filter, which drivers to fetch.
     */
    where?: driversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivers to fetch.
     */
    orderBy?: Enumerable<driversOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing drivers.
     */
    cursor?: driversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
     */
    skip?: number
    distinct?: Enumerable<DriversScalarFieldEnum>
  }


  /**
   * drivers create
   */
  export type driversCreateArgs = {
    /**
     * Select specific fields to fetch from the drivers
     */
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driversInclude | null
    /**
     * The data needed to create a drivers.
     */
    data: XOR<driversCreateInput, driversUncheckedCreateInput>
  }


  /**
   * drivers createMany
   */
  export type driversCreateManyArgs = {
    /**
     * The data used to create many drivers.
     */
    data: Enumerable<driversCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * drivers update
   */
  export type driversUpdateArgs = {
    /**
     * Select specific fields to fetch from the drivers
     */
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driversInclude | null
    /**
     * The data needed to update a drivers.
     */
    data: XOR<driversUpdateInput, driversUncheckedUpdateInput>
    /**
     * Choose, which drivers to update.
     */
    where: driversWhereUniqueInput
  }


  /**
   * drivers updateMany
   */
  export type driversUpdateManyArgs = {
    /**
     * The data used to update drivers.
     */
    data: XOR<driversUpdateManyMutationInput, driversUncheckedUpdateManyInput>
    /**
     * Filter which drivers to update
     */
    where?: driversWhereInput
  }


  /**
   * drivers upsert
   */
  export type driversUpsertArgs = {
    /**
     * Select specific fields to fetch from the drivers
     */
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driversInclude | null
    /**
     * The filter to search for the drivers to update in case it exists.
     */
    where: driversWhereUniqueInput
    /**
     * In case the drivers found by the `where` argument doesn't exist, create a new drivers with this data.
     */
    create: XOR<driversCreateInput, driversUncheckedCreateInput>
    /**
     * In case the drivers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<driversUpdateInput, driversUncheckedUpdateInput>
  }


  /**
   * drivers delete
   */
  export type driversDeleteArgs = {
    /**
     * Select specific fields to fetch from the drivers
     */
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driversInclude | null
    /**
     * Filter which drivers to delete.
     */
    where: driversWhereUniqueInput
  }


  /**
   * drivers deleteMany
   */
  export type driversDeleteManyArgs = {
    /**
     * Filter which drivers to delete
     */
    where?: driversWhereInput
  }


  /**
   * drivers.cars
   */
  export type drivers$carsArgs = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    where?: carsWhereInput
    orderBy?: Enumerable<carsOrderByWithRelationInput>
    cursor?: carsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CarsScalarFieldEnum>
  }


  /**
   * drivers without action
   */
  export type driversArgs = {
    /**
     * Select specific fields to fetch from the drivers
     */
    select?: driversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driversInclude | null
  }



  /**
   * Model features
   */


  export type AggregateFeatures = {
    _count: FeaturesCountAggregateOutputType | null
    _avg: FeaturesAvgAggregateOutputType | null
    _sum: FeaturesSumAggregateOutputType | null
    _min: FeaturesMinAggregateOutputType | null
    _max: FeaturesMaxAggregateOutputType | null
  }

  export type FeaturesAvgAggregateOutputType = {
    id: number | null
  }

  export type FeaturesSumAggregateOutputType = {
    id: number | null
  }

  export type FeaturesMinAggregateOutputType = {
    id: number | null
    feature: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FeaturesMaxAggregateOutputType = {
    id: number | null
    feature: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FeaturesCountAggregateOutputType = {
    id: number
    feature: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type FeaturesAvgAggregateInputType = {
    id?: true
  }

  export type FeaturesSumAggregateInputType = {
    id?: true
  }

  export type FeaturesMinAggregateInputType = {
    id?: true
    feature?: true
    created_at?: true
    updated_at?: true
  }

  export type FeaturesMaxAggregateInputType = {
    id?: true
    feature?: true
    created_at?: true
    updated_at?: true
  }

  export type FeaturesCountAggregateInputType = {
    id?: true
    feature?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type FeaturesAggregateArgs = {
    /**
     * Filter which features to aggregate.
     */
    where?: featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of features to fetch.
     */
    orderBy?: Enumerable<featuresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned features
    **/
    _count?: true | FeaturesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeaturesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeaturesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturesMaxAggregateInputType
  }

  export type GetFeaturesAggregateType<T extends FeaturesAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatures[P]>
      : GetScalarType<T[P], AggregateFeatures[P]>
  }




  export type FeaturesGroupByArgs = {
    where?: featuresWhereInput
    orderBy?: Enumerable<featuresOrderByWithAggregationInput>
    by: FeaturesScalarFieldEnum[]
    having?: featuresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturesCountAggregateInputType | true
    _avg?: FeaturesAvgAggregateInputType
    _sum?: FeaturesSumAggregateInputType
    _min?: FeaturesMinAggregateInputType
    _max?: FeaturesMaxAggregateInputType
  }


  export type FeaturesGroupByOutputType = {
    id: number
    feature: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: FeaturesCountAggregateOutputType | null
    _avg: FeaturesAvgAggregateOutputType | null
    _sum: FeaturesSumAggregateOutputType | null
    _min: FeaturesMinAggregateOutputType | null
    _max: FeaturesMaxAggregateOutputType | null
  }

  type GetFeaturesGroupByPayload<T extends FeaturesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FeaturesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturesGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturesGroupByOutputType[P]>
        }
      >
    >


  export type featuresSelect = {
    id?: boolean
    feature?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type featuresGetPayload<S extends boolean | null | undefined | featuresArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? features :
    S extends undefined ? never :
    S extends { include: any } & (featuresArgs | featuresFindManyArgs)
    ? features 
    : S extends { select: any } & (featuresArgs | featuresFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof features ? features[P] : never
  } 
      : features


  type featuresCountArgs = 
    Omit<featuresFindManyArgs, 'select' | 'include'> & {
      select?: FeaturesCountAggregateInputType | true
    }

  export interface featuresDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Features that matches the filter.
     * @param {featuresFindUniqueArgs} args - Arguments to find a Features
     * @example
     * // Get one Features
     * const features = await prisma.features.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends featuresFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, featuresFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'features'> extends True ? Prisma__featuresClient<featuresGetPayload<T>> : Prisma__featuresClient<featuresGetPayload<T> | null, null>

    /**
     * Find one Features that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {featuresFindUniqueOrThrowArgs} args - Arguments to find a Features
     * @example
     * // Get one Features
     * const features = await prisma.features.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends featuresFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, featuresFindUniqueOrThrowArgs>
    ): Prisma__featuresClient<featuresGetPayload<T>>

    /**
     * Find the first Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresFindFirstArgs} args - Arguments to find a Features
     * @example
     * // Get one Features
     * const features = await prisma.features.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends featuresFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, featuresFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'features'> extends True ? Prisma__featuresClient<featuresGetPayload<T>> : Prisma__featuresClient<featuresGetPayload<T> | null, null>

    /**
     * Find the first Features that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresFindFirstOrThrowArgs} args - Arguments to find a Features
     * @example
     * // Get one Features
     * const features = await prisma.features.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends featuresFindFirstOrThrowArgs>(
      args?: SelectSubset<T, featuresFindFirstOrThrowArgs>
    ): Prisma__featuresClient<featuresGetPayload<T>>

    /**
     * Find zero or more Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Features
     * const features = await prisma.features.findMany()
     * 
     * // Get first 10 Features
     * const features = await prisma.features.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featuresWithIdOnly = await prisma.features.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends featuresFindManyArgs>(
      args?: SelectSubset<T, featuresFindManyArgs>
    ): Prisma.PrismaPromise<Array<featuresGetPayload<T>>>

    /**
     * Create a Features.
     * @param {featuresCreateArgs} args - Arguments to create a Features.
     * @example
     * // Create one Features
     * const Features = await prisma.features.create({
     *   data: {
     *     // ... data to create a Features
     *   }
     * })
     * 
    **/
    create<T extends featuresCreateArgs>(
      args: SelectSubset<T, featuresCreateArgs>
    ): Prisma__featuresClient<featuresGetPayload<T>>

    /**
     * Create many Features.
     *     @param {featuresCreateManyArgs} args - Arguments to create many Features.
     *     @example
     *     // Create many Features
     *     const features = await prisma.features.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends featuresCreateManyArgs>(
      args?: SelectSubset<T, featuresCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Features.
     * @param {featuresDeleteArgs} args - Arguments to delete one Features.
     * @example
     * // Delete one Features
     * const Features = await prisma.features.delete({
     *   where: {
     *     // ... filter to delete one Features
     *   }
     * })
     * 
    **/
    delete<T extends featuresDeleteArgs>(
      args: SelectSubset<T, featuresDeleteArgs>
    ): Prisma__featuresClient<featuresGetPayload<T>>

    /**
     * Update one Features.
     * @param {featuresUpdateArgs} args - Arguments to update one Features.
     * @example
     * // Update one Features
     * const features = await prisma.features.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends featuresUpdateArgs>(
      args: SelectSubset<T, featuresUpdateArgs>
    ): Prisma__featuresClient<featuresGetPayload<T>>

    /**
     * Delete zero or more Features.
     * @param {featuresDeleteManyArgs} args - Arguments to filter Features to delete.
     * @example
     * // Delete a few Features
     * const { count } = await prisma.features.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends featuresDeleteManyArgs>(
      args?: SelectSubset<T, featuresDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Features
     * const features = await prisma.features.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends featuresUpdateManyArgs>(
      args: SelectSubset<T, featuresUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Features.
     * @param {featuresUpsertArgs} args - Arguments to update or create a Features.
     * @example
     * // Update or create a Features
     * const features = await prisma.features.upsert({
     *   create: {
     *     // ... data to create a Features
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Features we want to update
     *   }
     * })
    **/
    upsert<T extends featuresUpsertArgs>(
      args: SelectSubset<T, featuresUpsertArgs>
    ): Prisma__featuresClient<featuresGetPayload<T>>

    /**
     * Count the number of Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresCountArgs} args - Arguments to filter Features to count.
     * @example
     * // Count the number of Features
     * const count = await prisma.features.count({
     *   where: {
     *     // ... the filter for the Features we want to count
     *   }
     * })
    **/
    count<T extends featuresCountArgs>(
      args?: Subset<T, featuresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturesAggregateArgs>(args: Subset<T, FeaturesAggregateArgs>): Prisma.PrismaPromise<GetFeaturesAggregateType<T>>

    /**
     * Group by Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeaturesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeaturesGroupByArgs['orderBy'] }
        : { orderBy?: FeaturesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeaturesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for features.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__featuresClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * features base type for findUnique actions
   */
  export type featuresFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect | null
    /**
     * Filter, which features to fetch.
     */
    where: featuresWhereUniqueInput
  }

  /**
   * features findUnique
   */
  export interface featuresFindUniqueArgs extends featuresFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * features findUniqueOrThrow
   */
  export type featuresFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect | null
    /**
     * Filter, which features to fetch.
     */
    where: featuresWhereUniqueInput
  }


  /**
   * features base type for findFirst actions
   */
  export type featuresFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect | null
    /**
     * Filter, which features to fetch.
     */
    where?: featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of features to fetch.
     */
    orderBy?: Enumerable<featuresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for features.
     */
    cursor?: featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of features.
     */
    distinct?: Enumerable<FeaturesScalarFieldEnum>
  }

  /**
   * features findFirst
   */
  export interface featuresFindFirstArgs extends featuresFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * features findFirstOrThrow
   */
  export type featuresFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect | null
    /**
     * Filter, which features to fetch.
     */
    where?: featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of features to fetch.
     */
    orderBy?: Enumerable<featuresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for features.
     */
    cursor?: featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of features.
     */
    distinct?: Enumerable<FeaturesScalarFieldEnum>
  }


  /**
   * features findMany
   */
  export type featuresFindManyArgs = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect | null
    /**
     * Filter, which features to fetch.
     */
    where?: featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of features to fetch.
     */
    orderBy?: Enumerable<featuresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing features.
     */
    cursor?: featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` features.
     */
    skip?: number
    distinct?: Enumerable<FeaturesScalarFieldEnum>
  }


  /**
   * features create
   */
  export type featuresCreateArgs = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect | null
    /**
     * The data needed to create a features.
     */
    data: XOR<featuresCreateInput, featuresUncheckedCreateInput>
  }


  /**
   * features createMany
   */
  export type featuresCreateManyArgs = {
    /**
     * The data used to create many features.
     */
    data: Enumerable<featuresCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * features update
   */
  export type featuresUpdateArgs = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect | null
    /**
     * The data needed to update a features.
     */
    data: XOR<featuresUpdateInput, featuresUncheckedUpdateInput>
    /**
     * Choose, which features to update.
     */
    where: featuresWhereUniqueInput
  }


  /**
   * features updateMany
   */
  export type featuresUpdateManyArgs = {
    /**
     * The data used to update features.
     */
    data: XOR<featuresUpdateManyMutationInput, featuresUncheckedUpdateManyInput>
    /**
     * Filter which features to update
     */
    where?: featuresWhereInput
  }


  /**
   * features upsert
   */
  export type featuresUpsertArgs = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect | null
    /**
     * The filter to search for the features to update in case it exists.
     */
    where: featuresWhereUniqueInput
    /**
     * In case the features found by the `where` argument doesn't exist, create a new features with this data.
     */
    create: XOR<featuresCreateInput, featuresUncheckedCreateInput>
    /**
     * In case the features was found with the provided `where` argument, update it with this data.
     */
    update: XOR<featuresUpdateInput, featuresUncheckedUpdateInput>
  }


  /**
   * features delete
   */
  export type featuresDeleteArgs = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect | null
    /**
     * Filter which features to delete.
     */
    where: featuresWhereUniqueInput
  }


  /**
   * features deleteMany
   */
  export type featuresDeleteManyArgs = {
    /**
     * Filter which features to delete
     */
    where?: featuresWhereInput
  }


  /**
   * features without action
   */
  export type featuresArgs = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect | null
  }



  /**
   * Model files
   */


  export type AggregateFiles = {
    _count: FilesCountAggregateOutputType | null
    _avg: FilesAvgAggregateOutputType | null
    _sum: FilesSumAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  export type FilesAvgAggregateOutputType = {
    id: number | null
  }

  export type FilesSumAggregateOutputType = {
    id: number | null
  }

  export type FilesMinAggregateOutputType = {
    id: number | null
    filename: string | null
    mime: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FilesMaxAggregateOutputType = {
    id: number | null
    filename: string | null
    mime: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FilesCountAggregateOutputType = {
    id: number
    filename: number
    mime: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type FilesAvgAggregateInputType = {
    id?: true
  }

  export type FilesSumAggregateInputType = {
    id?: true
  }

  export type FilesMinAggregateInputType = {
    id?: true
    filename?: true
    mime?: true
    created_at?: true
    updated_at?: true
  }

  export type FilesMaxAggregateInputType = {
    id?: true
    filename?: true
    mime?: true
    created_at?: true
    updated_at?: true
  }

  export type FilesCountAggregateInputType = {
    id?: true
    filename?: true
    mime?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type FilesAggregateArgs = {
    /**
     * Filter which files to aggregate.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: Enumerable<filesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned files
    **/
    _count?: true | FilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilesMaxAggregateInputType
  }

  export type GetFilesAggregateType<T extends FilesAggregateArgs> = {
        [P in keyof T & keyof AggregateFiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiles[P]>
      : GetScalarType<T[P], AggregateFiles[P]>
  }




  export type FilesGroupByArgs = {
    where?: filesWhereInput
    orderBy?: Enumerable<filesOrderByWithAggregationInput>
    by: FilesScalarFieldEnum[]
    having?: filesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilesCountAggregateInputType | true
    _avg?: FilesAvgAggregateInputType
    _sum?: FilesSumAggregateInputType
    _min?: FilesMinAggregateInputType
    _max?: FilesMaxAggregateInputType
  }


  export type FilesGroupByOutputType = {
    id: number
    filename: string
    mime: string
    created_at: Date | null
    updated_at: Date | null
    _count: FilesCountAggregateOutputType | null
    _avg: FilesAvgAggregateOutputType | null
    _sum: FilesSumAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  type GetFilesGroupByPayload<T extends FilesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilesGroupByOutputType[P]>
            : GetScalarType<T[P], FilesGroupByOutputType[P]>
        }
      >
    >


  export type filesSelect = {
    id?: boolean
    filename?: boolean
    mime?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type filesGetPayload<S extends boolean | null | undefined | filesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? files :
    S extends undefined ? never :
    S extends { include: any } & (filesArgs | filesFindManyArgs)
    ? files 
    : S extends { select: any } & (filesArgs | filesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof files ? files[P] : never
  } 
      : files


  type filesCountArgs = 
    Omit<filesFindManyArgs, 'select' | 'include'> & {
      select?: FilesCountAggregateInputType | true
    }

  export interface filesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Files that matches the filter.
     * @param {filesFindUniqueArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends filesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, filesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'files'> extends True ? Prisma__filesClient<filesGetPayload<T>> : Prisma__filesClient<filesGetPayload<T> | null, null>

    /**
     * Find one Files that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {filesFindUniqueOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends filesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, filesFindUniqueOrThrowArgs>
    ): Prisma__filesClient<filesGetPayload<T>>

    /**
     * Find the first Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindFirstArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends filesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, filesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'files'> extends True ? Prisma__filesClient<filesGetPayload<T>> : Prisma__filesClient<filesGetPayload<T> | null, null>

    /**
     * Find the first Files that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindFirstOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends filesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, filesFindFirstOrThrowArgs>
    ): Prisma__filesClient<filesGetPayload<T>>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.files.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.files.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filesWithIdOnly = await prisma.files.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends filesFindManyArgs>(
      args?: SelectSubset<T, filesFindManyArgs>
    ): Prisma.PrismaPromise<Array<filesGetPayload<T>>>

    /**
     * Create a Files.
     * @param {filesCreateArgs} args - Arguments to create a Files.
     * @example
     * // Create one Files
     * const Files = await prisma.files.create({
     *   data: {
     *     // ... data to create a Files
     *   }
     * })
     * 
    **/
    create<T extends filesCreateArgs>(
      args: SelectSubset<T, filesCreateArgs>
    ): Prisma__filesClient<filesGetPayload<T>>

    /**
     * Create many Files.
     *     @param {filesCreateManyArgs} args - Arguments to create many Files.
     *     @example
     *     // Create many Files
     *     const files = await prisma.files.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends filesCreateManyArgs>(
      args?: SelectSubset<T, filesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Files.
     * @param {filesDeleteArgs} args - Arguments to delete one Files.
     * @example
     * // Delete one Files
     * const Files = await prisma.files.delete({
     *   where: {
     *     // ... filter to delete one Files
     *   }
     * })
     * 
    **/
    delete<T extends filesDeleteArgs>(
      args: SelectSubset<T, filesDeleteArgs>
    ): Prisma__filesClient<filesGetPayload<T>>

    /**
     * Update one Files.
     * @param {filesUpdateArgs} args - Arguments to update one Files.
     * @example
     * // Update one Files
     * const files = await prisma.files.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends filesUpdateArgs>(
      args: SelectSubset<T, filesUpdateArgs>
    ): Prisma__filesClient<filesGetPayload<T>>

    /**
     * Delete zero or more Files.
     * @param {filesDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.files.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends filesDeleteManyArgs>(
      args?: SelectSubset<T, filesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const files = await prisma.files.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends filesUpdateManyArgs>(
      args: SelectSubset<T, filesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Files.
     * @param {filesUpsertArgs} args - Arguments to update or create a Files.
     * @example
     * // Update or create a Files
     * const files = await prisma.files.upsert({
     *   create: {
     *     // ... data to create a Files
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Files we want to update
     *   }
     * })
    **/
    upsert<T extends filesUpsertArgs>(
      args: SelectSubset<T, filesUpsertArgs>
    ): Prisma__filesClient<filesGetPayload<T>>

    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.files.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends filesCountArgs>(
      args?: Subset<T, filesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilesAggregateArgs>(args: Subset<T, FilesAggregateArgs>): Prisma.PrismaPromise<GetFilesAggregateType<T>>

    /**
     * Group by Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilesGroupByArgs['orderBy'] }
        : { orderBy?: FilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for files.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__filesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * files base type for findUnique actions
   */
  export type filesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect | null
    /**
     * Filter, which files to fetch.
     */
    where: filesWhereUniqueInput
  }

  /**
   * files findUnique
   */
  export interface filesFindUniqueArgs extends filesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * files findUniqueOrThrow
   */
  export type filesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect | null
    /**
     * Filter, which files to fetch.
     */
    where: filesWhereUniqueInput
  }


  /**
   * files base type for findFirst actions
   */
  export type filesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect | null
    /**
     * Filter, which files to fetch.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: Enumerable<filesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files.
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files.
     */
    distinct?: Enumerable<FilesScalarFieldEnum>
  }

  /**
   * files findFirst
   */
  export interface filesFindFirstArgs extends filesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * files findFirstOrThrow
   */
  export type filesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect | null
    /**
     * Filter, which files to fetch.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: Enumerable<filesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files.
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files.
     */
    distinct?: Enumerable<FilesScalarFieldEnum>
  }


  /**
   * files findMany
   */
  export type filesFindManyArgs = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect | null
    /**
     * Filter, which files to fetch.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: Enumerable<filesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing files.
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    distinct?: Enumerable<FilesScalarFieldEnum>
  }


  /**
   * files create
   */
  export type filesCreateArgs = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect | null
    /**
     * The data needed to create a files.
     */
    data: XOR<filesCreateInput, filesUncheckedCreateInput>
  }


  /**
   * files createMany
   */
  export type filesCreateManyArgs = {
    /**
     * The data used to create many files.
     */
    data: Enumerable<filesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * files update
   */
  export type filesUpdateArgs = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect | null
    /**
     * The data needed to update a files.
     */
    data: XOR<filesUpdateInput, filesUncheckedUpdateInput>
    /**
     * Choose, which files to update.
     */
    where: filesWhereUniqueInput
  }


  /**
   * files updateMany
   */
  export type filesUpdateManyArgs = {
    /**
     * The data used to update files.
     */
    data: XOR<filesUpdateManyMutationInput, filesUncheckedUpdateManyInput>
    /**
     * Filter which files to update
     */
    where?: filesWhereInput
  }


  /**
   * files upsert
   */
  export type filesUpsertArgs = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect | null
    /**
     * The filter to search for the files to update in case it exists.
     */
    where: filesWhereUniqueInput
    /**
     * In case the files found by the `where` argument doesn't exist, create a new files with this data.
     */
    create: XOR<filesCreateInput, filesUncheckedCreateInput>
    /**
     * In case the files was found with the provided `where` argument, update it with this data.
     */
    update: XOR<filesUpdateInput, filesUncheckedUpdateInput>
  }


  /**
   * files delete
   */
  export type filesDeleteArgs = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect | null
    /**
     * Filter which files to delete.
     */
    where: filesWhereUniqueInput
  }


  /**
   * files deleteMany
   */
  export type filesDeleteManyArgs = {
    /**
     * Filter which files to delete
     */
    where?: filesWhereInput
  }


  /**
   * files without action
   */
  export type filesArgs = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect | null
  }



  /**
   * Model fuel_types
   */


  export type AggregateFuel_types = {
    _count: Fuel_typesCountAggregateOutputType | null
    _avg: Fuel_typesAvgAggregateOutputType | null
    _sum: Fuel_typesSumAggregateOutputType | null
    _min: Fuel_typesMinAggregateOutputType | null
    _max: Fuel_typesMaxAggregateOutputType | null
  }

  export type Fuel_typesAvgAggregateOutputType = {
    id: number | null
  }

  export type Fuel_typesSumAggregateOutputType = {
    id: number | null
  }

  export type Fuel_typesMinAggregateOutputType = {
    id: number | null
    fuel_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Fuel_typesMaxAggregateOutputType = {
    id: number | null
    fuel_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Fuel_typesCountAggregateOutputType = {
    id: number
    fuel_type: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Fuel_typesAvgAggregateInputType = {
    id?: true
  }

  export type Fuel_typesSumAggregateInputType = {
    id?: true
  }

  export type Fuel_typesMinAggregateInputType = {
    id?: true
    fuel_type?: true
    created_at?: true
    updated_at?: true
  }

  export type Fuel_typesMaxAggregateInputType = {
    id?: true
    fuel_type?: true
    created_at?: true
    updated_at?: true
  }

  export type Fuel_typesCountAggregateInputType = {
    id?: true
    fuel_type?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Fuel_typesAggregateArgs = {
    /**
     * Filter which fuel_types to aggregate.
     */
    where?: fuel_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fuel_types to fetch.
     */
    orderBy?: Enumerable<fuel_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fuel_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fuel_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fuel_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fuel_types
    **/
    _count?: true | Fuel_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fuel_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fuel_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fuel_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fuel_typesMaxAggregateInputType
  }

  export type GetFuel_typesAggregateType<T extends Fuel_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateFuel_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFuel_types[P]>
      : GetScalarType<T[P], AggregateFuel_types[P]>
  }




  export type Fuel_typesGroupByArgs = {
    where?: fuel_typesWhereInput
    orderBy?: Enumerable<fuel_typesOrderByWithAggregationInput>
    by: Fuel_typesScalarFieldEnum[]
    having?: fuel_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fuel_typesCountAggregateInputType | true
    _avg?: Fuel_typesAvgAggregateInputType
    _sum?: Fuel_typesSumAggregateInputType
    _min?: Fuel_typesMinAggregateInputType
    _max?: Fuel_typesMaxAggregateInputType
  }


  export type Fuel_typesGroupByOutputType = {
    id: number
    fuel_type: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Fuel_typesCountAggregateOutputType | null
    _avg: Fuel_typesAvgAggregateOutputType | null
    _sum: Fuel_typesSumAggregateOutputType | null
    _min: Fuel_typesMinAggregateOutputType | null
    _max: Fuel_typesMaxAggregateOutputType | null
  }

  type GetFuel_typesGroupByPayload<T extends Fuel_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Fuel_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fuel_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fuel_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Fuel_typesGroupByOutputType[P]>
        }
      >
    >


  export type fuel_typesSelect = {
    id?: boolean
    fuel_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    cars?: boolean | fuel_types$carsArgs
    _count?: boolean | Fuel_typesCountOutputTypeArgs
  }


  export type fuel_typesInclude = {
    cars?: boolean | fuel_types$carsArgs
    _count?: boolean | Fuel_typesCountOutputTypeArgs
  }

  export type fuel_typesGetPayload<S extends boolean | null | undefined | fuel_typesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? fuel_types :
    S extends undefined ? never :
    S extends { include: any } & (fuel_typesArgs | fuel_typesFindManyArgs)
    ? fuel_types  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'cars' ? Array < carsGetPayload<S['include'][P]>>  :
        P extends '_count' ? Fuel_typesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (fuel_typesArgs | fuel_typesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'cars' ? Array < carsGetPayload<S['select'][P]>>  :
        P extends '_count' ? Fuel_typesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof fuel_types ? fuel_types[P] : never
  } 
      : fuel_types


  type fuel_typesCountArgs = 
    Omit<fuel_typesFindManyArgs, 'select' | 'include'> & {
      select?: Fuel_typesCountAggregateInputType | true
    }

  export interface fuel_typesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Fuel_types that matches the filter.
     * @param {fuel_typesFindUniqueArgs} args - Arguments to find a Fuel_types
     * @example
     * // Get one Fuel_types
     * const fuel_types = await prisma.fuel_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fuel_typesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fuel_typesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fuel_types'> extends True ? Prisma__fuel_typesClient<fuel_typesGetPayload<T>> : Prisma__fuel_typesClient<fuel_typesGetPayload<T> | null, null>

    /**
     * Find one Fuel_types that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fuel_typesFindUniqueOrThrowArgs} args - Arguments to find a Fuel_types
     * @example
     * // Get one Fuel_types
     * const fuel_types = await prisma.fuel_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fuel_typesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, fuel_typesFindUniqueOrThrowArgs>
    ): Prisma__fuel_typesClient<fuel_typesGetPayload<T>>

    /**
     * Find the first Fuel_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fuel_typesFindFirstArgs} args - Arguments to find a Fuel_types
     * @example
     * // Get one Fuel_types
     * const fuel_types = await prisma.fuel_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fuel_typesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fuel_typesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fuel_types'> extends True ? Prisma__fuel_typesClient<fuel_typesGetPayload<T>> : Prisma__fuel_typesClient<fuel_typesGetPayload<T> | null, null>

    /**
     * Find the first Fuel_types that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fuel_typesFindFirstOrThrowArgs} args - Arguments to find a Fuel_types
     * @example
     * // Get one Fuel_types
     * const fuel_types = await prisma.fuel_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fuel_typesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fuel_typesFindFirstOrThrowArgs>
    ): Prisma__fuel_typesClient<fuel_typesGetPayload<T>>

    /**
     * Find zero or more Fuel_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fuel_typesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fuel_types
     * const fuel_types = await prisma.fuel_types.findMany()
     * 
     * // Get first 10 Fuel_types
     * const fuel_types = await prisma.fuel_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fuel_typesWithIdOnly = await prisma.fuel_types.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fuel_typesFindManyArgs>(
      args?: SelectSubset<T, fuel_typesFindManyArgs>
    ): Prisma.PrismaPromise<Array<fuel_typesGetPayload<T>>>

    /**
     * Create a Fuel_types.
     * @param {fuel_typesCreateArgs} args - Arguments to create a Fuel_types.
     * @example
     * // Create one Fuel_types
     * const Fuel_types = await prisma.fuel_types.create({
     *   data: {
     *     // ... data to create a Fuel_types
     *   }
     * })
     * 
    **/
    create<T extends fuel_typesCreateArgs>(
      args: SelectSubset<T, fuel_typesCreateArgs>
    ): Prisma__fuel_typesClient<fuel_typesGetPayload<T>>

    /**
     * Create many Fuel_types.
     *     @param {fuel_typesCreateManyArgs} args - Arguments to create many Fuel_types.
     *     @example
     *     // Create many Fuel_types
     *     const fuel_types = await prisma.fuel_types.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fuel_typesCreateManyArgs>(
      args?: SelectSubset<T, fuel_typesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fuel_types.
     * @param {fuel_typesDeleteArgs} args - Arguments to delete one Fuel_types.
     * @example
     * // Delete one Fuel_types
     * const Fuel_types = await prisma.fuel_types.delete({
     *   where: {
     *     // ... filter to delete one Fuel_types
     *   }
     * })
     * 
    **/
    delete<T extends fuel_typesDeleteArgs>(
      args: SelectSubset<T, fuel_typesDeleteArgs>
    ): Prisma__fuel_typesClient<fuel_typesGetPayload<T>>

    /**
     * Update one Fuel_types.
     * @param {fuel_typesUpdateArgs} args - Arguments to update one Fuel_types.
     * @example
     * // Update one Fuel_types
     * const fuel_types = await prisma.fuel_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fuel_typesUpdateArgs>(
      args: SelectSubset<T, fuel_typesUpdateArgs>
    ): Prisma__fuel_typesClient<fuel_typesGetPayload<T>>

    /**
     * Delete zero or more Fuel_types.
     * @param {fuel_typesDeleteManyArgs} args - Arguments to filter Fuel_types to delete.
     * @example
     * // Delete a few Fuel_types
     * const { count } = await prisma.fuel_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fuel_typesDeleteManyArgs>(
      args?: SelectSubset<T, fuel_typesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fuel_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fuel_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fuel_types
     * const fuel_types = await prisma.fuel_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fuel_typesUpdateManyArgs>(
      args: SelectSubset<T, fuel_typesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fuel_types.
     * @param {fuel_typesUpsertArgs} args - Arguments to update or create a Fuel_types.
     * @example
     * // Update or create a Fuel_types
     * const fuel_types = await prisma.fuel_types.upsert({
     *   create: {
     *     // ... data to create a Fuel_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fuel_types we want to update
     *   }
     * })
    **/
    upsert<T extends fuel_typesUpsertArgs>(
      args: SelectSubset<T, fuel_typesUpsertArgs>
    ): Prisma__fuel_typesClient<fuel_typesGetPayload<T>>

    /**
     * Count the number of Fuel_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fuel_typesCountArgs} args - Arguments to filter Fuel_types to count.
     * @example
     * // Count the number of Fuel_types
     * const count = await prisma.fuel_types.count({
     *   where: {
     *     // ... the filter for the Fuel_types we want to count
     *   }
     * })
    **/
    count<T extends fuel_typesCountArgs>(
      args?: Subset<T, fuel_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fuel_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fuel_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fuel_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fuel_typesAggregateArgs>(args: Subset<T, Fuel_typesAggregateArgs>): Prisma.PrismaPromise<GetFuel_typesAggregateType<T>>

    /**
     * Group by Fuel_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fuel_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fuel_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fuel_typesGroupByArgs['orderBy'] }
        : { orderBy?: Fuel_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fuel_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFuel_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fuel_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fuel_typesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cars<T extends fuel_types$carsArgs= {}>(args?: Subset<T, fuel_types$carsArgs>): Prisma.PrismaPromise<Array<carsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fuel_types base type for findUnique actions
   */
  export type fuel_typesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the fuel_types
     */
    select?: fuel_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fuel_typesInclude | null
    /**
     * Filter, which fuel_types to fetch.
     */
    where: fuel_typesWhereUniqueInput
  }

  /**
   * fuel_types findUnique
   */
  export interface fuel_typesFindUniqueArgs extends fuel_typesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fuel_types findUniqueOrThrow
   */
  export type fuel_typesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the fuel_types
     */
    select?: fuel_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fuel_typesInclude | null
    /**
     * Filter, which fuel_types to fetch.
     */
    where: fuel_typesWhereUniqueInput
  }


  /**
   * fuel_types base type for findFirst actions
   */
  export type fuel_typesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the fuel_types
     */
    select?: fuel_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fuel_typesInclude | null
    /**
     * Filter, which fuel_types to fetch.
     */
    where?: fuel_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fuel_types to fetch.
     */
    orderBy?: Enumerable<fuel_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fuel_types.
     */
    cursor?: fuel_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fuel_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fuel_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fuel_types.
     */
    distinct?: Enumerable<Fuel_typesScalarFieldEnum>
  }

  /**
   * fuel_types findFirst
   */
  export interface fuel_typesFindFirstArgs extends fuel_typesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fuel_types findFirstOrThrow
   */
  export type fuel_typesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the fuel_types
     */
    select?: fuel_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fuel_typesInclude | null
    /**
     * Filter, which fuel_types to fetch.
     */
    where?: fuel_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fuel_types to fetch.
     */
    orderBy?: Enumerable<fuel_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fuel_types.
     */
    cursor?: fuel_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fuel_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fuel_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fuel_types.
     */
    distinct?: Enumerable<Fuel_typesScalarFieldEnum>
  }


  /**
   * fuel_types findMany
   */
  export type fuel_typesFindManyArgs = {
    /**
     * Select specific fields to fetch from the fuel_types
     */
    select?: fuel_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fuel_typesInclude | null
    /**
     * Filter, which fuel_types to fetch.
     */
    where?: fuel_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fuel_types to fetch.
     */
    orderBy?: Enumerable<fuel_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fuel_types.
     */
    cursor?: fuel_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fuel_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fuel_types.
     */
    skip?: number
    distinct?: Enumerable<Fuel_typesScalarFieldEnum>
  }


  /**
   * fuel_types create
   */
  export type fuel_typesCreateArgs = {
    /**
     * Select specific fields to fetch from the fuel_types
     */
    select?: fuel_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fuel_typesInclude | null
    /**
     * The data needed to create a fuel_types.
     */
    data: XOR<fuel_typesCreateInput, fuel_typesUncheckedCreateInput>
  }


  /**
   * fuel_types createMany
   */
  export type fuel_typesCreateManyArgs = {
    /**
     * The data used to create many fuel_types.
     */
    data: Enumerable<fuel_typesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * fuel_types update
   */
  export type fuel_typesUpdateArgs = {
    /**
     * Select specific fields to fetch from the fuel_types
     */
    select?: fuel_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fuel_typesInclude | null
    /**
     * The data needed to update a fuel_types.
     */
    data: XOR<fuel_typesUpdateInput, fuel_typesUncheckedUpdateInput>
    /**
     * Choose, which fuel_types to update.
     */
    where: fuel_typesWhereUniqueInput
  }


  /**
   * fuel_types updateMany
   */
  export type fuel_typesUpdateManyArgs = {
    /**
     * The data used to update fuel_types.
     */
    data: XOR<fuel_typesUpdateManyMutationInput, fuel_typesUncheckedUpdateManyInput>
    /**
     * Filter which fuel_types to update
     */
    where?: fuel_typesWhereInput
  }


  /**
   * fuel_types upsert
   */
  export type fuel_typesUpsertArgs = {
    /**
     * Select specific fields to fetch from the fuel_types
     */
    select?: fuel_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fuel_typesInclude | null
    /**
     * The filter to search for the fuel_types to update in case it exists.
     */
    where: fuel_typesWhereUniqueInput
    /**
     * In case the fuel_types found by the `where` argument doesn't exist, create a new fuel_types with this data.
     */
    create: XOR<fuel_typesCreateInput, fuel_typesUncheckedCreateInput>
    /**
     * In case the fuel_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fuel_typesUpdateInput, fuel_typesUncheckedUpdateInput>
  }


  /**
   * fuel_types delete
   */
  export type fuel_typesDeleteArgs = {
    /**
     * Select specific fields to fetch from the fuel_types
     */
    select?: fuel_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fuel_typesInclude | null
    /**
     * Filter which fuel_types to delete.
     */
    where: fuel_typesWhereUniqueInput
  }


  /**
   * fuel_types deleteMany
   */
  export type fuel_typesDeleteManyArgs = {
    /**
     * Filter which fuel_types to delete
     */
    where?: fuel_typesWhereInput
  }


  /**
   * fuel_types.cars
   */
  export type fuel_types$carsArgs = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    where?: carsWhereInput
    orderBy?: Enumerable<carsOrderByWithRelationInput>
    cursor?: carsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CarsScalarFieldEnum>
  }


  /**
   * fuel_types without action
   */
  export type fuel_typesArgs = {
    /**
     * Select specific fields to fetch from the fuel_types
     */
    select?: fuel_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fuel_typesInclude | null
  }



  /**
   * Model gratuities
   */


  export type AggregateGratuities = {
    _count: GratuitiesCountAggregateOutputType | null
    _avg: GratuitiesAvgAggregateOutputType | null
    _sum: GratuitiesSumAggregateOutputType | null
    _min: GratuitiesMinAggregateOutputType | null
    _max: GratuitiesMaxAggregateOutputType | null
  }

  export type GratuitiesAvgAggregateOutputType = {
    id: number | null
    percentage: number | null
    price: number | null
    service_id: number | null
  }

  export type GratuitiesSumAggregateOutputType = {
    id: number | null
    percentage: number | null
    price: number | null
    service_id: number | null
  }

  export type GratuitiesMinAggregateOutputType = {
    id: number | null
    percentage: number | null
    status: boolean | null
    name: string | null
    price: number | null
    service_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type GratuitiesMaxAggregateOutputType = {
    id: number | null
    percentage: number | null
    status: boolean | null
    name: string | null
    price: number | null
    service_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type GratuitiesCountAggregateOutputType = {
    id: number
    percentage: number
    status: number
    name: number
    price: number
    service_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type GratuitiesAvgAggregateInputType = {
    id?: true
    percentage?: true
    price?: true
    service_id?: true
  }

  export type GratuitiesSumAggregateInputType = {
    id?: true
    percentage?: true
    price?: true
    service_id?: true
  }

  export type GratuitiesMinAggregateInputType = {
    id?: true
    percentage?: true
    status?: true
    name?: true
    price?: true
    service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type GratuitiesMaxAggregateInputType = {
    id?: true
    percentage?: true
    status?: true
    name?: true
    price?: true
    service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type GratuitiesCountAggregateInputType = {
    id?: true
    percentage?: true
    status?: true
    name?: true
    price?: true
    service_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type GratuitiesAggregateArgs = {
    /**
     * Filter which gratuities to aggregate.
     */
    where?: gratuitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gratuities to fetch.
     */
    orderBy?: Enumerable<gratuitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gratuitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gratuities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gratuities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gratuities
    **/
    _count?: true | GratuitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GratuitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GratuitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GratuitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GratuitiesMaxAggregateInputType
  }

  export type GetGratuitiesAggregateType<T extends GratuitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateGratuities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGratuities[P]>
      : GetScalarType<T[P], AggregateGratuities[P]>
  }




  export type GratuitiesGroupByArgs = {
    where?: gratuitiesWhereInput
    orderBy?: Enumerable<gratuitiesOrderByWithAggregationInput>
    by: GratuitiesScalarFieldEnum[]
    having?: gratuitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GratuitiesCountAggregateInputType | true
    _avg?: GratuitiesAvgAggregateInputType
    _sum?: GratuitiesSumAggregateInputType
    _min?: GratuitiesMinAggregateInputType
    _max?: GratuitiesMaxAggregateInputType
  }


  export type GratuitiesGroupByOutputType = {
    id: number
    percentage: number | null
    status: boolean | null
    name: string | null
    price: number
    service_id: number
    created_at: Date | null
    updated_at: Date | null
    _count: GratuitiesCountAggregateOutputType | null
    _avg: GratuitiesAvgAggregateOutputType | null
    _sum: GratuitiesSumAggregateOutputType | null
    _min: GratuitiesMinAggregateOutputType | null
    _max: GratuitiesMaxAggregateOutputType | null
  }

  type GetGratuitiesGroupByPayload<T extends GratuitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GratuitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GratuitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GratuitiesGroupByOutputType[P]>
            : GetScalarType<T[P], GratuitiesGroupByOutputType[P]>
        }
      >
    >


  export type gratuitiesSelect = {
    id?: boolean
    percentage?: boolean
    status?: boolean
    name?: boolean
    price?: boolean
    service_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    services?: boolean | servicesArgs
  }


  export type gratuitiesInclude = {
    services?: boolean | servicesArgs
  }

  export type gratuitiesGetPayload<S extends boolean | null | undefined | gratuitiesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? gratuities :
    S extends undefined ? never :
    S extends { include: any } & (gratuitiesArgs | gratuitiesFindManyArgs)
    ? gratuities  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'services' ? servicesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (gratuitiesArgs | gratuitiesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'services' ? servicesGetPayload<S['select'][P]> :  P extends keyof gratuities ? gratuities[P] : never
  } 
      : gratuities


  type gratuitiesCountArgs = 
    Omit<gratuitiesFindManyArgs, 'select' | 'include'> & {
      select?: GratuitiesCountAggregateInputType | true
    }

  export interface gratuitiesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Gratuities that matches the filter.
     * @param {gratuitiesFindUniqueArgs} args - Arguments to find a Gratuities
     * @example
     * // Get one Gratuities
     * const gratuities = await prisma.gratuities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gratuitiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, gratuitiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'gratuities'> extends True ? Prisma__gratuitiesClient<gratuitiesGetPayload<T>> : Prisma__gratuitiesClient<gratuitiesGetPayload<T> | null, null>

    /**
     * Find one Gratuities that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {gratuitiesFindUniqueOrThrowArgs} args - Arguments to find a Gratuities
     * @example
     * // Get one Gratuities
     * const gratuities = await prisma.gratuities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends gratuitiesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, gratuitiesFindUniqueOrThrowArgs>
    ): Prisma__gratuitiesClient<gratuitiesGetPayload<T>>

    /**
     * Find the first Gratuities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gratuitiesFindFirstArgs} args - Arguments to find a Gratuities
     * @example
     * // Get one Gratuities
     * const gratuities = await prisma.gratuities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gratuitiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, gratuitiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'gratuities'> extends True ? Prisma__gratuitiesClient<gratuitiesGetPayload<T>> : Prisma__gratuitiesClient<gratuitiesGetPayload<T> | null, null>

    /**
     * Find the first Gratuities that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gratuitiesFindFirstOrThrowArgs} args - Arguments to find a Gratuities
     * @example
     * // Get one Gratuities
     * const gratuities = await prisma.gratuities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends gratuitiesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, gratuitiesFindFirstOrThrowArgs>
    ): Prisma__gratuitiesClient<gratuitiesGetPayload<T>>

    /**
     * Find zero or more Gratuities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gratuitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gratuities
     * const gratuities = await prisma.gratuities.findMany()
     * 
     * // Get first 10 Gratuities
     * const gratuities = await prisma.gratuities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gratuitiesWithIdOnly = await prisma.gratuities.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends gratuitiesFindManyArgs>(
      args?: SelectSubset<T, gratuitiesFindManyArgs>
    ): Prisma.PrismaPromise<Array<gratuitiesGetPayload<T>>>

    /**
     * Create a Gratuities.
     * @param {gratuitiesCreateArgs} args - Arguments to create a Gratuities.
     * @example
     * // Create one Gratuities
     * const Gratuities = await prisma.gratuities.create({
     *   data: {
     *     // ... data to create a Gratuities
     *   }
     * })
     * 
    **/
    create<T extends gratuitiesCreateArgs>(
      args: SelectSubset<T, gratuitiesCreateArgs>
    ): Prisma__gratuitiesClient<gratuitiesGetPayload<T>>

    /**
     * Create many Gratuities.
     *     @param {gratuitiesCreateManyArgs} args - Arguments to create many Gratuities.
     *     @example
     *     // Create many Gratuities
     *     const gratuities = await prisma.gratuities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gratuitiesCreateManyArgs>(
      args?: SelectSubset<T, gratuitiesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gratuities.
     * @param {gratuitiesDeleteArgs} args - Arguments to delete one Gratuities.
     * @example
     * // Delete one Gratuities
     * const Gratuities = await prisma.gratuities.delete({
     *   where: {
     *     // ... filter to delete one Gratuities
     *   }
     * })
     * 
    **/
    delete<T extends gratuitiesDeleteArgs>(
      args: SelectSubset<T, gratuitiesDeleteArgs>
    ): Prisma__gratuitiesClient<gratuitiesGetPayload<T>>

    /**
     * Update one Gratuities.
     * @param {gratuitiesUpdateArgs} args - Arguments to update one Gratuities.
     * @example
     * // Update one Gratuities
     * const gratuities = await prisma.gratuities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gratuitiesUpdateArgs>(
      args: SelectSubset<T, gratuitiesUpdateArgs>
    ): Prisma__gratuitiesClient<gratuitiesGetPayload<T>>

    /**
     * Delete zero or more Gratuities.
     * @param {gratuitiesDeleteManyArgs} args - Arguments to filter Gratuities to delete.
     * @example
     * // Delete a few Gratuities
     * const { count } = await prisma.gratuities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gratuitiesDeleteManyArgs>(
      args?: SelectSubset<T, gratuitiesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gratuities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gratuitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gratuities
     * const gratuities = await prisma.gratuities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gratuitiesUpdateManyArgs>(
      args: SelectSubset<T, gratuitiesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gratuities.
     * @param {gratuitiesUpsertArgs} args - Arguments to update or create a Gratuities.
     * @example
     * // Update or create a Gratuities
     * const gratuities = await prisma.gratuities.upsert({
     *   create: {
     *     // ... data to create a Gratuities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gratuities we want to update
     *   }
     * })
    **/
    upsert<T extends gratuitiesUpsertArgs>(
      args: SelectSubset<T, gratuitiesUpsertArgs>
    ): Prisma__gratuitiesClient<gratuitiesGetPayload<T>>

    /**
     * Count the number of Gratuities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gratuitiesCountArgs} args - Arguments to filter Gratuities to count.
     * @example
     * // Count the number of Gratuities
     * const count = await prisma.gratuities.count({
     *   where: {
     *     // ... the filter for the Gratuities we want to count
     *   }
     * })
    **/
    count<T extends gratuitiesCountArgs>(
      args?: Subset<T, gratuitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GratuitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gratuities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GratuitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GratuitiesAggregateArgs>(args: Subset<T, GratuitiesAggregateArgs>): Prisma.PrismaPromise<GetGratuitiesAggregateType<T>>

    /**
     * Group by Gratuities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GratuitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GratuitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GratuitiesGroupByArgs['orderBy'] }
        : { orderBy?: GratuitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GratuitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGratuitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for gratuities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__gratuitiesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    services<T extends servicesArgs= {}>(args?: Subset<T, servicesArgs>): Prisma__servicesClient<servicesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * gratuities base type for findUnique actions
   */
  export type gratuitiesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the gratuities
     */
    select?: gratuitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gratuitiesInclude | null
    /**
     * Filter, which gratuities to fetch.
     */
    where: gratuitiesWhereUniqueInput
  }

  /**
   * gratuities findUnique
   */
  export interface gratuitiesFindUniqueArgs extends gratuitiesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gratuities findUniqueOrThrow
   */
  export type gratuitiesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the gratuities
     */
    select?: gratuitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gratuitiesInclude | null
    /**
     * Filter, which gratuities to fetch.
     */
    where: gratuitiesWhereUniqueInput
  }


  /**
   * gratuities base type for findFirst actions
   */
  export type gratuitiesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the gratuities
     */
    select?: gratuitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gratuitiesInclude | null
    /**
     * Filter, which gratuities to fetch.
     */
    where?: gratuitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gratuities to fetch.
     */
    orderBy?: Enumerable<gratuitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gratuities.
     */
    cursor?: gratuitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gratuities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gratuities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gratuities.
     */
    distinct?: Enumerable<GratuitiesScalarFieldEnum>
  }

  /**
   * gratuities findFirst
   */
  export interface gratuitiesFindFirstArgs extends gratuitiesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gratuities findFirstOrThrow
   */
  export type gratuitiesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the gratuities
     */
    select?: gratuitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gratuitiesInclude | null
    /**
     * Filter, which gratuities to fetch.
     */
    where?: gratuitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gratuities to fetch.
     */
    orderBy?: Enumerable<gratuitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gratuities.
     */
    cursor?: gratuitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gratuities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gratuities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gratuities.
     */
    distinct?: Enumerable<GratuitiesScalarFieldEnum>
  }


  /**
   * gratuities findMany
   */
  export type gratuitiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the gratuities
     */
    select?: gratuitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gratuitiesInclude | null
    /**
     * Filter, which gratuities to fetch.
     */
    where?: gratuitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gratuities to fetch.
     */
    orderBy?: Enumerable<gratuitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gratuities.
     */
    cursor?: gratuitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gratuities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gratuities.
     */
    skip?: number
    distinct?: Enumerable<GratuitiesScalarFieldEnum>
  }


  /**
   * gratuities create
   */
  export type gratuitiesCreateArgs = {
    /**
     * Select specific fields to fetch from the gratuities
     */
    select?: gratuitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gratuitiesInclude | null
    /**
     * The data needed to create a gratuities.
     */
    data: XOR<gratuitiesCreateInput, gratuitiesUncheckedCreateInput>
  }


  /**
   * gratuities createMany
   */
  export type gratuitiesCreateManyArgs = {
    /**
     * The data used to create many gratuities.
     */
    data: Enumerable<gratuitiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * gratuities update
   */
  export type gratuitiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the gratuities
     */
    select?: gratuitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gratuitiesInclude | null
    /**
     * The data needed to update a gratuities.
     */
    data: XOR<gratuitiesUpdateInput, gratuitiesUncheckedUpdateInput>
    /**
     * Choose, which gratuities to update.
     */
    where: gratuitiesWhereUniqueInput
  }


  /**
   * gratuities updateMany
   */
  export type gratuitiesUpdateManyArgs = {
    /**
     * The data used to update gratuities.
     */
    data: XOR<gratuitiesUpdateManyMutationInput, gratuitiesUncheckedUpdateManyInput>
    /**
     * Filter which gratuities to update
     */
    where?: gratuitiesWhereInput
  }


  /**
   * gratuities upsert
   */
  export type gratuitiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the gratuities
     */
    select?: gratuitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gratuitiesInclude | null
    /**
     * The filter to search for the gratuities to update in case it exists.
     */
    where: gratuitiesWhereUniqueInput
    /**
     * In case the gratuities found by the `where` argument doesn't exist, create a new gratuities with this data.
     */
    create: XOR<gratuitiesCreateInput, gratuitiesUncheckedCreateInput>
    /**
     * In case the gratuities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gratuitiesUpdateInput, gratuitiesUncheckedUpdateInput>
  }


  /**
   * gratuities delete
   */
  export type gratuitiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the gratuities
     */
    select?: gratuitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gratuitiesInclude | null
    /**
     * Filter which gratuities to delete.
     */
    where: gratuitiesWhereUniqueInput
  }


  /**
   * gratuities deleteMany
   */
  export type gratuitiesDeleteManyArgs = {
    /**
     * Filter which gratuities to delete
     */
    where?: gratuitiesWhereInput
  }


  /**
   * gratuities without action
   */
  export type gratuitiesArgs = {
    /**
     * Select specific fields to fetch from the gratuities
     */
    select?: gratuitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gratuitiesInclude | null
  }



  /**
   * Model hourly_services
   */


  export type AggregateHourly_services = {
    _count: Hourly_servicesCountAggregateOutputType | null
    _avg: Hourly_servicesAvgAggregateOutputType | null
    _sum: Hourly_servicesSumAggregateOutputType | null
    _min: Hourly_servicesMinAggregateOutputType | null
    _max: Hourly_servicesMaxAggregateOutputType | null
  }

  export type Hourly_servicesAvgAggregateOutputType = {
    id: number | null
    num_passengers: number | null
    num_service_hours: number | null
    service_id: number | null
  }

  export type Hourly_servicesSumAggregateOutputType = {
    id: number | null
    num_passengers: number | null
    num_service_hours: number | null
    service_id: number | null
  }

  export type Hourly_servicesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    pickup_location: string | null
    pickup_date_time: Date | null
    num_passengers: number | null
    num_service_hours: number | null
    dropoff_location: string | null
    add_another_stop: boolean | null
    additional_comments: string | null
    status: boolean | null
    service_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Hourly_servicesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    pickup_location: string | null
    pickup_date_time: Date | null
    num_passengers: number | null
    num_service_hours: number | null
    dropoff_location: string | null
    add_another_stop: boolean | null
    additional_comments: string | null
    status: boolean | null
    service_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Hourly_servicesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    pickup_location: number
    pickup_date_time: number
    num_passengers: number
    num_service_hours: number
    dropoff_location: number
    add_another_stop: number
    additional_comments: number
    status: number
    service_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Hourly_servicesAvgAggregateInputType = {
    id?: true
    num_passengers?: true
    num_service_hours?: true
    service_id?: true
  }

  export type Hourly_servicesSumAggregateInputType = {
    id?: true
    num_passengers?: true
    num_service_hours?: true
    service_id?: true
  }

  export type Hourly_servicesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pickup_location?: true
    pickup_date_time?: true
    num_passengers?: true
    num_service_hours?: true
    dropoff_location?: true
    add_another_stop?: true
    additional_comments?: true
    status?: true
    service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Hourly_servicesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pickup_location?: true
    pickup_date_time?: true
    num_passengers?: true
    num_service_hours?: true
    dropoff_location?: true
    add_another_stop?: true
    additional_comments?: true
    status?: true
    service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Hourly_servicesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pickup_location?: true
    pickup_date_time?: true
    num_passengers?: true
    num_service_hours?: true
    dropoff_location?: true
    add_another_stop?: true
    additional_comments?: true
    status?: true
    service_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Hourly_servicesAggregateArgs = {
    /**
     * Filter which hourly_services to aggregate.
     */
    where?: hourly_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hourly_services to fetch.
     */
    orderBy?: Enumerable<hourly_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hourly_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hourly_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hourly_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hourly_services
    **/
    _count?: true | Hourly_servicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Hourly_servicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Hourly_servicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hourly_servicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hourly_servicesMaxAggregateInputType
  }

  export type GetHourly_servicesAggregateType<T extends Hourly_servicesAggregateArgs> = {
        [P in keyof T & keyof AggregateHourly_services]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHourly_services[P]>
      : GetScalarType<T[P], AggregateHourly_services[P]>
  }




  export type Hourly_servicesGroupByArgs = {
    where?: hourly_servicesWhereInput
    orderBy?: Enumerable<hourly_servicesOrderByWithAggregationInput>
    by: Hourly_servicesScalarFieldEnum[]
    having?: hourly_servicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hourly_servicesCountAggregateInputType | true
    _avg?: Hourly_servicesAvgAggregateInputType
    _sum?: Hourly_servicesSumAggregateInputType
    _min?: Hourly_servicesMinAggregateInputType
    _max?: Hourly_servicesMaxAggregateInputType
  }


  export type Hourly_servicesGroupByOutputType = {
    id: number
    name: string
    description: string | null
    pickup_location: string
    pickup_date_time: Date
    num_passengers: number
    num_service_hours: number
    dropoff_location: string
    add_another_stop: boolean
    additional_comments: string | null
    status: boolean
    service_id: number
    created_at: Date | null
    updated_at: Date | null
    _count: Hourly_servicesCountAggregateOutputType | null
    _avg: Hourly_servicesAvgAggregateOutputType | null
    _sum: Hourly_servicesSumAggregateOutputType | null
    _min: Hourly_servicesMinAggregateOutputType | null
    _max: Hourly_servicesMaxAggregateOutputType | null
  }

  type GetHourly_servicesGroupByPayload<T extends Hourly_servicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Hourly_servicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hourly_servicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hourly_servicesGroupByOutputType[P]>
            : GetScalarType<T[P], Hourly_servicesGroupByOutputType[P]>
        }
      >
    >


  export type hourly_servicesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    pickup_location?: boolean
    pickup_date_time?: boolean
    num_passengers?: boolean
    num_service_hours?: boolean
    dropoff_location?: boolean
    add_another_stop?: boolean
    additional_comments?: boolean
    status?: boolean
    service_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    services?: boolean | servicesArgs
  }


  export type hourly_servicesInclude = {
    services?: boolean | servicesArgs
  }

  export type hourly_servicesGetPayload<S extends boolean | null | undefined | hourly_servicesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? hourly_services :
    S extends undefined ? never :
    S extends { include: any } & (hourly_servicesArgs | hourly_servicesFindManyArgs)
    ? hourly_services  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'services' ? servicesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (hourly_servicesArgs | hourly_servicesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'services' ? servicesGetPayload<S['select'][P]> :  P extends keyof hourly_services ? hourly_services[P] : never
  } 
      : hourly_services


  type hourly_servicesCountArgs = 
    Omit<hourly_servicesFindManyArgs, 'select' | 'include'> & {
      select?: Hourly_servicesCountAggregateInputType | true
    }

  export interface hourly_servicesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Hourly_services that matches the filter.
     * @param {hourly_servicesFindUniqueArgs} args - Arguments to find a Hourly_services
     * @example
     * // Get one Hourly_services
     * const hourly_services = await prisma.hourly_services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends hourly_servicesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, hourly_servicesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'hourly_services'> extends True ? Prisma__hourly_servicesClient<hourly_servicesGetPayload<T>> : Prisma__hourly_servicesClient<hourly_servicesGetPayload<T> | null, null>

    /**
     * Find one Hourly_services that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {hourly_servicesFindUniqueOrThrowArgs} args - Arguments to find a Hourly_services
     * @example
     * // Get one Hourly_services
     * const hourly_services = await prisma.hourly_services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends hourly_servicesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, hourly_servicesFindUniqueOrThrowArgs>
    ): Prisma__hourly_servicesClient<hourly_servicesGetPayload<T>>

    /**
     * Find the first Hourly_services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hourly_servicesFindFirstArgs} args - Arguments to find a Hourly_services
     * @example
     * // Get one Hourly_services
     * const hourly_services = await prisma.hourly_services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends hourly_servicesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, hourly_servicesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'hourly_services'> extends True ? Prisma__hourly_servicesClient<hourly_servicesGetPayload<T>> : Prisma__hourly_servicesClient<hourly_servicesGetPayload<T> | null, null>

    /**
     * Find the first Hourly_services that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hourly_servicesFindFirstOrThrowArgs} args - Arguments to find a Hourly_services
     * @example
     * // Get one Hourly_services
     * const hourly_services = await prisma.hourly_services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends hourly_servicesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, hourly_servicesFindFirstOrThrowArgs>
    ): Prisma__hourly_servicesClient<hourly_servicesGetPayload<T>>

    /**
     * Find zero or more Hourly_services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hourly_servicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hourly_services
     * const hourly_services = await prisma.hourly_services.findMany()
     * 
     * // Get first 10 Hourly_services
     * const hourly_services = await prisma.hourly_services.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hourly_servicesWithIdOnly = await prisma.hourly_services.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends hourly_servicesFindManyArgs>(
      args?: SelectSubset<T, hourly_servicesFindManyArgs>
    ): Prisma.PrismaPromise<Array<hourly_servicesGetPayload<T>>>

    /**
     * Create a Hourly_services.
     * @param {hourly_servicesCreateArgs} args - Arguments to create a Hourly_services.
     * @example
     * // Create one Hourly_services
     * const Hourly_services = await prisma.hourly_services.create({
     *   data: {
     *     // ... data to create a Hourly_services
     *   }
     * })
     * 
    **/
    create<T extends hourly_servicesCreateArgs>(
      args: SelectSubset<T, hourly_servicesCreateArgs>
    ): Prisma__hourly_servicesClient<hourly_servicesGetPayload<T>>

    /**
     * Create many Hourly_services.
     *     @param {hourly_servicesCreateManyArgs} args - Arguments to create many Hourly_services.
     *     @example
     *     // Create many Hourly_services
     *     const hourly_services = await prisma.hourly_services.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends hourly_servicesCreateManyArgs>(
      args?: SelectSubset<T, hourly_servicesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hourly_services.
     * @param {hourly_servicesDeleteArgs} args - Arguments to delete one Hourly_services.
     * @example
     * // Delete one Hourly_services
     * const Hourly_services = await prisma.hourly_services.delete({
     *   where: {
     *     // ... filter to delete one Hourly_services
     *   }
     * })
     * 
    **/
    delete<T extends hourly_servicesDeleteArgs>(
      args: SelectSubset<T, hourly_servicesDeleteArgs>
    ): Prisma__hourly_servicesClient<hourly_servicesGetPayload<T>>

    /**
     * Update one Hourly_services.
     * @param {hourly_servicesUpdateArgs} args - Arguments to update one Hourly_services.
     * @example
     * // Update one Hourly_services
     * const hourly_services = await prisma.hourly_services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends hourly_servicesUpdateArgs>(
      args: SelectSubset<T, hourly_servicesUpdateArgs>
    ): Prisma__hourly_servicesClient<hourly_servicesGetPayload<T>>

    /**
     * Delete zero or more Hourly_services.
     * @param {hourly_servicesDeleteManyArgs} args - Arguments to filter Hourly_services to delete.
     * @example
     * // Delete a few Hourly_services
     * const { count } = await prisma.hourly_services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends hourly_servicesDeleteManyArgs>(
      args?: SelectSubset<T, hourly_servicesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hourly_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hourly_servicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hourly_services
     * const hourly_services = await prisma.hourly_services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends hourly_servicesUpdateManyArgs>(
      args: SelectSubset<T, hourly_servicesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hourly_services.
     * @param {hourly_servicesUpsertArgs} args - Arguments to update or create a Hourly_services.
     * @example
     * // Update or create a Hourly_services
     * const hourly_services = await prisma.hourly_services.upsert({
     *   create: {
     *     // ... data to create a Hourly_services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hourly_services we want to update
     *   }
     * })
    **/
    upsert<T extends hourly_servicesUpsertArgs>(
      args: SelectSubset<T, hourly_servicesUpsertArgs>
    ): Prisma__hourly_servicesClient<hourly_servicesGetPayload<T>>

    /**
     * Count the number of Hourly_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hourly_servicesCountArgs} args - Arguments to filter Hourly_services to count.
     * @example
     * // Count the number of Hourly_services
     * const count = await prisma.hourly_services.count({
     *   where: {
     *     // ... the filter for the Hourly_services we want to count
     *   }
     * })
    **/
    count<T extends hourly_servicesCountArgs>(
      args?: Subset<T, hourly_servicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hourly_servicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hourly_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hourly_servicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hourly_servicesAggregateArgs>(args: Subset<T, Hourly_servicesAggregateArgs>): Prisma.PrismaPromise<GetHourly_servicesAggregateType<T>>

    /**
     * Group by Hourly_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hourly_servicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Hourly_servicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Hourly_servicesGroupByArgs['orderBy'] }
        : { orderBy?: Hourly_servicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Hourly_servicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHourly_servicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for hourly_services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__hourly_servicesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    services<T extends servicesArgs= {}>(args?: Subset<T, servicesArgs>): Prisma__servicesClient<servicesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * hourly_services base type for findUnique actions
   */
  export type hourly_servicesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the hourly_services
     */
    select?: hourly_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hourly_servicesInclude | null
    /**
     * Filter, which hourly_services to fetch.
     */
    where: hourly_servicesWhereUniqueInput
  }

  /**
   * hourly_services findUnique
   */
  export interface hourly_servicesFindUniqueArgs extends hourly_servicesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * hourly_services findUniqueOrThrow
   */
  export type hourly_servicesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the hourly_services
     */
    select?: hourly_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hourly_servicesInclude | null
    /**
     * Filter, which hourly_services to fetch.
     */
    where: hourly_servicesWhereUniqueInput
  }


  /**
   * hourly_services base type for findFirst actions
   */
  export type hourly_servicesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the hourly_services
     */
    select?: hourly_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hourly_servicesInclude | null
    /**
     * Filter, which hourly_services to fetch.
     */
    where?: hourly_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hourly_services to fetch.
     */
    orderBy?: Enumerable<hourly_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hourly_services.
     */
    cursor?: hourly_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hourly_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hourly_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hourly_services.
     */
    distinct?: Enumerable<Hourly_servicesScalarFieldEnum>
  }

  /**
   * hourly_services findFirst
   */
  export interface hourly_servicesFindFirstArgs extends hourly_servicesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * hourly_services findFirstOrThrow
   */
  export type hourly_servicesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the hourly_services
     */
    select?: hourly_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hourly_servicesInclude | null
    /**
     * Filter, which hourly_services to fetch.
     */
    where?: hourly_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hourly_services to fetch.
     */
    orderBy?: Enumerable<hourly_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hourly_services.
     */
    cursor?: hourly_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hourly_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hourly_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hourly_services.
     */
    distinct?: Enumerable<Hourly_servicesScalarFieldEnum>
  }


  /**
   * hourly_services findMany
   */
  export type hourly_servicesFindManyArgs = {
    /**
     * Select specific fields to fetch from the hourly_services
     */
    select?: hourly_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hourly_servicesInclude | null
    /**
     * Filter, which hourly_services to fetch.
     */
    where?: hourly_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hourly_services to fetch.
     */
    orderBy?: Enumerable<hourly_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hourly_services.
     */
    cursor?: hourly_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hourly_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hourly_services.
     */
    skip?: number
    distinct?: Enumerable<Hourly_servicesScalarFieldEnum>
  }


  /**
   * hourly_services create
   */
  export type hourly_servicesCreateArgs = {
    /**
     * Select specific fields to fetch from the hourly_services
     */
    select?: hourly_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hourly_servicesInclude | null
    /**
     * The data needed to create a hourly_services.
     */
    data: XOR<hourly_servicesCreateInput, hourly_servicesUncheckedCreateInput>
  }


  /**
   * hourly_services createMany
   */
  export type hourly_servicesCreateManyArgs = {
    /**
     * The data used to create many hourly_services.
     */
    data: Enumerable<hourly_servicesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * hourly_services update
   */
  export type hourly_servicesUpdateArgs = {
    /**
     * Select specific fields to fetch from the hourly_services
     */
    select?: hourly_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hourly_servicesInclude | null
    /**
     * The data needed to update a hourly_services.
     */
    data: XOR<hourly_servicesUpdateInput, hourly_servicesUncheckedUpdateInput>
    /**
     * Choose, which hourly_services to update.
     */
    where: hourly_servicesWhereUniqueInput
  }


  /**
   * hourly_services updateMany
   */
  export type hourly_servicesUpdateManyArgs = {
    /**
     * The data used to update hourly_services.
     */
    data: XOR<hourly_servicesUpdateManyMutationInput, hourly_servicesUncheckedUpdateManyInput>
    /**
     * Filter which hourly_services to update
     */
    where?: hourly_servicesWhereInput
  }


  /**
   * hourly_services upsert
   */
  export type hourly_servicesUpsertArgs = {
    /**
     * Select specific fields to fetch from the hourly_services
     */
    select?: hourly_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hourly_servicesInclude | null
    /**
     * The filter to search for the hourly_services to update in case it exists.
     */
    where: hourly_servicesWhereUniqueInput
    /**
     * In case the hourly_services found by the `where` argument doesn't exist, create a new hourly_services with this data.
     */
    create: XOR<hourly_servicesCreateInput, hourly_servicesUncheckedCreateInput>
    /**
     * In case the hourly_services was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hourly_servicesUpdateInput, hourly_servicesUncheckedUpdateInput>
  }


  /**
   * hourly_services delete
   */
  export type hourly_servicesDeleteArgs = {
    /**
     * Select specific fields to fetch from the hourly_services
     */
    select?: hourly_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hourly_servicesInclude | null
    /**
     * Filter which hourly_services to delete.
     */
    where: hourly_servicesWhereUniqueInput
  }


  /**
   * hourly_services deleteMany
   */
  export type hourly_servicesDeleteManyArgs = {
    /**
     * Filter which hourly_services to delete
     */
    where?: hourly_servicesWhereInput
  }


  /**
   * hourly_services without action
   */
  export type hourly_servicesArgs = {
    /**
     * Select specific fields to fetch from the hourly_services
     */
    select?: hourly_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hourly_servicesInclude | null
  }



  /**
   * Model locations
   */


  export type AggregateLocations = {
    _count: LocationsCountAggregateOutputType | null
    _avg: LocationsAvgAggregateOutputType | null
    _sum: LocationsSumAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  export type LocationsAvgAggregateOutputType = {
    id: number | null
    fee: number | null
  }

  export type LocationsSumAggregateOutputType = {
    id: number | null
    fee: number | null
  }

  export type LocationsMinAggregateOutputType = {
    id: number | null
    title: string | null
    pickup_location: string | null
    pickup_lat: string | null
    pickup_lng: string | null
    dropoff_location: string | null
    dropoff_lat: string | null
    dropoff_lng: string | null
    fee: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LocationsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    pickup_location: string | null
    pickup_lat: string | null
    pickup_lng: string | null
    dropoff_location: string | null
    dropoff_lat: string | null
    dropoff_lng: string | null
    fee: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LocationsCountAggregateOutputType = {
    id: number
    title: number
    pickup_location: number
    pickup_lat: number
    pickup_lng: number
    dropoff_location: number
    dropoff_lat: number
    dropoff_lng: number
    fee: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type LocationsAvgAggregateInputType = {
    id?: true
    fee?: true
  }

  export type LocationsSumAggregateInputType = {
    id?: true
    fee?: true
  }

  export type LocationsMinAggregateInputType = {
    id?: true
    title?: true
    pickup_location?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_location?: true
    dropoff_lat?: true
    dropoff_lng?: true
    fee?: true
    created_at?: true
    updated_at?: true
  }

  export type LocationsMaxAggregateInputType = {
    id?: true
    title?: true
    pickup_location?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_location?: true
    dropoff_lat?: true
    dropoff_lng?: true
    fee?: true
    created_at?: true
    updated_at?: true
  }

  export type LocationsCountAggregateInputType = {
    id?: true
    title?: true
    pickup_location?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_location?: true
    dropoff_lat?: true
    dropoff_lng?: true
    fee?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type LocationsAggregateArgs = {
    /**
     * Filter which locations to aggregate.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationsMaxAggregateInputType
  }

  export type GetLocationsAggregateType<T extends LocationsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocations[P]>
      : GetScalarType<T[P], AggregateLocations[P]>
  }




  export type LocationsGroupByArgs = {
    where?: locationsWhereInput
    orderBy?: Enumerable<locationsOrderByWithAggregationInput>
    by: LocationsScalarFieldEnum[]
    having?: locationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationsCountAggregateInputType | true
    _avg?: LocationsAvgAggregateInputType
    _sum?: LocationsSumAggregateInputType
    _min?: LocationsMinAggregateInputType
    _max?: LocationsMaxAggregateInputType
  }


  export type LocationsGroupByOutputType = {
    id: number
    title: string | null
    pickup_location: string | null
    pickup_lat: string | null
    pickup_lng: string | null
    dropoff_location: string | null
    dropoff_lat: string | null
    dropoff_lng: string | null
    fee: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: LocationsCountAggregateOutputType | null
    _avg: LocationsAvgAggregateOutputType | null
    _sum: LocationsSumAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  type GetLocationsGroupByPayload<T extends LocationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LocationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationsGroupByOutputType[P]>
            : GetScalarType<T[P], LocationsGroupByOutputType[P]>
        }
      >
    >


  export type locationsSelect = {
    id?: boolean
    title?: boolean
    pickup_location?: boolean
    pickup_lat?: boolean
    pickup_lng?: boolean
    dropoff_location?: boolean
    dropoff_lat?: boolean
    dropoff_lng?: boolean
    fee?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type locationsGetPayload<S extends boolean | null | undefined | locationsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? locations :
    S extends undefined ? never :
    S extends { include: any } & (locationsArgs | locationsFindManyArgs)
    ? locations 
    : S extends { select: any } & (locationsArgs | locationsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof locations ? locations[P] : never
  } 
      : locations


  type locationsCountArgs = 
    Omit<locationsFindManyArgs, 'select' | 'include'> & {
      select?: LocationsCountAggregateInputType | true
    }

  export interface locationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Locations that matches the filter.
     * @param {locationsFindUniqueArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends locationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, locationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'locations'> extends True ? Prisma__locationsClient<locationsGetPayload<T>> : Prisma__locationsClient<locationsGetPayload<T> | null, null>

    /**
     * Find one Locations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {locationsFindUniqueOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends locationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, locationsFindUniqueOrThrowArgs>
    ): Prisma__locationsClient<locationsGetPayload<T>>

    /**
     * Find the first Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindFirstArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends locationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, locationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'locations'> extends True ? Prisma__locationsClient<locationsGetPayload<T>> : Prisma__locationsClient<locationsGetPayload<T> | null, null>

    /**
     * Find the first Locations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindFirstOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends locationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, locationsFindFirstOrThrowArgs>
    ): Prisma__locationsClient<locationsGetPayload<T>>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.locations.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.locations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationsWithIdOnly = await prisma.locations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends locationsFindManyArgs>(
      args?: SelectSubset<T, locationsFindManyArgs>
    ): Prisma.PrismaPromise<Array<locationsGetPayload<T>>>

    /**
     * Create a Locations.
     * @param {locationsCreateArgs} args - Arguments to create a Locations.
     * @example
     * // Create one Locations
     * const Locations = await prisma.locations.create({
     *   data: {
     *     // ... data to create a Locations
     *   }
     * })
     * 
    **/
    create<T extends locationsCreateArgs>(
      args: SelectSubset<T, locationsCreateArgs>
    ): Prisma__locationsClient<locationsGetPayload<T>>

    /**
     * Create many Locations.
     *     @param {locationsCreateManyArgs} args - Arguments to create many Locations.
     *     @example
     *     // Create many Locations
     *     const locations = await prisma.locations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends locationsCreateManyArgs>(
      args?: SelectSubset<T, locationsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Locations.
     * @param {locationsDeleteArgs} args - Arguments to delete one Locations.
     * @example
     * // Delete one Locations
     * const Locations = await prisma.locations.delete({
     *   where: {
     *     // ... filter to delete one Locations
     *   }
     * })
     * 
    **/
    delete<T extends locationsDeleteArgs>(
      args: SelectSubset<T, locationsDeleteArgs>
    ): Prisma__locationsClient<locationsGetPayload<T>>

    /**
     * Update one Locations.
     * @param {locationsUpdateArgs} args - Arguments to update one Locations.
     * @example
     * // Update one Locations
     * const locations = await prisma.locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends locationsUpdateArgs>(
      args: SelectSubset<T, locationsUpdateArgs>
    ): Prisma__locationsClient<locationsGetPayload<T>>

    /**
     * Delete zero or more Locations.
     * @param {locationsDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends locationsDeleteManyArgs>(
      args?: SelectSubset<T, locationsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const locations = await prisma.locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends locationsUpdateManyArgs>(
      args: SelectSubset<T, locationsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Locations.
     * @param {locationsUpsertArgs} args - Arguments to update or create a Locations.
     * @example
     * // Update or create a Locations
     * const locations = await prisma.locations.upsert({
     *   create: {
     *     // ... data to create a Locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Locations we want to update
     *   }
     * })
    **/
    upsert<T extends locationsUpsertArgs>(
      args: SelectSubset<T, locationsUpsertArgs>
    ): Prisma__locationsClient<locationsGetPayload<T>>

    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.locations.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationsCountArgs>(
      args?: Subset<T, locationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationsAggregateArgs>(args: Subset<T, LocationsAggregateArgs>): Prisma.PrismaPromise<GetLocationsAggregateType<T>>

    /**
     * Group by Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationsGroupByArgs['orderBy'] }
        : { orderBy?: LocationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__locationsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * locations base type for findUnique actions
   */
  export type locationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Filter, which locations to fetch.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations findUnique
   */
  export interface locationsFindUniqueArgs extends locationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * locations findUniqueOrThrow
   */
  export type locationsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Filter, which locations to fetch.
     */
    where: locationsWhereUniqueInput
  }


  /**
   * locations base type for findFirst actions
   */
  export type locationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: Enumerable<LocationsScalarFieldEnum>
  }

  /**
   * locations findFirst
   */
  export interface locationsFindFirstArgs extends locationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * locations findFirstOrThrow
   */
  export type locationsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: Enumerable<LocationsScalarFieldEnum>
  }


  /**
   * locations findMany
   */
  export type locationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    distinct?: Enumerable<LocationsScalarFieldEnum>
  }


  /**
   * locations create
   */
  export type locationsCreateArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * The data needed to create a locations.
     */
    data: XOR<locationsCreateInput, locationsUncheckedCreateInput>
  }


  /**
   * locations createMany
   */
  export type locationsCreateManyArgs = {
    /**
     * The data used to create many locations.
     */
    data: Enumerable<locationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * locations update
   */
  export type locationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * The data needed to update a locations.
     */
    data: XOR<locationsUpdateInput, locationsUncheckedUpdateInput>
    /**
     * Choose, which locations to update.
     */
    where: locationsWhereUniqueInput
  }


  /**
   * locations updateMany
   */
  export type locationsUpdateManyArgs = {
    /**
     * The data used to update locations.
     */
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationsWhereInput
  }


  /**
   * locations upsert
   */
  export type locationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * The filter to search for the locations to update in case it exists.
     */
    where: locationsWhereUniqueInput
    /**
     * In case the locations found by the `where` argument doesn't exist, create a new locations with this data.
     */
    create: XOR<locationsCreateInput, locationsUncheckedCreateInput>
    /**
     * In case the locations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<locationsUpdateInput, locationsUncheckedUpdateInput>
  }


  /**
   * locations delete
   */
  export type locationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Filter which locations to delete.
     */
    where: locationsWhereUniqueInput
  }


  /**
   * locations deleteMany
   */
  export type locationsDeleteManyArgs = {
    /**
     * Filter which locations to delete
     */
    where?: locationsWhereInput
  }


  /**
   * locations without action
   */
  export type locationsArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
  }



  /**
   * Model manufacturers
   */


  export type AggregateManufacturers = {
    _count: ManufacturersCountAggregateOutputType | null
    _avg: ManufacturersAvgAggregateOutputType | null
    _sum: ManufacturersSumAggregateOutputType | null
    _min: ManufacturersMinAggregateOutputType | null
    _max: ManufacturersMaxAggregateOutputType | null
  }

  export type ManufacturersAvgAggregateOutputType = {
    id: number | null
  }

  export type ManufacturersSumAggregateOutputType = {
    id: number | null
  }

  export type ManufacturersMinAggregateOutputType = {
    id: number | null
    Manufacturer: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ManufacturersMaxAggregateOutputType = {
    id: number | null
    Manufacturer: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ManufacturersCountAggregateOutputType = {
    id: number
    Manufacturer: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ManufacturersAvgAggregateInputType = {
    id?: true
  }

  export type ManufacturersSumAggregateInputType = {
    id?: true
  }

  export type ManufacturersMinAggregateInputType = {
    id?: true
    Manufacturer?: true
    created_at?: true
    updated_at?: true
  }

  export type ManufacturersMaxAggregateInputType = {
    id?: true
    Manufacturer?: true
    created_at?: true
    updated_at?: true
  }

  export type ManufacturersCountAggregateInputType = {
    id?: true
    Manufacturer?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ManufacturersAggregateArgs = {
    /**
     * Filter which manufacturers to aggregate.
     */
    where?: manufacturersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manufacturers to fetch.
     */
    orderBy?: Enumerable<manufacturersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: manufacturersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned manufacturers
    **/
    _count?: true | ManufacturersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManufacturersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManufacturersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManufacturersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManufacturersMaxAggregateInputType
  }

  export type GetManufacturersAggregateType<T extends ManufacturersAggregateArgs> = {
        [P in keyof T & keyof AggregateManufacturers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManufacturers[P]>
      : GetScalarType<T[P], AggregateManufacturers[P]>
  }




  export type ManufacturersGroupByArgs = {
    where?: manufacturersWhereInput
    orderBy?: Enumerable<manufacturersOrderByWithAggregationInput>
    by: ManufacturersScalarFieldEnum[]
    having?: manufacturersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManufacturersCountAggregateInputType | true
    _avg?: ManufacturersAvgAggregateInputType
    _sum?: ManufacturersSumAggregateInputType
    _min?: ManufacturersMinAggregateInputType
    _max?: ManufacturersMaxAggregateInputType
  }


  export type ManufacturersGroupByOutputType = {
    id: number
    Manufacturer: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: ManufacturersCountAggregateOutputType | null
    _avg: ManufacturersAvgAggregateOutputType | null
    _sum: ManufacturersSumAggregateOutputType | null
    _min: ManufacturersMinAggregateOutputType | null
    _max: ManufacturersMaxAggregateOutputType | null
  }

  type GetManufacturersGroupByPayload<T extends ManufacturersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ManufacturersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManufacturersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManufacturersGroupByOutputType[P]>
            : GetScalarType<T[P], ManufacturersGroupByOutputType[P]>
        }
      >
    >


  export type manufacturersSelect = {
    id?: boolean
    Manufacturer?: boolean
    created_at?: boolean
    updated_at?: boolean
    cars?: boolean | manufacturers$carsArgs
    _count?: boolean | ManufacturersCountOutputTypeArgs
  }


  export type manufacturersInclude = {
    cars?: boolean | manufacturers$carsArgs
    _count?: boolean | ManufacturersCountOutputTypeArgs
  }

  export type manufacturersGetPayload<S extends boolean | null | undefined | manufacturersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? manufacturers :
    S extends undefined ? never :
    S extends { include: any } & (manufacturersArgs | manufacturersFindManyArgs)
    ? manufacturers  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'cars' ? Array < carsGetPayload<S['include'][P]>>  :
        P extends '_count' ? ManufacturersCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (manufacturersArgs | manufacturersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'cars' ? Array < carsGetPayload<S['select'][P]>>  :
        P extends '_count' ? ManufacturersCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof manufacturers ? manufacturers[P] : never
  } 
      : manufacturers


  type manufacturersCountArgs = 
    Omit<manufacturersFindManyArgs, 'select' | 'include'> & {
      select?: ManufacturersCountAggregateInputType | true
    }

  export interface manufacturersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Manufacturers that matches the filter.
     * @param {manufacturersFindUniqueArgs} args - Arguments to find a Manufacturers
     * @example
     * // Get one Manufacturers
     * const manufacturers = await prisma.manufacturers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends manufacturersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, manufacturersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'manufacturers'> extends True ? Prisma__manufacturersClient<manufacturersGetPayload<T>> : Prisma__manufacturersClient<manufacturersGetPayload<T> | null, null>

    /**
     * Find one Manufacturers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {manufacturersFindUniqueOrThrowArgs} args - Arguments to find a Manufacturers
     * @example
     * // Get one Manufacturers
     * const manufacturers = await prisma.manufacturers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends manufacturersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, manufacturersFindUniqueOrThrowArgs>
    ): Prisma__manufacturersClient<manufacturersGetPayload<T>>

    /**
     * Find the first Manufacturers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manufacturersFindFirstArgs} args - Arguments to find a Manufacturers
     * @example
     * // Get one Manufacturers
     * const manufacturers = await prisma.manufacturers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends manufacturersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, manufacturersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'manufacturers'> extends True ? Prisma__manufacturersClient<manufacturersGetPayload<T>> : Prisma__manufacturersClient<manufacturersGetPayload<T> | null, null>

    /**
     * Find the first Manufacturers that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manufacturersFindFirstOrThrowArgs} args - Arguments to find a Manufacturers
     * @example
     * // Get one Manufacturers
     * const manufacturers = await prisma.manufacturers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends manufacturersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, manufacturersFindFirstOrThrowArgs>
    ): Prisma__manufacturersClient<manufacturersGetPayload<T>>

    /**
     * Find zero or more Manufacturers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manufacturersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Manufacturers
     * const manufacturers = await prisma.manufacturers.findMany()
     * 
     * // Get first 10 Manufacturers
     * const manufacturers = await prisma.manufacturers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manufacturersWithIdOnly = await prisma.manufacturers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends manufacturersFindManyArgs>(
      args?: SelectSubset<T, manufacturersFindManyArgs>
    ): Prisma.PrismaPromise<Array<manufacturersGetPayload<T>>>

    /**
     * Create a Manufacturers.
     * @param {manufacturersCreateArgs} args - Arguments to create a Manufacturers.
     * @example
     * // Create one Manufacturers
     * const Manufacturers = await prisma.manufacturers.create({
     *   data: {
     *     // ... data to create a Manufacturers
     *   }
     * })
     * 
    **/
    create<T extends manufacturersCreateArgs>(
      args: SelectSubset<T, manufacturersCreateArgs>
    ): Prisma__manufacturersClient<manufacturersGetPayload<T>>

    /**
     * Create many Manufacturers.
     *     @param {manufacturersCreateManyArgs} args - Arguments to create many Manufacturers.
     *     @example
     *     // Create many Manufacturers
     *     const manufacturers = await prisma.manufacturers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends manufacturersCreateManyArgs>(
      args?: SelectSubset<T, manufacturersCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Manufacturers.
     * @param {manufacturersDeleteArgs} args - Arguments to delete one Manufacturers.
     * @example
     * // Delete one Manufacturers
     * const Manufacturers = await prisma.manufacturers.delete({
     *   where: {
     *     // ... filter to delete one Manufacturers
     *   }
     * })
     * 
    **/
    delete<T extends manufacturersDeleteArgs>(
      args: SelectSubset<T, manufacturersDeleteArgs>
    ): Prisma__manufacturersClient<manufacturersGetPayload<T>>

    /**
     * Update one Manufacturers.
     * @param {manufacturersUpdateArgs} args - Arguments to update one Manufacturers.
     * @example
     * // Update one Manufacturers
     * const manufacturers = await prisma.manufacturers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends manufacturersUpdateArgs>(
      args: SelectSubset<T, manufacturersUpdateArgs>
    ): Prisma__manufacturersClient<manufacturersGetPayload<T>>

    /**
     * Delete zero or more Manufacturers.
     * @param {manufacturersDeleteManyArgs} args - Arguments to filter Manufacturers to delete.
     * @example
     * // Delete a few Manufacturers
     * const { count } = await prisma.manufacturers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends manufacturersDeleteManyArgs>(
      args?: SelectSubset<T, manufacturersDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manufacturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manufacturersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Manufacturers
     * const manufacturers = await prisma.manufacturers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends manufacturersUpdateManyArgs>(
      args: SelectSubset<T, manufacturersUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manufacturers.
     * @param {manufacturersUpsertArgs} args - Arguments to update or create a Manufacturers.
     * @example
     * // Update or create a Manufacturers
     * const manufacturers = await prisma.manufacturers.upsert({
     *   create: {
     *     // ... data to create a Manufacturers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manufacturers we want to update
     *   }
     * })
    **/
    upsert<T extends manufacturersUpsertArgs>(
      args: SelectSubset<T, manufacturersUpsertArgs>
    ): Prisma__manufacturersClient<manufacturersGetPayload<T>>

    /**
     * Count the number of Manufacturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manufacturersCountArgs} args - Arguments to filter Manufacturers to count.
     * @example
     * // Count the number of Manufacturers
     * const count = await prisma.manufacturers.count({
     *   where: {
     *     // ... the filter for the Manufacturers we want to count
     *   }
     * })
    **/
    count<T extends manufacturersCountArgs>(
      args?: Subset<T, manufacturersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManufacturersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manufacturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManufacturersAggregateArgs>(args: Subset<T, ManufacturersAggregateArgs>): Prisma.PrismaPromise<GetManufacturersAggregateType<T>>

    /**
     * Group by Manufacturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManufacturersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManufacturersGroupByArgs['orderBy'] }
        : { orderBy?: ManufacturersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManufacturersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManufacturersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for manufacturers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__manufacturersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cars<T extends manufacturers$carsArgs= {}>(args?: Subset<T, manufacturers$carsArgs>): Prisma.PrismaPromise<Array<carsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * manufacturers base type for findUnique actions
   */
  export type manufacturersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the manufacturers
     */
    select?: manufacturersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manufacturersInclude | null
    /**
     * Filter, which manufacturers to fetch.
     */
    where: manufacturersWhereUniqueInput
  }

  /**
   * manufacturers findUnique
   */
  export interface manufacturersFindUniqueArgs extends manufacturersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * manufacturers findUniqueOrThrow
   */
  export type manufacturersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the manufacturers
     */
    select?: manufacturersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manufacturersInclude | null
    /**
     * Filter, which manufacturers to fetch.
     */
    where: manufacturersWhereUniqueInput
  }


  /**
   * manufacturers base type for findFirst actions
   */
  export type manufacturersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the manufacturers
     */
    select?: manufacturersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manufacturersInclude | null
    /**
     * Filter, which manufacturers to fetch.
     */
    where?: manufacturersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manufacturers to fetch.
     */
    orderBy?: Enumerable<manufacturersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manufacturers.
     */
    cursor?: manufacturersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manufacturers.
     */
    distinct?: Enumerable<ManufacturersScalarFieldEnum>
  }

  /**
   * manufacturers findFirst
   */
  export interface manufacturersFindFirstArgs extends manufacturersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * manufacturers findFirstOrThrow
   */
  export type manufacturersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the manufacturers
     */
    select?: manufacturersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manufacturersInclude | null
    /**
     * Filter, which manufacturers to fetch.
     */
    where?: manufacturersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manufacturers to fetch.
     */
    orderBy?: Enumerable<manufacturersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manufacturers.
     */
    cursor?: manufacturersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manufacturers.
     */
    distinct?: Enumerable<ManufacturersScalarFieldEnum>
  }


  /**
   * manufacturers findMany
   */
  export type manufacturersFindManyArgs = {
    /**
     * Select specific fields to fetch from the manufacturers
     */
    select?: manufacturersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manufacturersInclude | null
    /**
     * Filter, which manufacturers to fetch.
     */
    where?: manufacturersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manufacturers to fetch.
     */
    orderBy?: Enumerable<manufacturersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing manufacturers.
     */
    cursor?: manufacturersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manufacturers.
     */
    skip?: number
    distinct?: Enumerable<ManufacturersScalarFieldEnum>
  }


  /**
   * manufacturers create
   */
  export type manufacturersCreateArgs = {
    /**
     * Select specific fields to fetch from the manufacturers
     */
    select?: manufacturersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manufacturersInclude | null
    /**
     * The data needed to create a manufacturers.
     */
    data: XOR<manufacturersCreateInput, manufacturersUncheckedCreateInput>
  }


  /**
   * manufacturers createMany
   */
  export type manufacturersCreateManyArgs = {
    /**
     * The data used to create many manufacturers.
     */
    data: Enumerable<manufacturersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * manufacturers update
   */
  export type manufacturersUpdateArgs = {
    /**
     * Select specific fields to fetch from the manufacturers
     */
    select?: manufacturersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manufacturersInclude | null
    /**
     * The data needed to update a manufacturers.
     */
    data: XOR<manufacturersUpdateInput, manufacturersUncheckedUpdateInput>
    /**
     * Choose, which manufacturers to update.
     */
    where: manufacturersWhereUniqueInput
  }


  /**
   * manufacturers updateMany
   */
  export type manufacturersUpdateManyArgs = {
    /**
     * The data used to update manufacturers.
     */
    data: XOR<manufacturersUpdateManyMutationInput, manufacturersUncheckedUpdateManyInput>
    /**
     * Filter which manufacturers to update
     */
    where?: manufacturersWhereInput
  }


  /**
   * manufacturers upsert
   */
  export type manufacturersUpsertArgs = {
    /**
     * Select specific fields to fetch from the manufacturers
     */
    select?: manufacturersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manufacturersInclude | null
    /**
     * The filter to search for the manufacturers to update in case it exists.
     */
    where: manufacturersWhereUniqueInput
    /**
     * In case the manufacturers found by the `where` argument doesn't exist, create a new manufacturers with this data.
     */
    create: XOR<manufacturersCreateInput, manufacturersUncheckedCreateInput>
    /**
     * In case the manufacturers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<manufacturersUpdateInput, manufacturersUncheckedUpdateInput>
  }


  /**
   * manufacturers delete
   */
  export type manufacturersDeleteArgs = {
    /**
     * Select specific fields to fetch from the manufacturers
     */
    select?: manufacturersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manufacturersInclude | null
    /**
     * Filter which manufacturers to delete.
     */
    where: manufacturersWhereUniqueInput
  }


  /**
   * manufacturers deleteMany
   */
  export type manufacturersDeleteManyArgs = {
    /**
     * Filter which manufacturers to delete
     */
    where?: manufacturersWhereInput
  }


  /**
   * manufacturers.cars
   */
  export type manufacturers$carsArgs = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    where?: carsWhereInput
    orderBy?: Enumerable<carsOrderByWithRelationInput>
    cursor?: carsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CarsScalarFieldEnum>
  }


  /**
   * manufacturers without action
   */
  export type manufacturersArgs = {
    /**
     * Select specific fields to fetch from the manufacturers
     */
    select?: manufacturersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manufacturersInclude | null
  }



  /**
   * Model migrations
   */


  export type AggregateMigrations = {
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  export type MigrationsAvgAggregateOutputType = {
    id: number | null
    batch: number | null
  }

  export type MigrationsSumAggregateOutputType = {
    id: number | null
    batch: number | null
  }

  export type MigrationsMinAggregateOutputType = {
    id: number | null
    migration: string | null
    batch: number | null
  }

  export type MigrationsMaxAggregateOutputType = {
    id: number | null
    migration: string | null
    batch: number | null
  }

  export type MigrationsCountAggregateOutputType = {
    id: number
    migration: number
    batch: number
    _all: number
  }


  export type MigrationsAvgAggregateInputType = {
    id?: true
    batch?: true
  }

  export type MigrationsSumAggregateInputType = {
    id?: true
    batch?: true
  }

  export type MigrationsMinAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
  }

  export type MigrationsMaxAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
  }

  export type MigrationsCountAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
    _all?: true
  }

  export type MigrationsAggregateArgs = {
    /**
     * Filter which migrations to aggregate.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: Enumerable<migrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned migrations
    **/
    _count?: true | MigrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MigrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MigrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationsMaxAggregateInputType
  }

  export type GetMigrationsAggregateType<T extends MigrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMigrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigrations[P]>
      : GetScalarType<T[P], AggregateMigrations[P]>
  }




  export type MigrationsGroupByArgs = {
    where?: migrationsWhereInput
    orderBy?: Enumerable<migrationsOrderByWithAggregationInput>
    by: MigrationsScalarFieldEnum[]
    having?: migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationsCountAggregateInputType | true
    _avg?: MigrationsAvgAggregateInputType
    _sum?: MigrationsSumAggregateInputType
    _min?: MigrationsMinAggregateInputType
    _max?: MigrationsMaxAggregateInputType
  }


  export type MigrationsGroupByOutputType = {
    id: number
    migration: string
    batch: number
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  type GetMigrationsGroupByPayload<T extends MigrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MigrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
        }
      >
    >


  export type migrationsSelect = {
    id?: boolean
    migration?: boolean
    batch?: boolean
  }


  export type migrationsGetPayload<S extends boolean | null | undefined | migrationsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? migrations :
    S extends undefined ? never :
    S extends { include: any } & (migrationsArgs | migrationsFindManyArgs)
    ? migrations 
    : S extends { select: any } & (migrationsArgs | migrationsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof migrations ? migrations[P] : never
  } 
      : migrations


  type migrationsCountArgs = 
    Omit<migrationsFindManyArgs, 'select' | 'include'> & {
      select?: MigrationsCountAggregateInputType | true
    }

  export interface migrationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Migrations that matches the filter.
     * @param {migrationsFindUniqueArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends migrationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, migrationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'migrations'> extends True ? Prisma__migrationsClient<migrationsGetPayload<T>> : Prisma__migrationsClient<migrationsGetPayload<T> | null, null>

    /**
     * Find one Migrations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {migrationsFindUniqueOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends migrationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, migrationsFindUniqueOrThrowArgs>
    ): Prisma__migrationsClient<migrationsGetPayload<T>>

    /**
     * Find the first Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends migrationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, migrationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'migrations'> extends True ? Prisma__migrationsClient<migrationsGetPayload<T>> : Prisma__migrationsClient<migrationsGetPayload<T> | null, null>

    /**
     * Find the first Migrations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends migrationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, migrationsFindFirstOrThrowArgs>
    ): Prisma__migrationsClient<migrationsGetPayload<T>>

    /**
     * Find zero or more Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migrations
     * const migrations = await prisma.migrations.findMany()
     * 
     * // Get first 10 Migrations
     * const migrations = await prisma.migrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migrationsWithIdOnly = await prisma.migrations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends migrationsFindManyArgs>(
      args?: SelectSubset<T, migrationsFindManyArgs>
    ): Prisma.PrismaPromise<Array<migrationsGetPayload<T>>>

    /**
     * Create a Migrations.
     * @param {migrationsCreateArgs} args - Arguments to create a Migrations.
     * @example
     * // Create one Migrations
     * const Migrations = await prisma.migrations.create({
     *   data: {
     *     // ... data to create a Migrations
     *   }
     * })
     * 
    **/
    create<T extends migrationsCreateArgs>(
      args: SelectSubset<T, migrationsCreateArgs>
    ): Prisma__migrationsClient<migrationsGetPayload<T>>

    /**
     * Create many Migrations.
     *     @param {migrationsCreateManyArgs} args - Arguments to create many Migrations.
     *     @example
     *     // Create many Migrations
     *     const migrations = await prisma.migrations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends migrationsCreateManyArgs>(
      args?: SelectSubset<T, migrationsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Migrations.
     * @param {migrationsDeleteArgs} args - Arguments to delete one Migrations.
     * @example
     * // Delete one Migrations
     * const Migrations = await prisma.migrations.delete({
     *   where: {
     *     // ... filter to delete one Migrations
     *   }
     * })
     * 
    **/
    delete<T extends migrationsDeleteArgs>(
      args: SelectSubset<T, migrationsDeleteArgs>
    ): Prisma__migrationsClient<migrationsGetPayload<T>>

    /**
     * Update one Migrations.
     * @param {migrationsUpdateArgs} args - Arguments to update one Migrations.
     * @example
     * // Update one Migrations
     * const migrations = await prisma.migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends migrationsUpdateArgs>(
      args: SelectSubset<T, migrationsUpdateArgs>
    ): Prisma__migrationsClient<migrationsGetPayload<T>>

    /**
     * Delete zero or more Migrations.
     * @param {migrationsDeleteManyArgs} args - Arguments to filter Migrations to delete.
     * @example
     * // Delete a few Migrations
     * const { count } = await prisma.migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends migrationsDeleteManyArgs>(
      args?: SelectSubset<T, migrationsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends migrationsUpdateManyArgs>(
      args: SelectSubset<T, migrationsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Migrations.
     * @param {migrationsUpsertArgs} args - Arguments to update or create a Migrations.
     * @example
     * // Update or create a Migrations
     * const migrations = await prisma.migrations.upsert({
     *   create: {
     *     // ... data to create a Migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migrations we want to update
     *   }
     * })
    **/
    upsert<T extends migrationsUpsertArgs>(
      args: SelectSubset<T, migrationsUpsertArgs>
    ): Prisma__migrationsClient<migrationsGetPayload<T>>

    /**
     * Count the number of Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsCountArgs} args - Arguments to filter Migrations to count.
     * @example
     * // Count the number of Migrations
     * const count = await prisma.migrations.count({
     *   where: {
     *     // ... the filter for the Migrations we want to count
     *   }
     * })
    **/
    count<T extends migrationsCountArgs>(
      args?: Subset<T, migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationsAggregateArgs>(args: Subset<T, MigrationsAggregateArgs>): Prisma.PrismaPromise<GetMigrationsAggregateType<T>>

    /**
     * Group by Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MigrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MigrationsGroupByArgs['orderBy'] }
        : { orderBy?: MigrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MigrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__migrationsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * migrations base type for findUnique actions
   */
  export type migrationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findUnique
   */
  export interface migrationsFindUniqueArgs extends migrationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * migrations findUniqueOrThrow
   */
  export type migrationsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }


  /**
   * migrations base type for findFirst actions
   */
  export type migrationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: Enumerable<migrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: Enumerable<MigrationsScalarFieldEnum>
  }

  /**
   * migrations findFirst
   */
  export interface migrationsFindFirstArgs extends migrationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * migrations findFirstOrThrow
   */
  export type migrationsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: Enumerable<migrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: Enumerable<MigrationsScalarFieldEnum>
  }


  /**
   * migrations findMany
   */
  export type migrationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: Enumerable<migrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    distinct?: Enumerable<MigrationsScalarFieldEnum>
  }


  /**
   * migrations create
   */
  export type migrationsCreateArgs = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect | null
    /**
     * The data needed to create a migrations.
     */
    data: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
  }


  /**
   * migrations createMany
   */
  export type migrationsCreateManyArgs = {
    /**
     * The data used to create many migrations.
     */
    data: Enumerable<migrationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * migrations update
   */
  export type migrationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect | null
    /**
     * The data needed to update a migrations.
     */
    data: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
    /**
     * Choose, which migrations to update.
     */
    where: migrationsWhereUniqueInput
  }


  /**
   * migrations updateMany
   */
  export type migrationsUpdateManyArgs = {
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
  }


  /**
   * migrations upsert
   */
  export type migrationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect | null
    /**
     * The filter to search for the migrations to update in case it exists.
     */
    where: migrationsWhereUniqueInput
    /**
     * In case the migrations found by the `where` argument doesn't exist, create a new migrations with this data.
     */
    create: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
    /**
     * In case the migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
  }


  /**
   * migrations delete
   */
  export type migrationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect | null
    /**
     * Filter which migrations to delete.
     */
    where: migrationsWhereUniqueInput
  }


  /**
   * migrations deleteMany
   */
  export type migrationsDeleteManyArgs = {
    /**
     * Filter which migrations to delete
     */
    where?: migrationsWhereInput
  }


  /**
   * migrations without action
   */
  export type migrationsArgs = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect | null
  }



  /**
   * Model package_types
   */


  export type AggregatePackage_types = {
    _count: Package_typesCountAggregateOutputType | null
    _avg: Package_typesAvgAggregateOutputType | null
    _sum: Package_typesSumAggregateOutputType | null
    _min: Package_typesMinAggregateOutputType | null
    _max: Package_typesMaxAggregateOutputType | null
  }

  export type Package_typesAvgAggregateOutputType = {
    id: number | null
  }

  export type Package_typesSumAggregateOutputType = {
    id: number | null
  }

  export type Package_typesMinAggregateOutputType = {
    id: number | null
    name: string | null
    password: string | null
    Created_on: Date | null
  }

  export type Package_typesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    password: string | null
    Created_on: Date | null
  }

  export type Package_typesCountAggregateOutputType = {
    id: number
    name: number
    password: number
    Created_on: number
    _all: number
  }


  export type Package_typesAvgAggregateInputType = {
    id?: true
  }

  export type Package_typesSumAggregateInputType = {
    id?: true
  }

  export type Package_typesMinAggregateInputType = {
    id?: true
    name?: true
    password?: true
    Created_on?: true
  }

  export type Package_typesMaxAggregateInputType = {
    id?: true
    name?: true
    password?: true
    Created_on?: true
  }

  export type Package_typesCountAggregateInputType = {
    id?: true
    name?: true
    password?: true
    Created_on?: true
    _all?: true
  }

  export type Package_typesAggregateArgs = {
    /**
     * Filter which package_types to aggregate.
     */
    where?: package_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_types to fetch.
     */
    orderBy?: Enumerable<package_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: package_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned package_types
    **/
    _count?: true | Package_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Package_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Package_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Package_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Package_typesMaxAggregateInputType
  }

  export type GetPackage_typesAggregateType<T extends Package_typesAggregateArgs> = {
        [P in keyof T & keyof AggregatePackage_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackage_types[P]>
      : GetScalarType<T[P], AggregatePackage_types[P]>
  }




  export type Package_typesGroupByArgs = {
    where?: package_typesWhereInput
    orderBy?: Enumerable<package_typesOrderByWithAggregationInput>
    by: Package_typesScalarFieldEnum[]
    having?: package_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Package_typesCountAggregateInputType | true
    _avg?: Package_typesAvgAggregateInputType
    _sum?: Package_typesSumAggregateInputType
    _min?: Package_typesMinAggregateInputType
    _max?: Package_typesMaxAggregateInputType
  }


  export type Package_typesGroupByOutputType = {
    id: number
    name: string
    password: string
    Created_on: Date
    _count: Package_typesCountAggregateOutputType | null
    _avg: Package_typesAvgAggregateOutputType | null
    _sum: Package_typesSumAggregateOutputType | null
    _min: Package_typesMinAggregateOutputType | null
    _max: Package_typesMaxAggregateOutputType | null
  }

  type GetPackage_typesGroupByPayload<T extends Package_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Package_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Package_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Package_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Package_typesGroupByOutputType[P]>
        }
      >
    >


  export type package_typesSelect = {
    id?: boolean
    name?: boolean
    password?: boolean
    Created_on?: boolean
  }


  export type package_typesGetPayload<S extends boolean | null | undefined | package_typesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? package_types :
    S extends undefined ? never :
    S extends { include: any } & (package_typesArgs | package_typesFindManyArgs)
    ? package_types 
    : S extends { select: any } & (package_typesArgs | package_typesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof package_types ? package_types[P] : never
  } 
      : package_types


  type package_typesCountArgs = 
    Omit<package_typesFindManyArgs, 'select' | 'include'> & {
      select?: Package_typesCountAggregateInputType | true
    }

  export interface package_typesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Package_types that matches the filter.
     * @param {package_typesFindUniqueArgs} args - Arguments to find a Package_types
     * @example
     * // Get one Package_types
     * const package_types = await prisma.package_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends package_typesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, package_typesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'package_types'> extends True ? Prisma__package_typesClient<package_typesGetPayload<T>> : Prisma__package_typesClient<package_typesGetPayload<T> | null, null>

    /**
     * Find one Package_types that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {package_typesFindUniqueOrThrowArgs} args - Arguments to find a Package_types
     * @example
     * // Get one Package_types
     * const package_types = await prisma.package_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends package_typesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, package_typesFindUniqueOrThrowArgs>
    ): Prisma__package_typesClient<package_typesGetPayload<T>>

    /**
     * Find the first Package_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_typesFindFirstArgs} args - Arguments to find a Package_types
     * @example
     * // Get one Package_types
     * const package_types = await prisma.package_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends package_typesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, package_typesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'package_types'> extends True ? Prisma__package_typesClient<package_typesGetPayload<T>> : Prisma__package_typesClient<package_typesGetPayload<T> | null, null>

    /**
     * Find the first Package_types that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_typesFindFirstOrThrowArgs} args - Arguments to find a Package_types
     * @example
     * // Get one Package_types
     * const package_types = await prisma.package_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends package_typesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, package_typesFindFirstOrThrowArgs>
    ): Prisma__package_typesClient<package_typesGetPayload<T>>

    /**
     * Find zero or more Package_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_typesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Package_types
     * const package_types = await prisma.package_types.findMany()
     * 
     * // Get first 10 Package_types
     * const package_types = await prisma.package_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const package_typesWithIdOnly = await prisma.package_types.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends package_typesFindManyArgs>(
      args?: SelectSubset<T, package_typesFindManyArgs>
    ): Prisma.PrismaPromise<Array<package_typesGetPayload<T>>>

    /**
     * Create a Package_types.
     * @param {package_typesCreateArgs} args - Arguments to create a Package_types.
     * @example
     * // Create one Package_types
     * const Package_types = await prisma.package_types.create({
     *   data: {
     *     // ... data to create a Package_types
     *   }
     * })
     * 
    **/
    create<T extends package_typesCreateArgs>(
      args: SelectSubset<T, package_typesCreateArgs>
    ): Prisma__package_typesClient<package_typesGetPayload<T>>

    /**
     * Create many Package_types.
     *     @param {package_typesCreateManyArgs} args - Arguments to create many Package_types.
     *     @example
     *     // Create many Package_types
     *     const package_types = await prisma.package_types.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends package_typesCreateManyArgs>(
      args?: SelectSubset<T, package_typesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Package_types.
     * @param {package_typesDeleteArgs} args - Arguments to delete one Package_types.
     * @example
     * // Delete one Package_types
     * const Package_types = await prisma.package_types.delete({
     *   where: {
     *     // ... filter to delete one Package_types
     *   }
     * })
     * 
    **/
    delete<T extends package_typesDeleteArgs>(
      args: SelectSubset<T, package_typesDeleteArgs>
    ): Prisma__package_typesClient<package_typesGetPayload<T>>

    /**
     * Update one Package_types.
     * @param {package_typesUpdateArgs} args - Arguments to update one Package_types.
     * @example
     * // Update one Package_types
     * const package_types = await prisma.package_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends package_typesUpdateArgs>(
      args: SelectSubset<T, package_typesUpdateArgs>
    ): Prisma__package_typesClient<package_typesGetPayload<T>>

    /**
     * Delete zero or more Package_types.
     * @param {package_typesDeleteManyArgs} args - Arguments to filter Package_types to delete.
     * @example
     * // Delete a few Package_types
     * const { count } = await prisma.package_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends package_typesDeleteManyArgs>(
      args?: SelectSubset<T, package_typesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Package_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Package_types
     * const package_types = await prisma.package_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends package_typesUpdateManyArgs>(
      args: SelectSubset<T, package_typesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Package_types.
     * @param {package_typesUpsertArgs} args - Arguments to update or create a Package_types.
     * @example
     * // Update or create a Package_types
     * const package_types = await prisma.package_types.upsert({
     *   create: {
     *     // ... data to create a Package_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Package_types we want to update
     *   }
     * })
    **/
    upsert<T extends package_typesUpsertArgs>(
      args: SelectSubset<T, package_typesUpsertArgs>
    ): Prisma__package_typesClient<package_typesGetPayload<T>>

    /**
     * Count the number of Package_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_typesCountArgs} args - Arguments to filter Package_types to count.
     * @example
     * // Count the number of Package_types
     * const count = await prisma.package_types.count({
     *   where: {
     *     // ... the filter for the Package_types we want to count
     *   }
     * })
    **/
    count<T extends package_typesCountArgs>(
      args?: Subset<T, package_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Package_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Package_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Package_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Package_typesAggregateArgs>(args: Subset<T, Package_typesAggregateArgs>): Prisma.PrismaPromise<GetPackage_typesAggregateType<T>>

    /**
     * Group by Package_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Package_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Package_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Package_typesGroupByArgs['orderBy'] }
        : { orderBy?: Package_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Package_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackage_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for package_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__package_typesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * package_types base type for findUnique actions
   */
  export type package_typesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the package_types
     */
    select?: package_typesSelect | null
    /**
     * Filter, which package_types to fetch.
     */
    where: package_typesWhereUniqueInput
  }

  /**
   * package_types findUnique
   */
  export interface package_typesFindUniqueArgs extends package_typesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * package_types findUniqueOrThrow
   */
  export type package_typesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the package_types
     */
    select?: package_typesSelect | null
    /**
     * Filter, which package_types to fetch.
     */
    where: package_typesWhereUniqueInput
  }


  /**
   * package_types base type for findFirst actions
   */
  export type package_typesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the package_types
     */
    select?: package_typesSelect | null
    /**
     * Filter, which package_types to fetch.
     */
    where?: package_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_types to fetch.
     */
    orderBy?: Enumerable<package_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for package_types.
     */
    cursor?: package_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of package_types.
     */
    distinct?: Enumerable<Package_typesScalarFieldEnum>
  }

  /**
   * package_types findFirst
   */
  export interface package_typesFindFirstArgs extends package_typesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * package_types findFirstOrThrow
   */
  export type package_typesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the package_types
     */
    select?: package_typesSelect | null
    /**
     * Filter, which package_types to fetch.
     */
    where?: package_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_types to fetch.
     */
    orderBy?: Enumerable<package_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for package_types.
     */
    cursor?: package_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of package_types.
     */
    distinct?: Enumerable<Package_typesScalarFieldEnum>
  }


  /**
   * package_types findMany
   */
  export type package_typesFindManyArgs = {
    /**
     * Select specific fields to fetch from the package_types
     */
    select?: package_typesSelect | null
    /**
     * Filter, which package_types to fetch.
     */
    where?: package_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_types to fetch.
     */
    orderBy?: Enumerable<package_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing package_types.
     */
    cursor?: package_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_types.
     */
    skip?: number
    distinct?: Enumerable<Package_typesScalarFieldEnum>
  }


  /**
   * package_types create
   */
  export type package_typesCreateArgs = {
    /**
     * Select specific fields to fetch from the package_types
     */
    select?: package_typesSelect | null
    /**
     * The data needed to create a package_types.
     */
    data: XOR<package_typesCreateInput, package_typesUncheckedCreateInput>
  }


  /**
   * package_types createMany
   */
  export type package_typesCreateManyArgs = {
    /**
     * The data used to create many package_types.
     */
    data: Enumerable<package_typesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * package_types update
   */
  export type package_typesUpdateArgs = {
    /**
     * Select specific fields to fetch from the package_types
     */
    select?: package_typesSelect | null
    /**
     * The data needed to update a package_types.
     */
    data: XOR<package_typesUpdateInput, package_typesUncheckedUpdateInput>
    /**
     * Choose, which package_types to update.
     */
    where: package_typesWhereUniqueInput
  }


  /**
   * package_types updateMany
   */
  export type package_typesUpdateManyArgs = {
    /**
     * The data used to update package_types.
     */
    data: XOR<package_typesUpdateManyMutationInput, package_typesUncheckedUpdateManyInput>
    /**
     * Filter which package_types to update
     */
    where?: package_typesWhereInput
  }


  /**
   * package_types upsert
   */
  export type package_typesUpsertArgs = {
    /**
     * Select specific fields to fetch from the package_types
     */
    select?: package_typesSelect | null
    /**
     * The filter to search for the package_types to update in case it exists.
     */
    where: package_typesWhereUniqueInput
    /**
     * In case the package_types found by the `where` argument doesn't exist, create a new package_types with this data.
     */
    create: XOR<package_typesCreateInput, package_typesUncheckedCreateInput>
    /**
     * In case the package_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<package_typesUpdateInput, package_typesUncheckedUpdateInput>
  }


  /**
   * package_types delete
   */
  export type package_typesDeleteArgs = {
    /**
     * Select specific fields to fetch from the package_types
     */
    select?: package_typesSelect | null
    /**
     * Filter which package_types to delete.
     */
    where: package_typesWhereUniqueInput
  }


  /**
   * package_types deleteMany
   */
  export type package_typesDeleteManyArgs = {
    /**
     * Filter which package_types to delete
     */
    where?: package_typesWhereInput
  }


  /**
   * package_types without action
   */
  export type package_typesArgs = {
    /**
     * Select specific fields to fetch from the package_types
     */
    select?: package_typesSelect | null
  }



  /**
   * Model persistences
   */


  export type AggregatePersistences = {
    _count: PersistencesCountAggregateOutputType | null
    _avg: PersistencesAvgAggregateOutputType | null
    _sum: PersistencesSumAggregateOutputType | null
    _min: PersistencesMinAggregateOutputType | null
    _max: PersistencesMaxAggregateOutputType | null
  }

  export type PersistencesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type PersistencesSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type PersistencesMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    code: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PersistencesMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    code: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PersistencesCountAggregateOutputType = {
    id: number
    user_id: number
    code: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PersistencesAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type PersistencesSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type PersistencesMinAggregateInputType = {
    id?: true
    user_id?: true
    code?: true
    created_at?: true
    updated_at?: true
  }

  export type PersistencesMaxAggregateInputType = {
    id?: true
    user_id?: true
    code?: true
    created_at?: true
    updated_at?: true
  }

  export type PersistencesCountAggregateInputType = {
    id?: true
    user_id?: true
    code?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PersistencesAggregateArgs = {
    /**
     * Filter which persistences to aggregate.
     */
    where?: persistencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of persistences to fetch.
     */
    orderBy?: Enumerable<persistencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: persistencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` persistences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` persistences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned persistences
    **/
    _count?: true | PersistencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersistencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersistencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersistencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersistencesMaxAggregateInputType
  }

  export type GetPersistencesAggregateType<T extends PersistencesAggregateArgs> = {
        [P in keyof T & keyof AggregatePersistences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersistences[P]>
      : GetScalarType<T[P], AggregatePersistences[P]>
  }




  export type PersistencesGroupByArgs = {
    where?: persistencesWhereInput
    orderBy?: Enumerable<persistencesOrderByWithAggregationInput>
    by: PersistencesScalarFieldEnum[]
    having?: persistencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersistencesCountAggregateInputType | true
    _avg?: PersistencesAvgAggregateInputType
    _sum?: PersistencesSumAggregateInputType
    _min?: PersistencesMinAggregateInputType
    _max?: PersistencesMaxAggregateInputType
  }


  export type PersistencesGroupByOutputType = {
    id: number
    user_id: number
    code: string
    created_at: Date | null
    updated_at: Date | null
    _count: PersistencesCountAggregateOutputType | null
    _avg: PersistencesAvgAggregateOutputType | null
    _sum: PersistencesSumAggregateOutputType | null
    _min: PersistencesMinAggregateOutputType | null
    _max: PersistencesMaxAggregateOutputType | null
  }

  type GetPersistencesGroupByPayload<T extends PersistencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PersistencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersistencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersistencesGroupByOutputType[P]>
            : GetScalarType<T[P], PersistencesGroupByOutputType[P]>
        }
      >
    >


  export type persistencesSelect = {
    id?: boolean
    user_id?: boolean
    code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type persistencesGetPayload<S extends boolean | null | undefined | persistencesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? persistences :
    S extends undefined ? never :
    S extends { include: any } & (persistencesArgs | persistencesFindManyArgs)
    ? persistences 
    : S extends { select: any } & (persistencesArgs | persistencesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof persistences ? persistences[P] : never
  } 
      : persistences


  type persistencesCountArgs = 
    Omit<persistencesFindManyArgs, 'select' | 'include'> & {
      select?: PersistencesCountAggregateInputType | true
    }

  export interface persistencesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Persistences that matches the filter.
     * @param {persistencesFindUniqueArgs} args - Arguments to find a Persistences
     * @example
     * // Get one Persistences
     * const persistences = await prisma.persistences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends persistencesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, persistencesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'persistences'> extends True ? Prisma__persistencesClient<persistencesGetPayload<T>> : Prisma__persistencesClient<persistencesGetPayload<T> | null, null>

    /**
     * Find one Persistences that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {persistencesFindUniqueOrThrowArgs} args - Arguments to find a Persistences
     * @example
     * // Get one Persistences
     * const persistences = await prisma.persistences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends persistencesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, persistencesFindUniqueOrThrowArgs>
    ): Prisma__persistencesClient<persistencesGetPayload<T>>

    /**
     * Find the first Persistences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {persistencesFindFirstArgs} args - Arguments to find a Persistences
     * @example
     * // Get one Persistences
     * const persistences = await prisma.persistences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends persistencesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, persistencesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'persistences'> extends True ? Prisma__persistencesClient<persistencesGetPayload<T>> : Prisma__persistencesClient<persistencesGetPayload<T> | null, null>

    /**
     * Find the first Persistences that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {persistencesFindFirstOrThrowArgs} args - Arguments to find a Persistences
     * @example
     * // Get one Persistences
     * const persistences = await prisma.persistences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends persistencesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, persistencesFindFirstOrThrowArgs>
    ): Prisma__persistencesClient<persistencesGetPayload<T>>

    /**
     * Find zero or more Persistences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {persistencesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Persistences
     * const persistences = await prisma.persistences.findMany()
     * 
     * // Get first 10 Persistences
     * const persistences = await prisma.persistences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const persistencesWithIdOnly = await prisma.persistences.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends persistencesFindManyArgs>(
      args?: SelectSubset<T, persistencesFindManyArgs>
    ): Prisma.PrismaPromise<Array<persistencesGetPayload<T>>>

    /**
     * Create a Persistences.
     * @param {persistencesCreateArgs} args - Arguments to create a Persistences.
     * @example
     * // Create one Persistences
     * const Persistences = await prisma.persistences.create({
     *   data: {
     *     // ... data to create a Persistences
     *   }
     * })
     * 
    **/
    create<T extends persistencesCreateArgs>(
      args: SelectSubset<T, persistencesCreateArgs>
    ): Prisma__persistencesClient<persistencesGetPayload<T>>

    /**
     * Create many Persistences.
     *     @param {persistencesCreateManyArgs} args - Arguments to create many Persistences.
     *     @example
     *     // Create many Persistences
     *     const persistences = await prisma.persistences.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends persistencesCreateManyArgs>(
      args?: SelectSubset<T, persistencesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Persistences.
     * @param {persistencesDeleteArgs} args - Arguments to delete one Persistences.
     * @example
     * // Delete one Persistences
     * const Persistences = await prisma.persistences.delete({
     *   where: {
     *     // ... filter to delete one Persistences
     *   }
     * })
     * 
    **/
    delete<T extends persistencesDeleteArgs>(
      args: SelectSubset<T, persistencesDeleteArgs>
    ): Prisma__persistencesClient<persistencesGetPayload<T>>

    /**
     * Update one Persistences.
     * @param {persistencesUpdateArgs} args - Arguments to update one Persistences.
     * @example
     * // Update one Persistences
     * const persistences = await prisma.persistences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends persistencesUpdateArgs>(
      args: SelectSubset<T, persistencesUpdateArgs>
    ): Prisma__persistencesClient<persistencesGetPayload<T>>

    /**
     * Delete zero or more Persistences.
     * @param {persistencesDeleteManyArgs} args - Arguments to filter Persistences to delete.
     * @example
     * // Delete a few Persistences
     * const { count } = await prisma.persistences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends persistencesDeleteManyArgs>(
      args?: SelectSubset<T, persistencesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Persistences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {persistencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Persistences
     * const persistences = await prisma.persistences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends persistencesUpdateManyArgs>(
      args: SelectSubset<T, persistencesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Persistences.
     * @param {persistencesUpsertArgs} args - Arguments to update or create a Persistences.
     * @example
     * // Update or create a Persistences
     * const persistences = await prisma.persistences.upsert({
     *   create: {
     *     // ... data to create a Persistences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Persistences we want to update
     *   }
     * })
    **/
    upsert<T extends persistencesUpsertArgs>(
      args: SelectSubset<T, persistencesUpsertArgs>
    ): Prisma__persistencesClient<persistencesGetPayload<T>>

    /**
     * Count the number of Persistences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {persistencesCountArgs} args - Arguments to filter Persistences to count.
     * @example
     * // Count the number of Persistences
     * const count = await prisma.persistences.count({
     *   where: {
     *     // ... the filter for the Persistences we want to count
     *   }
     * })
    **/
    count<T extends persistencesCountArgs>(
      args?: Subset<T, persistencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersistencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Persistences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersistencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersistencesAggregateArgs>(args: Subset<T, PersistencesAggregateArgs>): Prisma.PrismaPromise<GetPersistencesAggregateType<T>>

    /**
     * Group by Persistences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersistencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersistencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersistencesGroupByArgs['orderBy'] }
        : { orderBy?: PersistencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersistencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersistencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for persistences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__persistencesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * persistences base type for findUnique actions
   */
  export type persistencesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the persistences
     */
    select?: persistencesSelect | null
    /**
     * Filter, which persistences to fetch.
     */
    where: persistencesWhereUniqueInput
  }

  /**
   * persistences findUnique
   */
  export interface persistencesFindUniqueArgs extends persistencesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * persistences findUniqueOrThrow
   */
  export type persistencesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the persistences
     */
    select?: persistencesSelect | null
    /**
     * Filter, which persistences to fetch.
     */
    where: persistencesWhereUniqueInput
  }


  /**
   * persistences base type for findFirst actions
   */
  export type persistencesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the persistences
     */
    select?: persistencesSelect | null
    /**
     * Filter, which persistences to fetch.
     */
    where?: persistencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of persistences to fetch.
     */
    orderBy?: Enumerable<persistencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for persistences.
     */
    cursor?: persistencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` persistences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` persistences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of persistences.
     */
    distinct?: Enumerable<PersistencesScalarFieldEnum>
  }

  /**
   * persistences findFirst
   */
  export interface persistencesFindFirstArgs extends persistencesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * persistences findFirstOrThrow
   */
  export type persistencesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the persistences
     */
    select?: persistencesSelect | null
    /**
     * Filter, which persistences to fetch.
     */
    where?: persistencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of persistences to fetch.
     */
    orderBy?: Enumerable<persistencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for persistences.
     */
    cursor?: persistencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` persistences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` persistences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of persistences.
     */
    distinct?: Enumerable<PersistencesScalarFieldEnum>
  }


  /**
   * persistences findMany
   */
  export type persistencesFindManyArgs = {
    /**
     * Select specific fields to fetch from the persistences
     */
    select?: persistencesSelect | null
    /**
     * Filter, which persistences to fetch.
     */
    where?: persistencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of persistences to fetch.
     */
    orderBy?: Enumerable<persistencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing persistences.
     */
    cursor?: persistencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` persistences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` persistences.
     */
    skip?: number
    distinct?: Enumerable<PersistencesScalarFieldEnum>
  }


  /**
   * persistences create
   */
  export type persistencesCreateArgs = {
    /**
     * Select specific fields to fetch from the persistences
     */
    select?: persistencesSelect | null
    /**
     * The data needed to create a persistences.
     */
    data: XOR<persistencesCreateInput, persistencesUncheckedCreateInput>
  }


  /**
   * persistences createMany
   */
  export type persistencesCreateManyArgs = {
    /**
     * The data used to create many persistences.
     */
    data: Enumerable<persistencesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * persistences update
   */
  export type persistencesUpdateArgs = {
    /**
     * Select specific fields to fetch from the persistences
     */
    select?: persistencesSelect | null
    /**
     * The data needed to update a persistences.
     */
    data: XOR<persistencesUpdateInput, persistencesUncheckedUpdateInput>
    /**
     * Choose, which persistences to update.
     */
    where: persistencesWhereUniqueInput
  }


  /**
   * persistences updateMany
   */
  export type persistencesUpdateManyArgs = {
    /**
     * The data used to update persistences.
     */
    data: XOR<persistencesUpdateManyMutationInput, persistencesUncheckedUpdateManyInput>
    /**
     * Filter which persistences to update
     */
    where?: persistencesWhereInput
  }


  /**
   * persistences upsert
   */
  export type persistencesUpsertArgs = {
    /**
     * Select specific fields to fetch from the persistences
     */
    select?: persistencesSelect | null
    /**
     * The filter to search for the persistences to update in case it exists.
     */
    where: persistencesWhereUniqueInput
    /**
     * In case the persistences found by the `where` argument doesn't exist, create a new persistences with this data.
     */
    create: XOR<persistencesCreateInput, persistencesUncheckedCreateInput>
    /**
     * In case the persistences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<persistencesUpdateInput, persistencesUncheckedUpdateInput>
  }


  /**
   * persistences delete
   */
  export type persistencesDeleteArgs = {
    /**
     * Select specific fields to fetch from the persistences
     */
    select?: persistencesSelect | null
    /**
     * Filter which persistences to delete.
     */
    where: persistencesWhereUniqueInput
  }


  /**
   * persistences deleteMany
   */
  export type persistencesDeleteManyArgs = {
    /**
     * Filter which persistences to delete
     */
    where?: persistencesWhereInput
  }


  /**
   * persistences without action
   */
  export type persistencesArgs = {
    /**
     * Select specific fields to fetch from the persistences
     */
    select?: persistencesSelect | null
  }



  /**
   * Model point_to_point_services
   */


  export type AggregatePoint_to_point_services = {
    _count: Point_to_point_servicesCountAggregateOutputType | null
    _avg: Point_to_point_servicesAvgAggregateOutputType | null
    _sum: Point_to_point_servicesSumAggregateOutputType | null
    _min: Point_to_point_servicesMinAggregateOutputType | null
    _max: Point_to_point_servicesMaxAggregateOutputType | null
  }

  export type Point_to_point_servicesAvgAggregateOutputType = {
    id: number | null
    num_passengers: number | null
    service_id: number | null
  }

  export type Point_to_point_servicesSumAggregateOutputType = {
    id: number | null
    num_passengers: number | null
    service_id: number | null
  }

  export type Point_to_point_servicesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    pickup_location: string | null
    pickup_date_time: Date | null
    num_passengers: number | null
    dropoff_location: string | null
    add_another_stop: boolean | null
    additional_comments: string | null
    status: boolean | null
    pick_up_lat: string | null
    pick_up_lon: string | null
    drop_off_lat: string | null
    drop_off_lon: string | null
    service_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Point_to_point_servicesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    pickup_location: string | null
    pickup_date_time: Date | null
    num_passengers: number | null
    dropoff_location: string | null
    add_another_stop: boolean | null
    additional_comments: string | null
    status: boolean | null
    pick_up_lat: string | null
    pick_up_lon: string | null
    drop_off_lat: string | null
    drop_off_lon: string | null
    service_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Point_to_point_servicesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    pickup_location: number
    pickup_date_time: number
    num_passengers: number
    dropoff_location: number
    add_another_stop: number
    additional_comments: number
    status: number
    pick_up_lat: number
    pick_up_lon: number
    drop_off_lat: number
    drop_off_lon: number
    service_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Point_to_point_servicesAvgAggregateInputType = {
    id?: true
    num_passengers?: true
    service_id?: true
  }

  export type Point_to_point_servicesSumAggregateInputType = {
    id?: true
    num_passengers?: true
    service_id?: true
  }

  export type Point_to_point_servicesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pickup_location?: true
    pickup_date_time?: true
    num_passengers?: true
    dropoff_location?: true
    add_another_stop?: true
    additional_comments?: true
    status?: true
    pick_up_lat?: true
    pick_up_lon?: true
    drop_off_lat?: true
    drop_off_lon?: true
    service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Point_to_point_servicesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pickup_location?: true
    pickup_date_time?: true
    num_passengers?: true
    dropoff_location?: true
    add_another_stop?: true
    additional_comments?: true
    status?: true
    pick_up_lat?: true
    pick_up_lon?: true
    drop_off_lat?: true
    drop_off_lon?: true
    service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Point_to_point_servicesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pickup_location?: true
    pickup_date_time?: true
    num_passengers?: true
    dropoff_location?: true
    add_another_stop?: true
    additional_comments?: true
    status?: true
    pick_up_lat?: true
    pick_up_lon?: true
    drop_off_lat?: true
    drop_off_lon?: true
    service_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Point_to_point_servicesAggregateArgs = {
    /**
     * Filter which point_to_point_services to aggregate.
     */
    where?: point_to_point_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of point_to_point_services to fetch.
     */
    orderBy?: Enumerable<point_to_point_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: point_to_point_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` point_to_point_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` point_to_point_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned point_to_point_services
    **/
    _count?: true | Point_to_point_servicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Point_to_point_servicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Point_to_point_servicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Point_to_point_servicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Point_to_point_servicesMaxAggregateInputType
  }

  export type GetPoint_to_point_servicesAggregateType<T extends Point_to_point_servicesAggregateArgs> = {
        [P in keyof T & keyof AggregatePoint_to_point_services]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoint_to_point_services[P]>
      : GetScalarType<T[P], AggregatePoint_to_point_services[P]>
  }




  export type Point_to_point_servicesGroupByArgs = {
    where?: point_to_point_servicesWhereInput
    orderBy?: Enumerable<point_to_point_servicesOrderByWithAggregationInput>
    by: Point_to_point_servicesScalarFieldEnum[]
    having?: point_to_point_servicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Point_to_point_servicesCountAggregateInputType | true
    _avg?: Point_to_point_servicesAvgAggregateInputType
    _sum?: Point_to_point_servicesSumAggregateInputType
    _min?: Point_to_point_servicesMinAggregateInputType
    _max?: Point_to_point_servicesMaxAggregateInputType
  }


  export type Point_to_point_servicesGroupByOutputType = {
    id: number
    name: string
    description: string | null
    pickup_location: string
    pickup_date_time: Date
    num_passengers: number
    dropoff_location: string
    add_another_stop: boolean
    additional_comments: string | null
    status: boolean
    pick_up_lat: string
    pick_up_lon: string
    drop_off_lat: string
    drop_off_lon: string
    service_id: number
    created_at: Date | null
    updated_at: Date | null
    _count: Point_to_point_servicesCountAggregateOutputType | null
    _avg: Point_to_point_servicesAvgAggregateOutputType | null
    _sum: Point_to_point_servicesSumAggregateOutputType | null
    _min: Point_to_point_servicesMinAggregateOutputType | null
    _max: Point_to_point_servicesMaxAggregateOutputType | null
  }

  type GetPoint_to_point_servicesGroupByPayload<T extends Point_to_point_servicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Point_to_point_servicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Point_to_point_servicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Point_to_point_servicesGroupByOutputType[P]>
            : GetScalarType<T[P], Point_to_point_servicesGroupByOutputType[P]>
        }
      >
    >


  export type point_to_point_servicesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    pickup_location?: boolean
    pickup_date_time?: boolean
    num_passengers?: boolean
    dropoff_location?: boolean
    add_another_stop?: boolean
    additional_comments?: boolean
    status?: boolean
    pick_up_lat?: boolean
    pick_up_lon?: boolean
    drop_off_lat?: boolean
    drop_off_lon?: boolean
    service_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    services?: boolean | servicesArgs
  }


  export type point_to_point_servicesInclude = {
    services?: boolean | servicesArgs
  }

  export type point_to_point_servicesGetPayload<S extends boolean | null | undefined | point_to_point_servicesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? point_to_point_services :
    S extends undefined ? never :
    S extends { include: any } & (point_to_point_servicesArgs | point_to_point_servicesFindManyArgs)
    ? point_to_point_services  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'services' ? servicesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (point_to_point_servicesArgs | point_to_point_servicesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'services' ? servicesGetPayload<S['select'][P]> :  P extends keyof point_to_point_services ? point_to_point_services[P] : never
  } 
      : point_to_point_services


  type point_to_point_servicesCountArgs = 
    Omit<point_to_point_servicesFindManyArgs, 'select' | 'include'> & {
      select?: Point_to_point_servicesCountAggregateInputType | true
    }

  export interface point_to_point_servicesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Point_to_point_services that matches the filter.
     * @param {point_to_point_servicesFindUniqueArgs} args - Arguments to find a Point_to_point_services
     * @example
     * // Get one Point_to_point_services
     * const point_to_point_services = await prisma.point_to_point_services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends point_to_point_servicesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, point_to_point_servicesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'point_to_point_services'> extends True ? Prisma__point_to_point_servicesClient<point_to_point_servicesGetPayload<T>> : Prisma__point_to_point_servicesClient<point_to_point_servicesGetPayload<T> | null, null>

    /**
     * Find one Point_to_point_services that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {point_to_point_servicesFindUniqueOrThrowArgs} args - Arguments to find a Point_to_point_services
     * @example
     * // Get one Point_to_point_services
     * const point_to_point_services = await prisma.point_to_point_services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends point_to_point_servicesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, point_to_point_servicesFindUniqueOrThrowArgs>
    ): Prisma__point_to_point_servicesClient<point_to_point_servicesGetPayload<T>>

    /**
     * Find the first Point_to_point_services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {point_to_point_servicesFindFirstArgs} args - Arguments to find a Point_to_point_services
     * @example
     * // Get one Point_to_point_services
     * const point_to_point_services = await prisma.point_to_point_services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends point_to_point_servicesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, point_to_point_servicesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'point_to_point_services'> extends True ? Prisma__point_to_point_servicesClient<point_to_point_servicesGetPayload<T>> : Prisma__point_to_point_servicesClient<point_to_point_servicesGetPayload<T> | null, null>

    /**
     * Find the first Point_to_point_services that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {point_to_point_servicesFindFirstOrThrowArgs} args - Arguments to find a Point_to_point_services
     * @example
     * // Get one Point_to_point_services
     * const point_to_point_services = await prisma.point_to_point_services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends point_to_point_servicesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, point_to_point_servicesFindFirstOrThrowArgs>
    ): Prisma__point_to_point_servicesClient<point_to_point_servicesGetPayload<T>>

    /**
     * Find zero or more Point_to_point_services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {point_to_point_servicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Point_to_point_services
     * const point_to_point_services = await prisma.point_to_point_services.findMany()
     * 
     * // Get first 10 Point_to_point_services
     * const point_to_point_services = await prisma.point_to_point_services.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const point_to_point_servicesWithIdOnly = await prisma.point_to_point_services.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends point_to_point_servicesFindManyArgs>(
      args?: SelectSubset<T, point_to_point_servicesFindManyArgs>
    ): Prisma.PrismaPromise<Array<point_to_point_servicesGetPayload<T>>>

    /**
     * Create a Point_to_point_services.
     * @param {point_to_point_servicesCreateArgs} args - Arguments to create a Point_to_point_services.
     * @example
     * // Create one Point_to_point_services
     * const Point_to_point_services = await prisma.point_to_point_services.create({
     *   data: {
     *     // ... data to create a Point_to_point_services
     *   }
     * })
     * 
    **/
    create<T extends point_to_point_servicesCreateArgs>(
      args: SelectSubset<T, point_to_point_servicesCreateArgs>
    ): Prisma__point_to_point_servicesClient<point_to_point_servicesGetPayload<T>>

    /**
     * Create many Point_to_point_services.
     *     @param {point_to_point_servicesCreateManyArgs} args - Arguments to create many Point_to_point_services.
     *     @example
     *     // Create many Point_to_point_services
     *     const point_to_point_services = await prisma.point_to_point_services.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends point_to_point_servicesCreateManyArgs>(
      args?: SelectSubset<T, point_to_point_servicesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Point_to_point_services.
     * @param {point_to_point_servicesDeleteArgs} args - Arguments to delete one Point_to_point_services.
     * @example
     * // Delete one Point_to_point_services
     * const Point_to_point_services = await prisma.point_to_point_services.delete({
     *   where: {
     *     // ... filter to delete one Point_to_point_services
     *   }
     * })
     * 
    **/
    delete<T extends point_to_point_servicesDeleteArgs>(
      args: SelectSubset<T, point_to_point_servicesDeleteArgs>
    ): Prisma__point_to_point_servicesClient<point_to_point_servicesGetPayload<T>>

    /**
     * Update one Point_to_point_services.
     * @param {point_to_point_servicesUpdateArgs} args - Arguments to update one Point_to_point_services.
     * @example
     * // Update one Point_to_point_services
     * const point_to_point_services = await prisma.point_to_point_services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends point_to_point_servicesUpdateArgs>(
      args: SelectSubset<T, point_to_point_servicesUpdateArgs>
    ): Prisma__point_to_point_servicesClient<point_to_point_servicesGetPayload<T>>

    /**
     * Delete zero or more Point_to_point_services.
     * @param {point_to_point_servicesDeleteManyArgs} args - Arguments to filter Point_to_point_services to delete.
     * @example
     * // Delete a few Point_to_point_services
     * const { count } = await prisma.point_to_point_services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends point_to_point_servicesDeleteManyArgs>(
      args?: SelectSubset<T, point_to_point_servicesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Point_to_point_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {point_to_point_servicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Point_to_point_services
     * const point_to_point_services = await prisma.point_to_point_services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends point_to_point_servicesUpdateManyArgs>(
      args: SelectSubset<T, point_to_point_servicesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Point_to_point_services.
     * @param {point_to_point_servicesUpsertArgs} args - Arguments to update or create a Point_to_point_services.
     * @example
     * // Update or create a Point_to_point_services
     * const point_to_point_services = await prisma.point_to_point_services.upsert({
     *   create: {
     *     // ... data to create a Point_to_point_services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Point_to_point_services we want to update
     *   }
     * })
    **/
    upsert<T extends point_to_point_servicesUpsertArgs>(
      args: SelectSubset<T, point_to_point_servicesUpsertArgs>
    ): Prisma__point_to_point_servicesClient<point_to_point_servicesGetPayload<T>>

    /**
     * Count the number of Point_to_point_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {point_to_point_servicesCountArgs} args - Arguments to filter Point_to_point_services to count.
     * @example
     * // Count the number of Point_to_point_services
     * const count = await prisma.point_to_point_services.count({
     *   where: {
     *     // ... the filter for the Point_to_point_services we want to count
     *   }
     * })
    **/
    count<T extends point_to_point_servicesCountArgs>(
      args?: Subset<T, point_to_point_servicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Point_to_point_servicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Point_to_point_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Point_to_point_servicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Point_to_point_servicesAggregateArgs>(args: Subset<T, Point_to_point_servicesAggregateArgs>): Prisma.PrismaPromise<GetPoint_to_point_servicesAggregateType<T>>

    /**
     * Group by Point_to_point_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Point_to_point_servicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Point_to_point_servicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Point_to_point_servicesGroupByArgs['orderBy'] }
        : { orderBy?: Point_to_point_servicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Point_to_point_servicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoint_to_point_servicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for point_to_point_services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__point_to_point_servicesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    services<T extends servicesArgs= {}>(args?: Subset<T, servicesArgs>): Prisma__servicesClient<servicesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * point_to_point_services base type for findUnique actions
   */
  export type point_to_point_servicesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the point_to_point_services
     */
    select?: point_to_point_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: point_to_point_servicesInclude | null
    /**
     * Filter, which point_to_point_services to fetch.
     */
    where: point_to_point_servicesWhereUniqueInput
  }

  /**
   * point_to_point_services findUnique
   */
  export interface point_to_point_servicesFindUniqueArgs extends point_to_point_servicesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * point_to_point_services findUniqueOrThrow
   */
  export type point_to_point_servicesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the point_to_point_services
     */
    select?: point_to_point_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: point_to_point_servicesInclude | null
    /**
     * Filter, which point_to_point_services to fetch.
     */
    where: point_to_point_servicesWhereUniqueInput
  }


  /**
   * point_to_point_services base type for findFirst actions
   */
  export type point_to_point_servicesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the point_to_point_services
     */
    select?: point_to_point_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: point_to_point_servicesInclude | null
    /**
     * Filter, which point_to_point_services to fetch.
     */
    where?: point_to_point_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of point_to_point_services to fetch.
     */
    orderBy?: Enumerable<point_to_point_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for point_to_point_services.
     */
    cursor?: point_to_point_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` point_to_point_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` point_to_point_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of point_to_point_services.
     */
    distinct?: Enumerable<Point_to_point_servicesScalarFieldEnum>
  }

  /**
   * point_to_point_services findFirst
   */
  export interface point_to_point_servicesFindFirstArgs extends point_to_point_servicesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * point_to_point_services findFirstOrThrow
   */
  export type point_to_point_servicesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the point_to_point_services
     */
    select?: point_to_point_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: point_to_point_servicesInclude | null
    /**
     * Filter, which point_to_point_services to fetch.
     */
    where?: point_to_point_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of point_to_point_services to fetch.
     */
    orderBy?: Enumerable<point_to_point_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for point_to_point_services.
     */
    cursor?: point_to_point_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` point_to_point_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` point_to_point_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of point_to_point_services.
     */
    distinct?: Enumerable<Point_to_point_servicesScalarFieldEnum>
  }


  /**
   * point_to_point_services findMany
   */
  export type point_to_point_servicesFindManyArgs = {
    /**
     * Select specific fields to fetch from the point_to_point_services
     */
    select?: point_to_point_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: point_to_point_servicesInclude | null
    /**
     * Filter, which point_to_point_services to fetch.
     */
    where?: point_to_point_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of point_to_point_services to fetch.
     */
    orderBy?: Enumerable<point_to_point_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing point_to_point_services.
     */
    cursor?: point_to_point_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` point_to_point_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` point_to_point_services.
     */
    skip?: number
    distinct?: Enumerable<Point_to_point_servicesScalarFieldEnum>
  }


  /**
   * point_to_point_services create
   */
  export type point_to_point_servicesCreateArgs = {
    /**
     * Select specific fields to fetch from the point_to_point_services
     */
    select?: point_to_point_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: point_to_point_servicesInclude | null
    /**
     * The data needed to create a point_to_point_services.
     */
    data: XOR<point_to_point_servicesCreateInput, point_to_point_servicesUncheckedCreateInput>
  }


  /**
   * point_to_point_services createMany
   */
  export type point_to_point_servicesCreateManyArgs = {
    /**
     * The data used to create many point_to_point_services.
     */
    data: Enumerable<point_to_point_servicesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * point_to_point_services update
   */
  export type point_to_point_servicesUpdateArgs = {
    /**
     * Select specific fields to fetch from the point_to_point_services
     */
    select?: point_to_point_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: point_to_point_servicesInclude | null
    /**
     * The data needed to update a point_to_point_services.
     */
    data: XOR<point_to_point_servicesUpdateInput, point_to_point_servicesUncheckedUpdateInput>
    /**
     * Choose, which point_to_point_services to update.
     */
    where: point_to_point_servicesWhereUniqueInput
  }


  /**
   * point_to_point_services updateMany
   */
  export type point_to_point_servicesUpdateManyArgs = {
    /**
     * The data used to update point_to_point_services.
     */
    data: XOR<point_to_point_servicesUpdateManyMutationInput, point_to_point_servicesUncheckedUpdateManyInput>
    /**
     * Filter which point_to_point_services to update
     */
    where?: point_to_point_servicesWhereInput
  }


  /**
   * point_to_point_services upsert
   */
  export type point_to_point_servicesUpsertArgs = {
    /**
     * Select specific fields to fetch from the point_to_point_services
     */
    select?: point_to_point_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: point_to_point_servicesInclude | null
    /**
     * The filter to search for the point_to_point_services to update in case it exists.
     */
    where: point_to_point_servicesWhereUniqueInput
    /**
     * In case the point_to_point_services found by the `where` argument doesn't exist, create a new point_to_point_services with this data.
     */
    create: XOR<point_to_point_servicesCreateInput, point_to_point_servicesUncheckedCreateInput>
    /**
     * In case the point_to_point_services was found with the provided `where` argument, update it with this data.
     */
    update: XOR<point_to_point_servicesUpdateInput, point_to_point_servicesUncheckedUpdateInput>
  }


  /**
   * point_to_point_services delete
   */
  export type point_to_point_servicesDeleteArgs = {
    /**
     * Select specific fields to fetch from the point_to_point_services
     */
    select?: point_to_point_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: point_to_point_servicesInclude | null
    /**
     * Filter which point_to_point_services to delete.
     */
    where: point_to_point_servicesWhereUniqueInput
  }


  /**
   * point_to_point_services deleteMany
   */
  export type point_to_point_servicesDeleteManyArgs = {
    /**
     * Filter which point_to_point_services to delete
     */
    where?: point_to_point_servicesWhereInput
  }


  /**
   * point_to_point_services without action
   */
  export type point_to_point_servicesArgs = {
    /**
     * Select specific fields to fetch from the point_to_point_services
     */
    select?: point_to_point_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: point_to_point_servicesInclude | null
  }



  /**
   * Model reminders
   */


  export type AggregateReminders = {
    _count: RemindersCountAggregateOutputType | null
    _avg: RemindersAvgAggregateOutputType | null
    _sum: RemindersSumAggregateOutputType | null
    _min: RemindersMinAggregateOutputType | null
    _max: RemindersMaxAggregateOutputType | null
  }

  export type RemindersAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type RemindersSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type RemindersMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    code: string | null
    completed: boolean | null
    completed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RemindersMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    code: string | null
    completed: boolean | null
    completed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RemindersCountAggregateOutputType = {
    id: number
    user_id: number
    code: number
    completed: number
    completed_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RemindersAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type RemindersSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type RemindersMinAggregateInputType = {
    id?: true
    user_id?: true
    code?: true
    completed?: true
    completed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type RemindersMaxAggregateInputType = {
    id?: true
    user_id?: true
    code?: true
    completed?: true
    completed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type RemindersCountAggregateInputType = {
    id?: true
    user_id?: true
    code?: true
    completed?: true
    completed_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RemindersAggregateArgs = {
    /**
     * Filter which reminders to aggregate.
     */
    where?: remindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reminders to fetch.
     */
    orderBy?: Enumerable<remindersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: remindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reminders
    **/
    _count?: true | RemindersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RemindersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RemindersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RemindersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RemindersMaxAggregateInputType
  }

  export type GetRemindersAggregateType<T extends RemindersAggregateArgs> = {
        [P in keyof T & keyof AggregateReminders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReminders[P]>
      : GetScalarType<T[P], AggregateReminders[P]>
  }




  export type RemindersGroupByArgs = {
    where?: remindersWhereInput
    orderBy?: Enumerable<remindersOrderByWithAggregationInput>
    by: RemindersScalarFieldEnum[]
    having?: remindersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RemindersCountAggregateInputType | true
    _avg?: RemindersAvgAggregateInputType
    _sum?: RemindersSumAggregateInputType
    _min?: RemindersMinAggregateInputType
    _max?: RemindersMaxAggregateInputType
  }


  export type RemindersGroupByOutputType = {
    id: number
    user_id: number
    code: string
    completed: boolean
    completed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: RemindersCountAggregateOutputType | null
    _avg: RemindersAvgAggregateOutputType | null
    _sum: RemindersSumAggregateOutputType | null
    _min: RemindersMinAggregateOutputType | null
    _max: RemindersMaxAggregateOutputType | null
  }

  type GetRemindersGroupByPayload<T extends RemindersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RemindersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RemindersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RemindersGroupByOutputType[P]>
            : GetScalarType<T[P], RemindersGroupByOutputType[P]>
        }
      >
    >


  export type remindersSelect = {
    id?: boolean
    user_id?: boolean
    code?: boolean
    completed?: boolean
    completed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type remindersGetPayload<S extends boolean | null | undefined | remindersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reminders :
    S extends undefined ? never :
    S extends { include: any } & (remindersArgs | remindersFindManyArgs)
    ? reminders 
    : S extends { select: any } & (remindersArgs | remindersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reminders ? reminders[P] : never
  } 
      : reminders


  type remindersCountArgs = 
    Omit<remindersFindManyArgs, 'select' | 'include'> & {
      select?: RemindersCountAggregateInputType | true
    }

  export interface remindersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Reminders that matches the filter.
     * @param {remindersFindUniqueArgs} args - Arguments to find a Reminders
     * @example
     * // Get one Reminders
     * const reminders = await prisma.reminders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends remindersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, remindersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reminders'> extends True ? Prisma__remindersClient<remindersGetPayload<T>> : Prisma__remindersClient<remindersGetPayload<T> | null, null>

    /**
     * Find one Reminders that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {remindersFindUniqueOrThrowArgs} args - Arguments to find a Reminders
     * @example
     * // Get one Reminders
     * const reminders = await prisma.reminders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends remindersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, remindersFindUniqueOrThrowArgs>
    ): Prisma__remindersClient<remindersGetPayload<T>>

    /**
     * Find the first Reminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {remindersFindFirstArgs} args - Arguments to find a Reminders
     * @example
     * // Get one Reminders
     * const reminders = await prisma.reminders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends remindersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, remindersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reminders'> extends True ? Prisma__remindersClient<remindersGetPayload<T>> : Prisma__remindersClient<remindersGetPayload<T> | null, null>

    /**
     * Find the first Reminders that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {remindersFindFirstOrThrowArgs} args - Arguments to find a Reminders
     * @example
     * // Get one Reminders
     * const reminders = await prisma.reminders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends remindersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, remindersFindFirstOrThrowArgs>
    ): Prisma__remindersClient<remindersGetPayload<T>>

    /**
     * Find zero or more Reminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {remindersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reminders
     * const reminders = await prisma.reminders.findMany()
     * 
     * // Get first 10 Reminders
     * const reminders = await prisma.reminders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const remindersWithIdOnly = await prisma.reminders.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends remindersFindManyArgs>(
      args?: SelectSubset<T, remindersFindManyArgs>
    ): Prisma.PrismaPromise<Array<remindersGetPayload<T>>>

    /**
     * Create a Reminders.
     * @param {remindersCreateArgs} args - Arguments to create a Reminders.
     * @example
     * // Create one Reminders
     * const Reminders = await prisma.reminders.create({
     *   data: {
     *     // ... data to create a Reminders
     *   }
     * })
     * 
    **/
    create<T extends remindersCreateArgs>(
      args: SelectSubset<T, remindersCreateArgs>
    ): Prisma__remindersClient<remindersGetPayload<T>>

    /**
     * Create many Reminders.
     *     @param {remindersCreateManyArgs} args - Arguments to create many Reminders.
     *     @example
     *     // Create many Reminders
     *     const reminders = await prisma.reminders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends remindersCreateManyArgs>(
      args?: SelectSubset<T, remindersCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reminders.
     * @param {remindersDeleteArgs} args - Arguments to delete one Reminders.
     * @example
     * // Delete one Reminders
     * const Reminders = await prisma.reminders.delete({
     *   where: {
     *     // ... filter to delete one Reminders
     *   }
     * })
     * 
    **/
    delete<T extends remindersDeleteArgs>(
      args: SelectSubset<T, remindersDeleteArgs>
    ): Prisma__remindersClient<remindersGetPayload<T>>

    /**
     * Update one Reminders.
     * @param {remindersUpdateArgs} args - Arguments to update one Reminders.
     * @example
     * // Update one Reminders
     * const reminders = await prisma.reminders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends remindersUpdateArgs>(
      args: SelectSubset<T, remindersUpdateArgs>
    ): Prisma__remindersClient<remindersGetPayload<T>>

    /**
     * Delete zero or more Reminders.
     * @param {remindersDeleteManyArgs} args - Arguments to filter Reminders to delete.
     * @example
     * // Delete a few Reminders
     * const { count } = await prisma.reminders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends remindersDeleteManyArgs>(
      args?: SelectSubset<T, remindersDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {remindersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reminders
     * const reminders = await prisma.reminders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends remindersUpdateManyArgs>(
      args: SelectSubset<T, remindersUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reminders.
     * @param {remindersUpsertArgs} args - Arguments to update or create a Reminders.
     * @example
     * // Update or create a Reminders
     * const reminders = await prisma.reminders.upsert({
     *   create: {
     *     // ... data to create a Reminders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reminders we want to update
     *   }
     * })
    **/
    upsert<T extends remindersUpsertArgs>(
      args: SelectSubset<T, remindersUpsertArgs>
    ): Prisma__remindersClient<remindersGetPayload<T>>

    /**
     * Count the number of Reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {remindersCountArgs} args - Arguments to filter Reminders to count.
     * @example
     * // Count the number of Reminders
     * const count = await prisma.reminders.count({
     *   where: {
     *     // ... the filter for the Reminders we want to count
     *   }
     * })
    **/
    count<T extends remindersCountArgs>(
      args?: Subset<T, remindersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RemindersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemindersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RemindersAggregateArgs>(args: Subset<T, RemindersAggregateArgs>): Prisma.PrismaPromise<GetRemindersAggregateType<T>>

    /**
     * Group by Reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemindersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RemindersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RemindersGroupByArgs['orderBy'] }
        : { orderBy?: RemindersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RemindersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRemindersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reminders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__remindersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reminders base type for findUnique actions
   */
  export type remindersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect | null
    /**
     * Filter, which reminders to fetch.
     */
    where: remindersWhereUniqueInput
  }

  /**
   * reminders findUnique
   */
  export interface remindersFindUniqueArgs extends remindersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reminders findUniqueOrThrow
   */
  export type remindersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect | null
    /**
     * Filter, which reminders to fetch.
     */
    where: remindersWhereUniqueInput
  }


  /**
   * reminders base type for findFirst actions
   */
  export type remindersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect | null
    /**
     * Filter, which reminders to fetch.
     */
    where?: remindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reminders to fetch.
     */
    orderBy?: Enumerable<remindersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reminders.
     */
    cursor?: remindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reminders.
     */
    distinct?: Enumerable<RemindersScalarFieldEnum>
  }

  /**
   * reminders findFirst
   */
  export interface remindersFindFirstArgs extends remindersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reminders findFirstOrThrow
   */
  export type remindersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect | null
    /**
     * Filter, which reminders to fetch.
     */
    where?: remindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reminders to fetch.
     */
    orderBy?: Enumerable<remindersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reminders.
     */
    cursor?: remindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reminders.
     */
    distinct?: Enumerable<RemindersScalarFieldEnum>
  }


  /**
   * reminders findMany
   */
  export type remindersFindManyArgs = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect | null
    /**
     * Filter, which reminders to fetch.
     */
    where?: remindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reminders to fetch.
     */
    orderBy?: Enumerable<remindersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reminders.
     */
    cursor?: remindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reminders.
     */
    skip?: number
    distinct?: Enumerable<RemindersScalarFieldEnum>
  }


  /**
   * reminders create
   */
  export type remindersCreateArgs = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect | null
    /**
     * The data needed to create a reminders.
     */
    data: XOR<remindersCreateInput, remindersUncheckedCreateInput>
  }


  /**
   * reminders createMany
   */
  export type remindersCreateManyArgs = {
    /**
     * The data used to create many reminders.
     */
    data: Enumerable<remindersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reminders update
   */
  export type remindersUpdateArgs = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect | null
    /**
     * The data needed to update a reminders.
     */
    data: XOR<remindersUpdateInput, remindersUncheckedUpdateInput>
    /**
     * Choose, which reminders to update.
     */
    where: remindersWhereUniqueInput
  }


  /**
   * reminders updateMany
   */
  export type remindersUpdateManyArgs = {
    /**
     * The data used to update reminders.
     */
    data: XOR<remindersUpdateManyMutationInput, remindersUncheckedUpdateManyInput>
    /**
     * Filter which reminders to update
     */
    where?: remindersWhereInput
  }


  /**
   * reminders upsert
   */
  export type remindersUpsertArgs = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect | null
    /**
     * The filter to search for the reminders to update in case it exists.
     */
    where: remindersWhereUniqueInput
    /**
     * In case the reminders found by the `where` argument doesn't exist, create a new reminders with this data.
     */
    create: XOR<remindersCreateInput, remindersUncheckedCreateInput>
    /**
     * In case the reminders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<remindersUpdateInput, remindersUncheckedUpdateInput>
  }


  /**
   * reminders delete
   */
  export type remindersDeleteArgs = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect | null
    /**
     * Filter which reminders to delete.
     */
    where: remindersWhereUniqueInput
  }


  /**
   * reminders deleteMany
   */
  export type remindersDeleteManyArgs = {
    /**
     * Filter which reminders to delete
     */
    where?: remindersWhereInput
  }


  /**
   * reminders without action
   */
  export type remindersArgs = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect | null
  }



  /**
   * Model reservations
   */


  export type AggregateReservations = {
    _count: ReservationsCountAggregateOutputType | null
    _avg: ReservationsAvgAggregateOutputType | null
    _sum: ReservationsSumAggregateOutputType | null
    _min: ReservationsMinAggregateOutputType | null
    _max: ReservationsMaxAggregateOutputType | null
  }

  export type ReservationsAvgAggregateOutputType = {
    id: number | null
    service_id: number | null
    car_id: number | null
    pick_up_lat: number | null
    pick_up_lon: number | null
    drop_off_lat: number | null
    drop_off_lon: number | null
    price: number | null
    tax: number | null
    no_of_hours: number | null
    maximum_passenger: number | null
    maximum_luggage: number | null
    isPaid: number | null
  }

  export type ReservationsSumAggregateOutputType = {
    id: number | null
    service_id: number | null
    car_id: number | null
    pick_up_lat: number | null
    pick_up_lon: number | null
    drop_off_lat: number | null
    drop_off_lon: number | null
    price: number | null
    tax: number | null
    no_of_hours: number | null
    maximum_passenger: number | null
    maximum_luggage: number | null
    isPaid: number | null
  }

  export type ReservationsMinAggregateOutputType = {
    id: number | null
    order_number: string | null
    service_id: number | null
    car_id: number | null
    pick_up_postal_code: string | null
    pick_up_lat: number | null
    pick_up_lon: number | null
    pick_up_loc_name: string | null
    drop_off_postal_code: string | null
    drop_off_lat: number | null
    drop_off_lon: number | null
    drop_off_loc_name: string | null
    pick_up_date: Date | null
    price: number | null
    tax: number | null
    airline: string | null
    flight_no: string | null
    no_of_hours: number | null
    maximum_passenger: number | null
    maximum_luggage: number | null
    customer_first_name: string | null
    customer_last_name: string | null
    customer_cnic: string | null
    customer_email: string | null
    customer_phone: string | null
    created_at: Date | null
    updated_at: Date | null
    uuid: string | null
    payment_method: string | null
    isPaid: number | null
    special_instruction: string | null
  }

  export type ReservationsMaxAggregateOutputType = {
    id: number | null
    order_number: string | null
    service_id: number | null
    car_id: number | null
    pick_up_postal_code: string | null
    pick_up_lat: number | null
    pick_up_lon: number | null
    pick_up_loc_name: string | null
    drop_off_postal_code: string | null
    drop_off_lat: number | null
    drop_off_lon: number | null
    drop_off_loc_name: string | null
    pick_up_date: Date | null
    price: number | null
    tax: number | null
    airline: string | null
    flight_no: string | null
    no_of_hours: number | null
    maximum_passenger: number | null
    maximum_luggage: number | null
    customer_first_name: string | null
    customer_last_name: string | null
    customer_cnic: string | null
    customer_email: string | null
    customer_phone: string | null
    created_at: Date | null
    updated_at: Date | null
    uuid: string | null
    payment_method: string | null
    isPaid: number | null
    special_instruction: string | null
  }

  export type ReservationsCountAggregateOutputType = {
    id: number
    order_number: number
    service_id: number
    car_id: number
    pick_up_postal_code: number
    pick_up_lat: number
    pick_up_lon: number
    pick_up_loc_name: number
    drop_off_postal_code: number
    drop_off_lat: number
    drop_off_lon: number
    drop_off_loc_name: number
    pick_up_date: number
    price: number
    tax: number
    airline: number
    flight_no: number
    no_of_hours: number
    maximum_passenger: number
    maximum_luggage: number
    customer_first_name: number
    customer_last_name: number
    customer_cnic: number
    customer_email: number
    customer_phone: number
    created_at: number
    updated_at: number
    uuid: number
    payment_method: number
    isPaid: number
    special_instruction: number
    _all: number
  }


  export type ReservationsAvgAggregateInputType = {
    id?: true
    service_id?: true
    car_id?: true
    pick_up_lat?: true
    pick_up_lon?: true
    drop_off_lat?: true
    drop_off_lon?: true
    price?: true
    tax?: true
    no_of_hours?: true
    maximum_passenger?: true
    maximum_luggage?: true
    isPaid?: true
  }

  export type ReservationsSumAggregateInputType = {
    id?: true
    service_id?: true
    car_id?: true
    pick_up_lat?: true
    pick_up_lon?: true
    drop_off_lat?: true
    drop_off_lon?: true
    price?: true
    tax?: true
    no_of_hours?: true
    maximum_passenger?: true
    maximum_luggage?: true
    isPaid?: true
  }

  export type ReservationsMinAggregateInputType = {
    id?: true
    order_number?: true
    service_id?: true
    car_id?: true
    pick_up_postal_code?: true
    pick_up_lat?: true
    pick_up_lon?: true
    pick_up_loc_name?: true
    drop_off_postal_code?: true
    drop_off_lat?: true
    drop_off_lon?: true
    drop_off_loc_name?: true
    pick_up_date?: true
    price?: true
    tax?: true
    airline?: true
    flight_no?: true
    no_of_hours?: true
    maximum_passenger?: true
    maximum_luggage?: true
    customer_first_name?: true
    customer_last_name?: true
    customer_cnic?: true
    customer_email?: true
    customer_phone?: true
    created_at?: true
    updated_at?: true
    uuid?: true
    payment_method?: true
    isPaid?: true
    special_instruction?: true
  }

  export type ReservationsMaxAggregateInputType = {
    id?: true
    order_number?: true
    service_id?: true
    car_id?: true
    pick_up_postal_code?: true
    pick_up_lat?: true
    pick_up_lon?: true
    pick_up_loc_name?: true
    drop_off_postal_code?: true
    drop_off_lat?: true
    drop_off_lon?: true
    drop_off_loc_name?: true
    pick_up_date?: true
    price?: true
    tax?: true
    airline?: true
    flight_no?: true
    no_of_hours?: true
    maximum_passenger?: true
    maximum_luggage?: true
    customer_first_name?: true
    customer_last_name?: true
    customer_cnic?: true
    customer_email?: true
    customer_phone?: true
    created_at?: true
    updated_at?: true
    uuid?: true
    payment_method?: true
    isPaid?: true
    special_instruction?: true
  }

  export type ReservationsCountAggregateInputType = {
    id?: true
    order_number?: true
    service_id?: true
    car_id?: true
    pick_up_postal_code?: true
    pick_up_lat?: true
    pick_up_lon?: true
    pick_up_loc_name?: true
    drop_off_postal_code?: true
    drop_off_lat?: true
    drop_off_lon?: true
    drop_off_loc_name?: true
    pick_up_date?: true
    price?: true
    tax?: true
    airline?: true
    flight_no?: true
    no_of_hours?: true
    maximum_passenger?: true
    maximum_luggage?: true
    customer_first_name?: true
    customer_last_name?: true
    customer_cnic?: true
    customer_email?: true
    customer_phone?: true
    created_at?: true
    updated_at?: true
    uuid?: true
    payment_method?: true
    isPaid?: true
    special_instruction?: true
    _all?: true
  }

  export type ReservationsAggregateArgs = {
    /**
     * Filter which reservations to aggregate.
     */
    where?: reservationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     */
    orderBy?: Enumerable<reservationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reservationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reservations
    **/
    _count?: true | ReservationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationsMaxAggregateInputType
  }

  export type GetReservationsAggregateType<T extends ReservationsAggregateArgs> = {
        [P in keyof T & keyof AggregateReservations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservations[P]>
      : GetScalarType<T[P], AggregateReservations[P]>
  }




  export type ReservationsGroupByArgs = {
    where?: reservationsWhereInput
    orderBy?: Enumerable<reservationsOrderByWithAggregationInput>
    by: ReservationsScalarFieldEnum[]
    having?: reservationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationsCountAggregateInputType | true
    _avg?: ReservationsAvgAggregateInputType
    _sum?: ReservationsSumAggregateInputType
    _min?: ReservationsMinAggregateInputType
    _max?: ReservationsMaxAggregateInputType
  }


  export type ReservationsGroupByOutputType = {
    id: number
    order_number: string | null
    service_id: number
    car_id: number
    pick_up_postal_code: string | null
    pick_up_lat: number | null
    pick_up_lon: number | null
    pick_up_loc_name: string | null
    drop_off_postal_code: string | null
    drop_off_lat: number | null
    drop_off_lon: number | null
    drop_off_loc_name: string | null
    pick_up_date: Date | null
    price: number | null
    tax: number | null
    airline: string | null
    flight_no: string | null
    no_of_hours: number | null
    maximum_passenger: number | null
    maximum_luggage: number | null
    customer_first_name: string | null
    customer_last_name: string | null
    customer_cnic: string | null
    customer_email: string | null
    customer_phone: string | null
    created_at: Date | null
    updated_at: Date | null
    uuid: string
    payment_method: string | null
    isPaid: number | null
    special_instruction: string | null
    _count: ReservationsCountAggregateOutputType | null
    _avg: ReservationsAvgAggregateOutputType | null
    _sum: ReservationsSumAggregateOutputType | null
    _min: ReservationsMinAggregateOutputType | null
    _max: ReservationsMaxAggregateOutputType | null
  }

  type GetReservationsGroupByPayload<T extends ReservationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReservationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationsGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationsGroupByOutputType[P]>
        }
      >
    >


  export type reservationsSelect = {
    id?: boolean
    order_number?: boolean
    service_id?: boolean
    car_id?: boolean
    pick_up_postal_code?: boolean
    pick_up_lat?: boolean
    pick_up_lon?: boolean
    pick_up_loc_name?: boolean
    drop_off_postal_code?: boolean
    drop_off_lat?: boolean
    drop_off_lon?: boolean
    drop_off_loc_name?: boolean
    pick_up_date?: boolean
    price?: boolean
    tax?: boolean
    airline?: boolean
    flight_no?: boolean
    no_of_hours?: boolean
    maximum_passenger?: boolean
    maximum_luggage?: boolean
    customer_first_name?: boolean
    customer_last_name?: boolean
    customer_cnic?: boolean
    customer_email?: boolean
    customer_phone?: boolean
    created_at?: boolean
    updated_at?: boolean
    uuid?: boolean
    payment_method?: boolean
    isPaid?: boolean
    special_instruction?: boolean
    cars?: boolean | carsArgs
    sub_services?: boolean | sub_servicesArgs
  }


  export type reservationsInclude = {
    cars?: boolean | carsArgs
    sub_services?: boolean | sub_servicesArgs
  }

  export type reservationsGetPayload<S extends boolean | null | undefined | reservationsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reservations :
    S extends undefined ? never :
    S extends { include: any } & (reservationsArgs | reservationsFindManyArgs)
    ? reservations  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'cars' ? carsGetPayload<S['include'][P]> :
        P extends 'sub_services' ? sub_servicesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (reservationsArgs | reservationsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'cars' ? carsGetPayload<S['select'][P]> :
        P extends 'sub_services' ? sub_servicesGetPayload<S['select'][P]> :  P extends keyof reservations ? reservations[P] : never
  } 
      : reservations


  type reservationsCountArgs = 
    Omit<reservationsFindManyArgs, 'select' | 'include'> & {
      select?: ReservationsCountAggregateInputType | true
    }

  export interface reservationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Reservations that matches the filter.
     * @param {reservationsFindUniqueArgs} args - Arguments to find a Reservations
     * @example
     * // Get one Reservations
     * const reservations = await prisma.reservations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reservationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reservationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reservations'> extends True ? Prisma__reservationsClient<reservationsGetPayload<T>> : Prisma__reservationsClient<reservationsGetPayload<T> | null, null>

    /**
     * Find one Reservations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reservationsFindUniqueOrThrowArgs} args - Arguments to find a Reservations
     * @example
     * // Get one Reservations
     * const reservations = await prisma.reservations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reservationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reservationsFindUniqueOrThrowArgs>
    ): Prisma__reservationsClient<reservationsGetPayload<T>>

    /**
     * Find the first Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationsFindFirstArgs} args - Arguments to find a Reservations
     * @example
     * // Get one Reservations
     * const reservations = await prisma.reservations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reservationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reservationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reservations'> extends True ? Prisma__reservationsClient<reservationsGetPayload<T>> : Prisma__reservationsClient<reservationsGetPayload<T> | null, null>

    /**
     * Find the first Reservations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationsFindFirstOrThrowArgs} args - Arguments to find a Reservations
     * @example
     * // Get one Reservations
     * const reservations = await prisma.reservations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reservationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reservationsFindFirstOrThrowArgs>
    ): Prisma__reservationsClient<reservationsGetPayload<T>>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservations.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationsWithIdOnly = await prisma.reservations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reservationsFindManyArgs>(
      args?: SelectSubset<T, reservationsFindManyArgs>
    ): Prisma.PrismaPromise<Array<reservationsGetPayload<T>>>

    /**
     * Create a Reservations.
     * @param {reservationsCreateArgs} args - Arguments to create a Reservations.
     * @example
     * // Create one Reservations
     * const Reservations = await prisma.reservations.create({
     *   data: {
     *     // ... data to create a Reservations
     *   }
     * })
     * 
    **/
    create<T extends reservationsCreateArgs>(
      args: SelectSubset<T, reservationsCreateArgs>
    ): Prisma__reservationsClient<reservationsGetPayload<T>>

    /**
     * Create many Reservations.
     *     @param {reservationsCreateManyArgs} args - Arguments to create many Reservations.
     *     @example
     *     // Create many Reservations
     *     const reservations = await prisma.reservations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reservationsCreateManyArgs>(
      args?: SelectSubset<T, reservationsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reservations.
     * @param {reservationsDeleteArgs} args - Arguments to delete one Reservations.
     * @example
     * // Delete one Reservations
     * const Reservations = await prisma.reservations.delete({
     *   where: {
     *     // ... filter to delete one Reservations
     *   }
     * })
     * 
    **/
    delete<T extends reservationsDeleteArgs>(
      args: SelectSubset<T, reservationsDeleteArgs>
    ): Prisma__reservationsClient<reservationsGetPayload<T>>

    /**
     * Update one Reservations.
     * @param {reservationsUpdateArgs} args - Arguments to update one Reservations.
     * @example
     * // Update one Reservations
     * const reservations = await prisma.reservations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reservationsUpdateArgs>(
      args: SelectSubset<T, reservationsUpdateArgs>
    ): Prisma__reservationsClient<reservationsGetPayload<T>>

    /**
     * Delete zero or more Reservations.
     * @param {reservationsDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reservationsDeleteManyArgs>(
      args?: SelectSubset<T, reservationsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservations = await prisma.reservations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reservationsUpdateManyArgs>(
      args: SelectSubset<T, reservationsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reservations.
     * @param {reservationsUpsertArgs} args - Arguments to update or create a Reservations.
     * @example
     * // Update or create a Reservations
     * const reservations = await prisma.reservations.upsert({
     *   create: {
     *     // ... data to create a Reservations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservations we want to update
     *   }
     * })
    **/
    upsert<T extends reservationsUpsertArgs>(
      args: SelectSubset<T, reservationsUpsertArgs>
    ): Prisma__reservationsClient<reservationsGetPayload<T>>

    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationsCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservations.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends reservationsCountArgs>(
      args?: Subset<T, reservationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationsAggregateArgs>(args: Subset<T, ReservationsAggregateArgs>): Prisma.PrismaPromise<GetReservationsAggregateType<T>>

    /**
     * Group by Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationsGroupByArgs['orderBy'] }
        : { orderBy?: ReservationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reservations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reservationsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cars<T extends carsArgs= {}>(args?: Subset<T, carsArgs>): Prisma__carsClient<carsGetPayload<T> | Null>;

    sub_services<T extends sub_servicesArgs= {}>(args?: Subset<T, sub_servicesArgs>): Prisma__sub_servicesClient<sub_servicesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reservations base type for findUnique actions
   */
  export type reservationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reservationsInclude | null
    /**
     * Filter, which reservations to fetch.
     */
    where: reservationsWhereUniqueInput
  }

  /**
   * reservations findUnique
   */
  export interface reservationsFindUniqueArgs extends reservationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reservations findUniqueOrThrow
   */
  export type reservationsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reservationsInclude | null
    /**
     * Filter, which reservations to fetch.
     */
    where: reservationsWhereUniqueInput
  }


  /**
   * reservations base type for findFirst actions
   */
  export type reservationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reservationsInclude | null
    /**
     * Filter, which reservations to fetch.
     */
    where?: reservationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     */
    orderBy?: Enumerable<reservationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reservations.
     */
    cursor?: reservationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reservations.
     */
    distinct?: Enumerable<ReservationsScalarFieldEnum>
  }

  /**
   * reservations findFirst
   */
  export interface reservationsFindFirstArgs extends reservationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reservations findFirstOrThrow
   */
  export type reservationsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reservationsInclude | null
    /**
     * Filter, which reservations to fetch.
     */
    where?: reservationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     */
    orderBy?: Enumerable<reservationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reservations.
     */
    cursor?: reservationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reservations.
     */
    distinct?: Enumerable<ReservationsScalarFieldEnum>
  }


  /**
   * reservations findMany
   */
  export type reservationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reservationsInclude | null
    /**
     * Filter, which reservations to fetch.
     */
    where?: reservationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     */
    orderBy?: Enumerable<reservationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reservations.
     */
    cursor?: reservationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     */
    skip?: number
    distinct?: Enumerable<ReservationsScalarFieldEnum>
  }


  /**
   * reservations create
   */
  export type reservationsCreateArgs = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reservationsInclude | null
    /**
     * The data needed to create a reservations.
     */
    data: XOR<reservationsCreateInput, reservationsUncheckedCreateInput>
  }


  /**
   * reservations createMany
   */
  export type reservationsCreateManyArgs = {
    /**
     * The data used to create many reservations.
     */
    data: Enumerable<reservationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reservations update
   */
  export type reservationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reservationsInclude | null
    /**
     * The data needed to update a reservations.
     */
    data: XOR<reservationsUpdateInput, reservationsUncheckedUpdateInput>
    /**
     * Choose, which reservations to update.
     */
    where: reservationsWhereUniqueInput
  }


  /**
   * reservations updateMany
   */
  export type reservationsUpdateManyArgs = {
    /**
     * The data used to update reservations.
     */
    data: XOR<reservationsUpdateManyMutationInput, reservationsUncheckedUpdateManyInput>
    /**
     * Filter which reservations to update
     */
    where?: reservationsWhereInput
  }


  /**
   * reservations upsert
   */
  export type reservationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reservationsInclude | null
    /**
     * The filter to search for the reservations to update in case it exists.
     */
    where: reservationsWhereUniqueInput
    /**
     * In case the reservations found by the `where` argument doesn't exist, create a new reservations with this data.
     */
    create: XOR<reservationsCreateInput, reservationsUncheckedCreateInput>
    /**
     * In case the reservations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reservationsUpdateInput, reservationsUncheckedUpdateInput>
  }


  /**
   * reservations delete
   */
  export type reservationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reservationsInclude | null
    /**
     * Filter which reservations to delete.
     */
    where: reservationsWhereUniqueInput
  }


  /**
   * reservations deleteMany
   */
  export type reservationsDeleteManyArgs = {
    /**
     * Filter which reservations to delete
     */
    where?: reservationsWhereInput
  }


  /**
   * reservations without action
   */
  export type reservationsArgs = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reservationsInclude | null
  }



  /**
   * Model role_users
   */


  export type AggregateRole_users = {
    _count: Role_usersCountAggregateOutputType | null
    _avg: Role_usersAvgAggregateOutputType | null
    _sum: Role_usersSumAggregateOutputType | null
    _min: Role_usersMinAggregateOutputType | null
    _max: Role_usersMaxAggregateOutputType | null
  }

  export type Role_usersAvgAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type Role_usersSumAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type Role_usersMinAggregateOutputType = {
    user_id: number | null
    role_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Role_usersMaxAggregateOutputType = {
    user_id: number | null
    role_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Role_usersCountAggregateOutputType = {
    user_id: number
    role_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Role_usersAvgAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type Role_usersSumAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type Role_usersMinAggregateInputType = {
    user_id?: true
    role_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Role_usersMaxAggregateInputType = {
    user_id?: true
    role_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Role_usersCountAggregateInputType = {
    user_id?: true
    role_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Role_usersAggregateArgs = {
    /**
     * Filter which role_users to aggregate.
     */
    where?: role_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_users to fetch.
     */
    orderBy?: Enumerable<role_usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: role_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned role_users
    **/
    _count?: true | Role_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Role_usersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Role_usersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Role_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Role_usersMaxAggregateInputType
  }

  export type GetRole_usersAggregateType<T extends Role_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateRole_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole_users[P]>
      : GetScalarType<T[P], AggregateRole_users[P]>
  }




  export type Role_usersGroupByArgs = {
    where?: role_usersWhereInput
    orderBy?: Enumerable<role_usersOrderByWithAggregationInput>
    by: Role_usersScalarFieldEnum[]
    having?: role_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Role_usersCountAggregateInputType | true
    _avg?: Role_usersAvgAggregateInputType
    _sum?: Role_usersSumAggregateInputType
    _min?: Role_usersMinAggregateInputType
    _max?: Role_usersMaxAggregateInputType
  }


  export type Role_usersGroupByOutputType = {
    user_id: number
    role_id: number
    created_at: Date | null
    updated_at: Date | null
    _count: Role_usersCountAggregateOutputType | null
    _avg: Role_usersAvgAggregateOutputType | null
    _sum: Role_usersSumAggregateOutputType | null
    _min: Role_usersMinAggregateOutputType | null
    _max: Role_usersMaxAggregateOutputType | null
  }

  type GetRole_usersGroupByPayload<T extends Role_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Role_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Role_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Role_usersGroupByOutputType[P]>
            : GetScalarType<T[P], Role_usersGroupByOutputType[P]>
        }
      >
    >


  export type role_usersSelect = {
    user_id?: boolean
    role_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    roles?: boolean | rolesArgs
    users?: boolean | usersArgs
  }


  export type role_usersInclude = {
    roles?: boolean | rolesArgs
    users?: boolean | usersArgs
  }

  export type role_usersGetPayload<S extends boolean | null | undefined | role_usersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? role_users :
    S extends undefined ? never :
    S extends { include: any } & (role_usersArgs | role_usersFindManyArgs)
    ? role_users  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'roles' ? rolesGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (role_usersArgs | role_usersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'roles' ? rolesGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :  P extends keyof role_users ? role_users[P] : never
  } 
      : role_users


  type role_usersCountArgs = 
    Omit<role_usersFindManyArgs, 'select' | 'include'> & {
      select?: Role_usersCountAggregateInputType | true
    }

  export interface role_usersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Role_users that matches the filter.
     * @param {role_usersFindUniqueArgs} args - Arguments to find a Role_users
     * @example
     * // Get one Role_users
     * const role_users = await prisma.role_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends role_usersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, role_usersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'role_users'> extends True ? Prisma__role_usersClient<role_usersGetPayload<T>> : Prisma__role_usersClient<role_usersGetPayload<T> | null, null>

    /**
     * Find one Role_users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {role_usersFindUniqueOrThrowArgs} args - Arguments to find a Role_users
     * @example
     * // Get one Role_users
     * const role_users = await prisma.role_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends role_usersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, role_usersFindUniqueOrThrowArgs>
    ): Prisma__role_usersClient<role_usersGetPayload<T>>

    /**
     * Find the first Role_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_usersFindFirstArgs} args - Arguments to find a Role_users
     * @example
     * // Get one Role_users
     * const role_users = await prisma.role_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends role_usersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, role_usersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'role_users'> extends True ? Prisma__role_usersClient<role_usersGetPayload<T>> : Prisma__role_usersClient<role_usersGetPayload<T> | null, null>

    /**
     * Find the first Role_users that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_usersFindFirstOrThrowArgs} args - Arguments to find a Role_users
     * @example
     * // Get one Role_users
     * const role_users = await prisma.role_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends role_usersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, role_usersFindFirstOrThrowArgs>
    ): Prisma__role_usersClient<role_usersGetPayload<T>>

    /**
     * Find zero or more Role_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Role_users
     * const role_users = await prisma.role_users.findMany()
     * 
     * // Get first 10 Role_users
     * const role_users = await prisma.role_users.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const role_usersWithUser_idOnly = await prisma.role_users.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends role_usersFindManyArgs>(
      args?: SelectSubset<T, role_usersFindManyArgs>
    ): Prisma.PrismaPromise<Array<role_usersGetPayload<T>>>

    /**
     * Create a Role_users.
     * @param {role_usersCreateArgs} args - Arguments to create a Role_users.
     * @example
     * // Create one Role_users
     * const Role_users = await prisma.role_users.create({
     *   data: {
     *     // ... data to create a Role_users
     *   }
     * })
     * 
    **/
    create<T extends role_usersCreateArgs>(
      args: SelectSubset<T, role_usersCreateArgs>
    ): Prisma__role_usersClient<role_usersGetPayload<T>>

    /**
     * Create many Role_users.
     *     @param {role_usersCreateManyArgs} args - Arguments to create many Role_users.
     *     @example
     *     // Create many Role_users
     *     const role_users = await prisma.role_users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends role_usersCreateManyArgs>(
      args?: SelectSubset<T, role_usersCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role_users.
     * @param {role_usersDeleteArgs} args - Arguments to delete one Role_users.
     * @example
     * // Delete one Role_users
     * const Role_users = await prisma.role_users.delete({
     *   where: {
     *     // ... filter to delete one Role_users
     *   }
     * })
     * 
    **/
    delete<T extends role_usersDeleteArgs>(
      args: SelectSubset<T, role_usersDeleteArgs>
    ): Prisma__role_usersClient<role_usersGetPayload<T>>

    /**
     * Update one Role_users.
     * @param {role_usersUpdateArgs} args - Arguments to update one Role_users.
     * @example
     * // Update one Role_users
     * const role_users = await prisma.role_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends role_usersUpdateArgs>(
      args: SelectSubset<T, role_usersUpdateArgs>
    ): Prisma__role_usersClient<role_usersGetPayload<T>>

    /**
     * Delete zero or more Role_users.
     * @param {role_usersDeleteManyArgs} args - Arguments to filter Role_users to delete.
     * @example
     * // Delete a few Role_users
     * const { count } = await prisma.role_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends role_usersDeleteManyArgs>(
      args?: SelectSubset<T, role_usersDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Role_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Role_users
     * const role_users = await prisma.role_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends role_usersUpdateManyArgs>(
      args: SelectSubset<T, role_usersUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role_users.
     * @param {role_usersUpsertArgs} args - Arguments to update or create a Role_users.
     * @example
     * // Update or create a Role_users
     * const role_users = await prisma.role_users.upsert({
     *   create: {
     *     // ... data to create a Role_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role_users we want to update
     *   }
     * })
    **/
    upsert<T extends role_usersUpsertArgs>(
      args: SelectSubset<T, role_usersUpsertArgs>
    ): Prisma__role_usersClient<role_usersGetPayload<T>>

    /**
     * Count the number of Role_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_usersCountArgs} args - Arguments to filter Role_users to count.
     * @example
     * // Count the number of Role_users
     * const count = await prisma.role_users.count({
     *   where: {
     *     // ... the filter for the Role_users we want to count
     *   }
     * })
    **/
    count<T extends role_usersCountArgs>(
      args?: Subset<T, role_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Role_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Role_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Role_usersAggregateArgs>(args: Subset<T, Role_usersAggregateArgs>): Prisma.PrismaPromise<GetRole_usersAggregateType<T>>

    /**
     * Group by Role_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Role_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Role_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Role_usersGroupByArgs['orderBy'] }
        : { orderBy?: Role_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Role_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRole_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for role_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__role_usersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    roles<T extends rolesArgs= {}>(args?: Subset<T, rolesArgs>): Prisma__rolesClient<rolesGetPayload<T> | Null>;

    users<T extends usersArgs= {}>(args?: Subset<T, usersArgs>): Prisma__usersClient<usersGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * role_users base type for findUnique actions
   */
  export type role_usersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the role_users
     */
    select?: role_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: role_usersInclude | null
    /**
     * Filter, which role_users to fetch.
     */
    where: role_usersWhereUniqueInput
  }

  /**
   * role_users findUnique
   */
  export interface role_usersFindUniqueArgs extends role_usersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * role_users findUniqueOrThrow
   */
  export type role_usersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the role_users
     */
    select?: role_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: role_usersInclude | null
    /**
     * Filter, which role_users to fetch.
     */
    where: role_usersWhereUniqueInput
  }


  /**
   * role_users base type for findFirst actions
   */
  export type role_usersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the role_users
     */
    select?: role_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: role_usersInclude | null
    /**
     * Filter, which role_users to fetch.
     */
    where?: role_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_users to fetch.
     */
    orderBy?: Enumerable<role_usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_users.
     */
    cursor?: role_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_users.
     */
    distinct?: Enumerable<Role_usersScalarFieldEnum>
  }

  /**
   * role_users findFirst
   */
  export interface role_usersFindFirstArgs extends role_usersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * role_users findFirstOrThrow
   */
  export type role_usersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the role_users
     */
    select?: role_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: role_usersInclude | null
    /**
     * Filter, which role_users to fetch.
     */
    where?: role_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_users to fetch.
     */
    orderBy?: Enumerable<role_usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_users.
     */
    cursor?: role_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_users.
     */
    distinct?: Enumerable<Role_usersScalarFieldEnum>
  }


  /**
   * role_users findMany
   */
  export type role_usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the role_users
     */
    select?: role_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: role_usersInclude | null
    /**
     * Filter, which role_users to fetch.
     */
    where?: role_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_users to fetch.
     */
    orderBy?: Enumerable<role_usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing role_users.
     */
    cursor?: role_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_users.
     */
    skip?: number
    distinct?: Enumerable<Role_usersScalarFieldEnum>
  }


  /**
   * role_users create
   */
  export type role_usersCreateArgs = {
    /**
     * Select specific fields to fetch from the role_users
     */
    select?: role_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: role_usersInclude | null
    /**
     * The data needed to create a role_users.
     */
    data: XOR<role_usersCreateInput, role_usersUncheckedCreateInput>
  }


  /**
   * role_users createMany
   */
  export type role_usersCreateManyArgs = {
    /**
     * The data used to create many role_users.
     */
    data: Enumerable<role_usersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * role_users update
   */
  export type role_usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the role_users
     */
    select?: role_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: role_usersInclude | null
    /**
     * The data needed to update a role_users.
     */
    data: XOR<role_usersUpdateInput, role_usersUncheckedUpdateInput>
    /**
     * Choose, which role_users to update.
     */
    where: role_usersWhereUniqueInput
  }


  /**
   * role_users updateMany
   */
  export type role_usersUpdateManyArgs = {
    /**
     * The data used to update role_users.
     */
    data: XOR<role_usersUpdateManyMutationInput, role_usersUncheckedUpdateManyInput>
    /**
     * Filter which role_users to update
     */
    where?: role_usersWhereInput
  }


  /**
   * role_users upsert
   */
  export type role_usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the role_users
     */
    select?: role_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: role_usersInclude | null
    /**
     * The filter to search for the role_users to update in case it exists.
     */
    where: role_usersWhereUniqueInput
    /**
     * In case the role_users found by the `where` argument doesn't exist, create a new role_users with this data.
     */
    create: XOR<role_usersCreateInput, role_usersUncheckedCreateInput>
    /**
     * In case the role_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<role_usersUpdateInput, role_usersUncheckedUpdateInput>
  }


  /**
   * role_users delete
   */
  export type role_usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the role_users
     */
    select?: role_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: role_usersInclude | null
    /**
     * Filter which role_users to delete.
     */
    where: role_usersWhereUniqueInput
  }


  /**
   * role_users deleteMany
   */
  export type role_usersDeleteManyArgs = {
    /**
     * Filter which role_users to delete
     */
    where?: role_usersWhereInput
  }


  /**
   * role_users without action
   */
  export type role_usersArgs = {
    /**
     * Select specific fields to fetch from the role_users
     */
    select?: role_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: role_usersInclude | null
  }



  /**
   * Model roles
   */


  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    permissions: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    permissions: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    permissions: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    permissions?: true
    created_at?: true
    updated_at?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    permissions?: true
    created_at?: true
    updated_at?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    permissions?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RolesAggregateArgs = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: Enumerable<rolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs = {
    where?: rolesWhereInput
    orderBy?: Enumerable<rolesOrderByWithAggregationInput>
    by: RolesScalarFieldEnum[]
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }


  export type RolesGroupByOutputType = {
    id: number
    slug: string
    name: string
    permissions: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect = {
    id?: boolean
    slug?: boolean
    name?: boolean
    permissions?: boolean
    created_at?: boolean
    updated_at?: boolean
    role_users?: boolean | roles$role_usersArgs
    _count?: boolean | RolesCountOutputTypeArgs
  }


  export type rolesInclude = {
    role_users?: boolean | roles$role_usersArgs
    _count?: boolean | RolesCountOutputTypeArgs
  }

  export type rolesGetPayload<S extends boolean | null | undefined | rolesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? roles :
    S extends undefined ? never :
    S extends { include: any } & (rolesArgs | rolesFindManyArgs)
    ? roles  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'role_users' ? Array < role_usersGetPayload<S['include'][P]>>  :
        P extends '_count' ? RolesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (rolesArgs | rolesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'role_users' ? Array < role_usersGetPayload<S['select'][P]>>  :
        P extends '_count' ? RolesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof roles ? roles[P] : never
  } 
      : roles


  type rolesCountArgs = 
    Omit<rolesFindManyArgs, 'select' | 'include'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rolesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, rolesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'roles'> extends True ? Prisma__rolesClient<rolesGetPayload<T>> : Prisma__rolesClient<rolesGetPayload<T> | null, null>

    /**
     * Find one Roles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, rolesFindUniqueOrThrowArgs>
    ): Prisma__rolesClient<rolesGetPayload<T>>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rolesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, rolesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'roles'> extends True ? Prisma__rolesClient<rolesGetPayload<T>> : Prisma__rolesClient<rolesGetPayload<T> | null, null>

    /**
     * Find the first Roles that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, rolesFindFirstOrThrowArgs>
    ): Prisma__rolesClient<rolesGetPayload<T>>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends rolesFindManyArgs>(
      args?: SelectSubset<T, rolesFindManyArgs>
    ): Prisma.PrismaPromise<Array<rolesGetPayload<T>>>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
    **/
    create<T extends rolesCreateArgs>(
      args: SelectSubset<T, rolesCreateArgs>
    ): Prisma__rolesClient<rolesGetPayload<T>>

    /**
     * Create many Roles.
     *     @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const roles = await prisma.roles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rolesCreateManyArgs>(
      args?: SelectSubset<T, rolesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
    **/
    delete<T extends rolesDeleteArgs>(
      args: SelectSubset<T, rolesDeleteArgs>
    ): Prisma__rolesClient<rolesGetPayload<T>>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rolesUpdateArgs>(
      args: SelectSubset<T, rolesUpdateArgs>
    ): Prisma__rolesClient<rolesGetPayload<T>>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rolesDeleteManyArgs>(
      args?: SelectSubset<T, rolesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rolesUpdateManyArgs>(
      args: SelectSubset<T, rolesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
    **/
    upsert<T extends rolesUpsertArgs>(
      args: SelectSubset<T, rolesUpsertArgs>
    ): Prisma__rolesClient<rolesGetPayload<T>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__rolesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    role_users<T extends roles$role_usersArgs= {}>(args?: Subset<T, roles$role_usersArgs>): Prisma.PrismaPromise<Array<role_usersGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * roles base type for findUnique actions
   */
  export type rolesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUnique
   */
  export interface rolesFindUniqueArgs extends rolesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }


  /**
   * roles base type for findFirst actions
   */
  export type rolesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: Enumerable<rolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: Enumerable<RolesScalarFieldEnum>
  }

  /**
   * roles findFirst
   */
  export interface rolesFindFirstArgs extends rolesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: Enumerable<rolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: Enumerable<RolesScalarFieldEnum>
  }


  /**
   * roles findMany
   */
  export type rolesFindManyArgs = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: Enumerable<rolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: Enumerable<RolesScalarFieldEnum>
  }


  /**
   * roles create
   */
  export type rolesCreateArgs = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }


  /**
   * roles createMany
   */
  export type rolesCreateManyArgs = {
    /**
     * The data used to create many roles.
     */
    data: Enumerable<rolesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * roles update
   */
  export type rolesUpdateArgs = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }


  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
  }


  /**
   * roles upsert
   */
  export type rolesUpsertArgs = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }


  /**
   * roles delete
   */
  export type rolesDeleteArgs = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }


  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
  }


  /**
   * roles.role_users
   */
  export type roles$role_usersArgs = {
    /**
     * Select specific fields to fetch from the role_users
     */
    select?: role_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: role_usersInclude | null
    where?: role_usersWhereInput
    orderBy?: Enumerable<role_usersOrderByWithRelationInput>
    cursor?: role_usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Role_usersScalarFieldEnum>
  }


  /**
   * roles without action
   */
  export type rolesArgs = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude | null
  }



  /**
   * Model services
   */


  export type AggregateServices = {
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  export type ServicesAvgAggregateOutputType = {
    id: number | null
  }

  export type ServicesSumAggregateOutputType = {
    id: number | null
  }

  export type ServicesMinAggregateOutputType = {
    id: number | null
    Name: string | null
    Status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServicesMaxAggregateOutputType = {
    id: number | null
    Name: string | null
    Status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServicesCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ServicesAvgAggregateInputType = {
    id?: true
  }

  export type ServicesSumAggregateInputType = {
    id?: true
  }

  export type ServicesMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    created_at?: true
    updated_at?: true
  }

  export type ServicesMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    created_at?: true
    updated_at?: true
  }

  export type ServicesCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ServicesAggregateArgs = {
    /**
     * Filter which services to aggregate.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: Enumerable<servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned services
    **/
    _count?: true | ServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesMaxAggregateInputType
  }

  export type GetServicesAggregateType<T extends ServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServices[P]>
      : GetScalarType<T[P], AggregateServices[P]>
  }




  export type ServicesGroupByArgs = {
    where?: servicesWhereInput
    orderBy?: Enumerable<servicesOrderByWithAggregationInput>
    by: ServicesScalarFieldEnum[]
    having?: servicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesCountAggregateInputType | true
    _avg?: ServicesAvgAggregateInputType
    _sum?: ServicesSumAggregateInputType
    _min?: ServicesMinAggregateInputType
    _max?: ServicesMaxAggregateInputType
  }


  export type ServicesGroupByOutputType = {
    id: number
    Name: string | null
    Status: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  type GetServicesGroupByPayload<T extends ServicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesGroupByOutputType[P]>
        }
      >
    >


  export type servicesSelect = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    created_at?: boolean
    updated_at?: boolean
    airport_services?: boolean | services$airport_servicesArgs
    gratuities?: boolean | services$gratuitiesArgs
    hourly_services?: boolean | services$hourly_servicesArgs
    point_to_point_services?: boolean | services$point_to_point_servicesArgs
    sub_services?: boolean | services$sub_servicesArgs
    _count?: boolean | ServicesCountOutputTypeArgs
  }


  export type servicesInclude = {
    airport_services?: boolean | services$airport_servicesArgs
    gratuities?: boolean | services$gratuitiesArgs
    hourly_services?: boolean | services$hourly_servicesArgs
    point_to_point_services?: boolean | services$point_to_point_servicesArgs
    sub_services?: boolean | services$sub_servicesArgs
    _count?: boolean | ServicesCountOutputTypeArgs
  }

  export type servicesGetPayload<S extends boolean | null | undefined | servicesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? services :
    S extends undefined ? never :
    S extends { include: any } & (servicesArgs | servicesFindManyArgs)
    ? services  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'airport_services' ? Array < airport_servicesGetPayload<S['include'][P]>>  :
        P extends 'gratuities' ? Array < gratuitiesGetPayload<S['include'][P]>>  :
        P extends 'hourly_services' ? Array < hourly_servicesGetPayload<S['include'][P]>>  :
        P extends 'point_to_point_services' ? Array < point_to_point_servicesGetPayload<S['include'][P]>>  :
        P extends 'sub_services' ? Array < sub_servicesGetPayload<S['include'][P]>>  :
        P extends '_count' ? ServicesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (servicesArgs | servicesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'airport_services' ? Array < airport_servicesGetPayload<S['select'][P]>>  :
        P extends 'gratuities' ? Array < gratuitiesGetPayload<S['select'][P]>>  :
        P extends 'hourly_services' ? Array < hourly_servicesGetPayload<S['select'][P]>>  :
        P extends 'point_to_point_services' ? Array < point_to_point_servicesGetPayload<S['select'][P]>>  :
        P extends 'sub_services' ? Array < sub_servicesGetPayload<S['select'][P]>>  :
        P extends '_count' ? ServicesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof services ? services[P] : never
  } 
      : services


  type servicesCountArgs = 
    Omit<servicesFindManyArgs, 'select' | 'include'> & {
      select?: ServicesCountAggregateInputType | true
    }

  export interface servicesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Services that matches the filter.
     * @param {servicesFindUniqueArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'services'> extends True ? Prisma__servicesClient<servicesGetPayload<T>> : Prisma__servicesClient<servicesGetPayload<T> | null, null>

    /**
     * Find one Services that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicesFindUniqueOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, servicesFindUniqueOrThrowArgs>
    ): Prisma__servicesClient<servicesGetPayload<T>>

    /**
     * Find the first Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindFirstArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'services'> extends True ? Prisma__servicesClient<servicesGetPayload<T>> : Prisma__servicesClient<servicesGetPayload<T> | null, null>

    /**
     * Find the first Services that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindFirstOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, servicesFindFirstOrThrowArgs>
    ): Prisma__servicesClient<servicesGetPayload<T>>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.services.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.services.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicesWithIdOnly = await prisma.services.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends servicesFindManyArgs>(
      args?: SelectSubset<T, servicesFindManyArgs>
    ): Prisma.PrismaPromise<Array<servicesGetPayload<T>>>

    /**
     * Create a Services.
     * @param {servicesCreateArgs} args - Arguments to create a Services.
     * @example
     * // Create one Services
     * const Services = await prisma.services.create({
     *   data: {
     *     // ... data to create a Services
     *   }
     * })
     * 
    **/
    create<T extends servicesCreateArgs>(
      args: SelectSubset<T, servicesCreateArgs>
    ): Prisma__servicesClient<servicesGetPayload<T>>

    /**
     * Create many Services.
     *     @param {servicesCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const services = await prisma.services.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicesCreateManyArgs>(
      args?: SelectSubset<T, servicesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Services.
     * @param {servicesDeleteArgs} args - Arguments to delete one Services.
     * @example
     * // Delete one Services
     * const Services = await prisma.services.delete({
     *   where: {
     *     // ... filter to delete one Services
     *   }
     * })
     * 
    **/
    delete<T extends servicesDeleteArgs>(
      args: SelectSubset<T, servicesDeleteArgs>
    ): Prisma__servicesClient<servicesGetPayload<T>>

    /**
     * Update one Services.
     * @param {servicesUpdateArgs} args - Arguments to update one Services.
     * @example
     * // Update one Services
     * const services = await prisma.services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicesUpdateArgs>(
      args: SelectSubset<T, servicesUpdateArgs>
    ): Prisma__servicesClient<servicesGetPayload<T>>

    /**
     * Delete zero or more Services.
     * @param {servicesDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicesDeleteManyArgs>(
      args?: SelectSubset<T, servicesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const services = await prisma.services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicesUpdateManyArgs>(
      args: SelectSubset<T, servicesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Services.
     * @param {servicesUpsertArgs} args - Arguments to update or create a Services.
     * @example
     * // Update or create a Services
     * const services = await prisma.services.upsert({
     *   create: {
     *     // ... data to create a Services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Services we want to update
     *   }
     * })
    **/
    upsert<T extends servicesUpsertArgs>(
      args: SelectSubset<T, servicesUpsertArgs>
    ): Prisma__servicesClient<servicesGetPayload<T>>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.services.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends servicesCountArgs>(
      args?: Subset<T, servicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesAggregateArgs>(args: Subset<T, ServicesAggregateArgs>): Prisma.PrismaPromise<GetServicesAggregateType<T>>

    /**
     * Group by Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicesGroupByArgs['orderBy'] }
        : { orderBy?: ServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    airport_services<T extends services$airport_servicesArgs= {}>(args?: Subset<T, services$airport_servicesArgs>): Prisma.PrismaPromise<Array<airport_servicesGetPayload<T>>| Null>;

    gratuities<T extends services$gratuitiesArgs= {}>(args?: Subset<T, services$gratuitiesArgs>): Prisma.PrismaPromise<Array<gratuitiesGetPayload<T>>| Null>;

    hourly_services<T extends services$hourly_servicesArgs= {}>(args?: Subset<T, services$hourly_servicesArgs>): Prisma.PrismaPromise<Array<hourly_servicesGetPayload<T>>| Null>;

    point_to_point_services<T extends services$point_to_point_servicesArgs= {}>(args?: Subset<T, services$point_to_point_servicesArgs>): Prisma.PrismaPromise<Array<point_to_point_servicesGetPayload<T>>| Null>;

    sub_services<T extends services$sub_servicesArgs= {}>(args?: Subset<T, services$sub_servicesArgs>): Prisma.PrismaPromise<Array<sub_servicesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * services base type for findUnique actions
   */
  export type servicesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude | null
    /**
     * Filter, which services to fetch.
     */
    where: servicesWhereUniqueInput
  }

  /**
   * services findUnique
   */
  export interface servicesFindUniqueArgs extends servicesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * services findUniqueOrThrow
   */
  export type servicesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude | null
    /**
     * Filter, which services to fetch.
     */
    where: servicesWhereUniqueInput
  }


  /**
   * services base type for findFirst actions
   */
  export type servicesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: Enumerable<servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: Enumerable<ServicesScalarFieldEnum>
  }

  /**
   * services findFirst
   */
  export interface servicesFindFirstArgs extends servicesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * services findFirstOrThrow
   */
  export type servicesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: Enumerable<servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: Enumerable<ServicesScalarFieldEnum>
  }


  /**
   * services findMany
   */
  export type servicesFindManyArgs = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: Enumerable<servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    distinct?: Enumerable<ServicesScalarFieldEnum>
  }


  /**
   * services create
   */
  export type servicesCreateArgs = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude | null
    /**
     * The data needed to create a services.
     */
    data: XOR<servicesCreateInput, servicesUncheckedCreateInput>
  }


  /**
   * services createMany
   */
  export type servicesCreateManyArgs = {
    /**
     * The data used to create many services.
     */
    data: Enumerable<servicesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * services update
   */
  export type servicesUpdateArgs = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude | null
    /**
     * The data needed to update a services.
     */
    data: XOR<servicesUpdateInput, servicesUncheckedUpdateInput>
    /**
     * Choose, which services to update.
     */
    where: servicesWhereUniqueInput
  }


  /**
   * services updateMany
   */
  export type servicesUpdateManyArgs = {
    /**
     * The data used to update services.
     */
    data: XOR<servicesUpdateManyMutationInput, servicesUncheckedUpdateManyInput>
    /**
     * Filter which services to update
     */
    where?: servicesWhereInput
  }


  /**
   * services upsert
   */
  export type servicesUpsertArgs = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude | null
    /**
     * The filter to search for the services to update in case it exists.
     */
    where: servicesWhereUniqueInput
    /**
     * In case the services found by the `where` argument doesn't exist, create a new services with this data.
     */
    create: XOR<servicesCreateInput, servicesUncheckedCreateInput>
    /**
     * In case the services was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicesUpdateInput, servicesUncheckedUpdateInput>
  }


  /**
   * services delete
   */
  export type servicesDeleteArgs = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude | null
    /**
     * Filter which services to delete.
     */
    where: servicesWhereUniqueInput
  }


  /**
   * services deleteMany
   */
  export type servicesDeleteManyArgs = {
    /**
     * Filter which services to delete
     */
    where?: servicesWhereInput
  }


  /**
   * services.airport_services
   */
  export type services$airport_servicesArgs = {
    /**
     * Select specific fields to fetch from the airport_services
     */
    select?: airport_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: airport_servicesInclude | null
    where?: airport_servicesWhereInput
    orderBy?: Enumerable<airport_servicesOrderByWithRelationInput>
    cursor?: airport_servicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Airport_servicesScalarFieldEnum>
  }


  /**
   * services.gratuities
   */
  export type services$gratuitiesArgs = {
    /**
     * Select specific fields to fetch from the gratuities
     */
    select?: gratuitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: gratuitiesInclude | null
    where?: gratuitiesWhereInput
    orderBy?: Enumerable<gratuitiesOrderByWithRelationInput>
    cursor?: gratuitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GratuitiesScalarFieldEnum>
  }


  /**
   * services.hourly_services
   */
  export type services$hourly_servicesArgs = {
    /**
     * Select specific fields to fetch from the hourly_services
     */
    select?: hourly_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: hourly_servicesInclude | null
    where?: hourly_servicesWhereInput
    orderBy?: Enumerable<hourly_servicesOrderByWithRelationInput>
    cursor?: hourly_servicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Hourly_servicesScalarFieldEnum>
  }


  /**
   * services.point_to_point_services
   */
  export type services$point_to_point_servicesArgs = {
    /**
     * Select specific fields to fetch from the point_to_point_services
     */
    select?: point_to_point_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: point_to_point_servicesInclude | null
    where?: point_to_point_servicesWhereInput
    orderBy?: Enumerable<point_to_point_servicesOrderByWithRelationInput>
    cursor?: point_to_point_servicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Point_to_point_servicesScalarFieldEnum>
  }


  /**
   * services.sub_services
   */
  export type services$sub_servicesArgs = {
    /**
     * Select specific fields to fetch from the sub_services
     */
    select?: sub_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_servicesInclude | null
    where?: sub_servicesWhereInput
    orderBy?: Enumerable<sub_servicesOrderByWithRelationInput>
    cursor?: sub_servicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Sub_servicesScalarFieldEnum>
  }


  /**
   * services without action
   */
  export type servicesArgs = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude | null
  }



  /**
   * Model sys_settings
   */


  export type AggregateSys_settings = {
    _count: Sys_settingsCountAggregateOutputType | null
    _avg: Sys_settingsAvgAggregateOutputType | null
    _sum: Sys_settingsSumAggregateOutputType | null
    _min: Sys_settingsMinAggregateOutputType | null
    _max: Sys_settingsMaxAggregateOutputType | null
  }

  export type Sys_settingsAvgAggregateOutputType = {
    id: number | null
  }

  export type Sys_settingsSumAggregateOutputType = {
    id: number | null
  }

  export type Sys_settingsMinAggregateOutputType = {
    id: number | null
    sys_name: string | null
    sys_details: string | null
    Created_on: Date | null
    setting_key: string | null
  }

  export type Sys_settingsMaxAggregateOutputType = {
    id: number | null
    sys_name: string | null
    sys_details: string | null
    Created_on: Date | null
    setting_key: string | null
  }

  export type Sys_settingsCountAggregateOutputType = {
    id: number
    sys_name: number
    sys_details: number
    Created_on: number
    setting_key: number
    _all: number
  }


  export type Sys_settingsAvgAggregateInputType = {
    id?: true
  }

  export type Sys_settingsSumAggregateInputType = {
    id?: true
  }

  export type Sys_settingsMinAggregateInputType = {
    id?: true
    sys_name?: true
    sys_details?: true
    Created_on?: true
    setting_key?: true
  }

  export type Sys_settingsMaxAggregateInputType = {
    id?: true
    sys_name?: true
    sys_details?: true
    Created_on?: true
    setting_key?: true
  }

  export type Sys_settingsCountAggregateInputType = {
    id?: true
    sys_name?: true
    sys_details?: true
    Created_on?: true
    setting_key?: true
    _all?: true
  }

  export type Sys_settingsAggregateArgs = {
    /**
     * Filter which sys_settings to aggregate.
     */
    where?: sys_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_settings to fetch.
     */
    orderBy?: Enumerable<sys_settingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sys_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sys_settings
    **/
    _count?: true | Sys_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sys_settingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sys_settingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sys_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sys_settingsMaxAggregateInputType
  }

  export type GetSys_settingsAggregateType<T extends Sys_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSys_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSys_settings[P]>
      : GetScalarType<T[P], AggregateSys_settings[P]>
  }




  export type Sys_settingsGroupByArgs = {
    where?: sys_settingsWhereInput
    orderBy?: Enumerable<sys_settingsOrderByWithAggregationInput>
    by: Sys_settingsScalarFieldEnum[]
    having?: sys_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sys_settingsCountAggregateInputType | true
    _avg?: Sys_settingsAvgAggregateInputType
    _sum?: Sys_settingsSumAggregateInputType
    _min?: Sys_settingsMinAggregateInputType
    _max?: Sys_settingsMaxAggregateInputType
  }


  export type Sys_settingsGroupByOutputType = {
    id: number
    sys_name: string
    sys_details: string
    Created_on: Date
    setting_key: string
    _count: Sys_settingsCountAggregateOutputType | null
    _avg: Sys_settingsAvgAggregateOutputType | null
    _sum: Sys_settingsSumAggregateOutputType | null
    _min: Sys_settingsMinAggregateOutputType | null
    _max: Sys_settingsMaxAggregateOutputType | null
  }

  type GetSys_settingsGroupByPayload<T extends Sys_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Sys_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sys_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sys_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], Sys_settingsGroupByOutputType[P]>
        }
      >
    >


  export type sys_settingsSelect = {
    id?: boolean
    sys_name?: boolean
    sys_details?: boolean
    Created_on?: boolean
    setting_key?: boolean
  }


  export type sys_settingsGetPayload<S extends boolean | null | undefined | sys_settingsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? sys_settings :
    S extends undefined ? never :
    S extends { include: any } & (sys_settingsArgs | sys_settingsFindManyArgs)
    ? sys_settings 
    : S extends { select: any } & (sys_settingsArgs | sys_settingsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof sys_settings ? sys_settings[P] : never
  } 
      : sys_settings


  type sys_settingsCountArgs = 
    Omit<sys_settingsFindManyArgs, 'select' | 'include'> & {
      select?: Sys_settingsCountAggregateInputType | true
    }

  export interface sys_settingsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Sys_settings that matches the filter.
     * @param {sys_settingsFindUniqueArgs} args - Arguments to find a Sys_settings
     * @example
     * // Get one Sys_settings
     * const sys_settings = await prisma.sys_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sys_settingsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sys_settingsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sys_settings'> extends True ? Prisma__sys_settingsClient<sys_settingsGetPayload<T>> : Prisma__sys_settingsClient<sys_settingsGetPayload<T> | null, null>

    /**
     * Find one Sys_settings that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sys_settingsFindUniqueOrThrowArgs} args - Arguments to find a Sys_settings
     * @example
     * // Get one Sys_settings
     * const sys_settings = await prisma.sys_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sys_settingsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, sys_settingsFindUniqueOrThrowArgs>
    ): Prisma__sys_settingsClient<sys_settingsGetPayload<T>>

    /**
     * Find the first Sys_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_settingsFindFirstArgs} args - Arguments to find a Sys_settings
     * @example
     * // Get one Sys_settings
     * const sys_settings = await prisma.sys_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sys_settingsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sys_settingsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sys_settings'> extends True ? Prisma__sys_settingsClient<sys_settingsGetPayload<T>> : Prisma__sys_settingsClient<sys_settingsGetPayload<T> | null, null>

    /**
     * Find the first Sys_settings that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_settingsFindFirstOrThrowArgs} args - Arguments to find a Sys_settings
     * @example
     * // Get one Sys_settings
     * const sys_settings = await prisma.sys_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sys_settingsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, sys_settingsFindFirstOrThrowArgs>
    ): Prisma__sys_settingsClient<sys_settingsGetPayload<T>>

    /**
     * Find zero or more Sys_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_settingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sys_settings
     * const sys_settings = await prisma.sys_settings.findMany()
     * 
     * // Get first 10 Sys_settings
     * const sys_settings = await prisma.sys_settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sys_settingsWithIdOnly = await prisma.sys_settings.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sys_settingsFindManyArgs>(
      args?: SelectSubset<T, sys_settingsFindManyArgs>
    ): Prisma.PrismaPromise<Array<sys_settingsGetPayload<T>>>

    /**
     * Create a Sys_settings.
     * @param {sys_settingsCreateArgs} args - Arguments to create a Sys_settings.
     * @example
     * // Create one Sys_settings
     * const Sys_settings = await prisma.sys_settings.create({
     *   data: {
     *     // ... data to create a Sys_settings
     *   }
     * })
     * 
    **/
    create<T extends sys_settingsCreateArgs>(
      args: SelectSubset<T, sys_settingsCreateArgs>
    ): Prisma__sys_settingsClient<sys_settingsGetPayload<T>>

    /**
     * Create many Sys_settings.
     *     @param {sys_settingsCreateManyArgs} args - Arguments to create many Sys_settings.
     *     @example
     *     // Create many Sys_settings
     *     const sys_settings = await prisma.sys_settings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sys_settingsCreateManyArgs>(
      args?: SelectSubset<T, sys_settingsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sys_settings.
     * @param {sys_settingsDeleteArgs} args - Arguments to delete one Sys_settings.
     * @example
     * // Delete one Sys_settings
     * const Sys_settings = await prisma.sys_settings.delete({
     *   where: {
     *     // ... filter to delete one Sys_settings
     *   }
     * })
     * 
    **/
    delete<T extends sys_settingsDeleteArgs>(
      args: SelectSubset<T, sys_settingsDeleteArgs>
    ): Prisma__sys_settingsClient<sys_settingsGetPayload<T>>

    /**
     * Update one Sys_settings.
     * @param {sys_settingsUpdateArgs} args - Arguments to update one Sys_settings.
     * @example
     * // Update one Sys_settings
     * const sys_settings = await prisma.sys_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sys_settingsUpdateArgs>(
      args: SelectSubset<T, sys_settingsUpdateArgs>
    ): Prisma__sys_settingsClient<sys_settingsGetPayload<T>>

    /**
     * Delete zero or more Sys_settings.
     * @param {sys_settingsDeleteManyArgs} args - Arguments to filter Sys_settings to delete.
     * @example
     * // Delete a few Sys_settings
     * const { count } = await prisma.sys_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sys_settingsDeleteManyArgs>(
      args?: SelectSubset<T, sys_settingsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sys_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sys_settings
     * const sys_settings = await prisma.sys_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sys_settingsUpdateManyArgs>(
      args: SelectSubset<T, sys_settingsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sys_settings.
     * @param {sys_settingsUpsertArgs} args - Arguments to update or create a Sys_settings.
     * @example
     * // Update or create a Sys_settings
     * const sys_settings = await prisma.sys_settings.upsert({
     *   create: {
     *     // ... data to create a Sys_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sys_settings we want to update
     *   }
     * })
    **/
    upsert<T extends sys_settingsUpsertArgs>(
      args: SelectSubset<T, sys_settingsUpsertArgs>
    ): Prisma__sys_settingsClient<sys_settingsGetPayload<T>>

    /**
     * Count the number of Sys_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sys_settingsCountArgs} args - Arguments to filter Sys_settings to count.
     * @example
     * // Count the number of Sys_settings
     * const count = await prisma.sys_settings.count({
     *   where: {
     *     // ... the filter for the Sys_settings we want to count
     *   }
     * })
    **/
    count<T extends sys_settingsCountArgs>(
      args?: Subset<T, sys_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sys_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sys_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sys_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sys_settingsAggregateArgs>(args: Subset<T, Sys_settingsAggregateArgs>): Prisma.PrismaPromise<GetSys_settingsAggregateType<T>>

    /**
     * Group by Sys_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sys_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Sys_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Sys_settingsGroupByArgs['orderBy'] }
        : { orderBy?: Sys_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Sys_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSys_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for sys_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sys_settingsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * sys_settings base type for findUnique actions
   */
  export type sys_settingsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the sys_settings
     */
    select?: sys_settingsSelect | null
    /**
     * Filter, which sys_settings to fetch.
     */
    where: sys_settingsWhereUniqueInput
  }

  /**
   * sys_settings findUnique
   */
  export interface sys_settingsFindUniqueArgs extends sys_settingsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sys_settings findUniqueOrThrow
   */
  export type sys_settingsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the sys_settings
     */
    select?: sys_settingsSelect | null
    /**
     * Filter, which sys_settings to fetch.
     */
    where: sys_settingsWhereUniqueInput
  }


  /**
   * sys_settings base type for findFirst actions
   */
  export type sys_settingsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the sys_settings
     */
    select?: sys_settingsSelect | null
    /**
     * Filter, which sys_settings to fetch.
     */
    where?: sys_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_settings to fetch.
     */
    orderBy?: Enumerable<sys_settingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_settings.
     */
    cursor?: sys_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_settings.
     */
    distinct?: Enumerable<Sys_settingsScalarFieldEnum>
  }

  /**
   * sys_settings findFirst
   */
  export interface sys_settingsFindFirstArgs extends sys_settingsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sys_settings findFirstOrThrow
   */
  export type sys_settingsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the sys_settings
     */
    select?: sys_settingsSelect | null
    /**
     * Filter, which sys_settings to fetch.
     */
    where?: sys_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_settings to fetch.
     */
    orderBy?: Enumerable<sys_settingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sys_settings.
     */
    cursor?: sys_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sys_settings.
     */
    distinct?: Enumerable<Sys_settingsScalarFieldEnum>
  }


  /**
   * sys_settings findMany
   */
  export type sys_settingsFindManyArgs = {
    /**
     * Select specific fields to fetch from the sys_settings
     */
    select?: sys_settingsSelect | null
    /**
     * Filter, which sys_settings to fetch.
     */
    where?: sys_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sys_settings to fetch.
     */
    orderBy?: Enumerable<sys_settingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sys_settings.
     */
    cursor?: sys_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sys_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sys_settings.
     */
    skip?: number
    distinct?: Enumerable<Sys_settingsScalarFieldEnum>
  }


  /**
   * sys_settings create
   */
  export type sys_settingsCreateArgs = {
    /**
     * Select specific fields to fetch from the sys_settings
     */
    select?: sys_settingsSelect | null
    /**
     * The data needed to create a sys_settings.
     */
    data: XOR<sys_settingsCreateInput, sys_settingsUncheckedCreateInput>
  }


  /**
   * sys_settings createMany
   */
  export type sys_settingsCreateManyArgs = {
    /**
     * The data used to create many sys_settings.
     */
    data: Enumerable<sys_settingsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * sys_settings update
   */
  export type sys_settingsUpdateArgs = {
    /**
     * Select specific fields to fetch from the sys_settings
     */
    select?: sys_settingsSelect | null
    /**
     * The data needed to update a sys_settings.
     */
    data: XOR<sys_settingsUpdateInput, sys_settingsUncheckedUpdateInput>
    /**
     * Choose, which sys_settings to update.
     */
    where: sys_settingsWhereUniqueInput
  }


  /**
   * sys_settings updateMany
   */
  export type sys_settingsUpdateManyArgs = {
    /**
     * The data used to update sys_settings.
     */
    data: XOR<sys_settingsUpdateManyMutationInput, sys_settingsUncheckedUpdateManyInput>
    /**
     * Filter which sys_settings to update
     */
    where?: sys_settingsWhereInput
  }


  /**
   * sys_settings upsert
   */
  export type sys_settingsUpsertArgs = {
    /**
     * Select specific fields to fetch from the sys_settings
     */
    select?: sys_settingsSelect | null
    /**
     * The filter to search for the sys_settings to update in case it exists.
     */
    where: sys_settingsWhereUniqueInput
    /**
     * In case the sys_settings found by the `where` argument doesn't exist, create a new sys_settings with this data.
     */
    create: XOR<sys_settingsCreateInput, sys_settingsUncheckedCreateInput>
    /**
     * In case the sys_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sys_settingsUpdateInput, sys_settingsUncheckedUpdateInput>
  }


  /**
   * sys_settings delete
   */
  export type sys_settingsDeleteArgs = {
    /**
     * Select specific fields to fetch from the sys_settings
     */
    select?: sys_settingsSelect | null
    /**
     * Filter which sys_settings to delete.
     */
    where: sys_settingsWhereUniqueInput
  }


  /**
   * sys_settings deleteMany
   */
  export type sys_settingsDeleteManyArgs = {
    /**
     * Filter which sys_settings to delete
     */
    where?: sys_settingsWhereInput
  }


  /**
   * sys_settings without action
   */
  export type sys_settingsArgs = {
    /**
     * Select specific fields to fetch from the sys_settings
     */
    select?: sys_settingsSelect | null
  }



  /**
   * Model taggable_tags
   */


  export type AggregateTaggable_tags = {
    _count: Taggable_tagsCountAggregateOutputType | null
    _avg: Taggable_tagsAvgAggregateOutputType | null
    _sum: Taggable_tagsSumAggregateOutputType | null
    _min: Taggable_tagsMinAggregateOutputType | null
    _max: Taggable_tagsMaxAggregateOutputType | null
  }

  export type Taggable_tagsAvgAggregateOutputType = {
    tag_id: number | null
  }

  export type Taggable_tagsSumAggregateOutputType = {
    tag_id: number | null
  }

  export type Taggable_tagsMinAggregateOutputType = {
    tag_id: number | null
    name: string | null
    normalized: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Taggable_tagsMaxAggregateOutputType = {
    tag_id: number | null
    name: string | null
    normalized: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Taggable_tagsCountAggregateOutputType = {
    tag_id: number
    name: number
    normalized: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Taggable_tagsAvgAggregateInputType = {
    tag_id?: true
  }

  export type Taggable_tagsSumAggregateInputType = {
    tag_id?: true
  }

  export type Taggable_tagsMinAggregateInputType = {
    tag_id?: true
    name?: true
    normalized?: true
    created_at?: true
    updated_at?: true
  }

  export type Taggable_tagsMaxAggregateInputType = {
    tag_id?: true
    name?: true
    normalized?: true
    created_at?: true
    updated_at?: true
  }

  export type Taggable_tagsCountAggregateInputType = {
    tag_id?: true
    name?: true
    normalized?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Taggable_tagsAggregateArgs = {
    /**
     * Filter which taggable_tags to aggregate.
     */
    where?: taggable_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taggable_tags to fetch.
     */
    orderBy?: Enumerable<taggable_tagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: taggable_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taggable_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taggable_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned taggable_tags
    **/
    _count?: true | Taggable_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Taggable_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Taggable_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Taggable_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Taggable_tagsMaxAggregateInputType
  }

  export type GetTaggable_tagsAggregateType<T extends Taggable_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTaggable_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaggable_tags[P]>
      : GetScalarType<T[P], AggregateTaggable_tags[P]>
  }




  export type Taggable_tagsGroupByArgs = {
    where?: taggable_tagsWhereInput
    orderBy?: Enumerable<taggable_tagsOrderByWithAggregationInput>
    by: Taggable_tagsScalarFieldEnum[]
    having?: taggable_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Taggable_tagsCountAggregateInputType | true
    _avg?: Taggable_tagsAvgAggregateInputType
    _sum?: Taggable_tagsSumAggregateInputType
    _min?: Taggable_tagsMinAggregateInputType
    _max?: Taggable_tagsMaxAggregateInputType
  }


  export type Taggable_tagsGroupByOutputType = {
    tag_id: number
    name: string
    normalized: string
    created_at: Date | null
    updated_at: Date | null
    _count: Taggable_tagsCountAggregateOutputType | null
    _avg: Taggable_tagsAvgAggregateOutputType | null
    _sum: Taggable_tagsSumAggregateOutputType | null
    _min: Taggable_tagsMinAggregateOutputType | null
    _max: Taggable_tagsMaxAggregateOutputType | null
  }

  type GetTaggable_tagsGroupByPayload<T extends Taggable_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Taggable_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Taggable_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Taggable_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Taggable_tagsGroupByOutputType[P]>
        }
      >
    >


  export type taggable_tagsSelect = {
    tag_id?: boolean
    name?: boolean
    normalized?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type taggable_tagsGetPayload<S extends boolean | null | undefined | taggable_tagsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? taggable_tags :
    S extends undefined ? never :
    S extends { include: any } & (taggable_tagsArgs | taggable_tagsFindManyArgs)
    ? taggable_tags 
    : S extends { select: any } & (taggable_tagsArgs | taggable_tagsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof taggable_tags ? taggable_tags[P] : never
  } 
      : taggable_tags


  type taggable_tagsCountArgs = 
    Omit<taggable_tagsFindManyArgs, 'select' | 'include'> & {
      select?: Taggable_tagsCountAggregateInputType | true
    }

  export interface taggable_tagsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Taggable_tags that matches the filter.
     * @param {taggable_tagsFindUniqueArgs} args - Arguments to find a Taggable_tags
     * @example
     * // Get one Taggable_tags
     * const taggable_tags = await prisma.taggable_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends taggable_tagsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, taggable_tagsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'taggable_tags'> extends True ? Prisma__taggable_tagsClient<taggable_tagsGetPayload<T>> : Prisma__taggable_tagsClient<taggable_tagsGetPayload<T> | null, null>

    /**
     * Find one Taggable_tags that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {taggable_tagsFindUniqueOrThrowArgs} args - Arguments to find a Taggable_tags
     * @example
     * // Get one Taggable_tags
     * const taggable_tags = await prisma.taggable_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends taggable_tagsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, taggable_tagsFindUniqueOrThrowArgs>
    ): Prisma__taggable_tagsClient<taggable_tagsGetPayload<T>>

    /**
     * Find the first Taggable_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taggable_tagsFindFirstArgs} args - Arguments to find a Taggable_tags
     * @example
     * // Get one Taggable_tags
     * const taggable_tags = await prisma.taggable_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends taggable_tagsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, taggable_tagsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'taggable_tags'> extends True ? Prisma__taggable_tagsClient<taggable_tagsGetPayload<T>> : Prisma__taggable_tagsClient<taggable_tagsGetPayload<T> | null, null>

    /**
     * Find the first Taggable_tags that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taggable_tagsFindFirstOrThrowArgs} args - Arguments to find a Taggable_tags
     * @example
     * // Get one Taggable_tags
     * const taggable_tags = await prisma.taggable_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends taggable_tagsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, taggable_tagsFindFirstOrThrowArgs>
    ): Prisma__taggable_tagsClient<taggable_tagsGetPayload<T>>

    /**
     * Find zero or more Taggable_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taggable_tagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Taggable_tags
     * const taggable_tags = await prisma.taggable_tags.findMany()
     * 
     * // Get first 10 Taggable_tags
     * const taggable_tags = await prisma.taggable_tags.findMany({ take: 10 })
     * 
     * // Only select the `tag_id`
     * const taggable_tagsWithTag_idOnly = await prisma.taggable_tags.findMany({ select: { tag_id: true } })
     * 
    **/
    findMany<T extends taggable_tagsFindManyArgs>(
      args?: SelectSubset<T, taggable_tagsFindManyArgs>
    ): Prisma.PrismaPromise<Array<taggable_tagsGetPayload<T>>>

    /**
     * Create a Taggable_tags.
     * @param {taggable_tagsCreateArgs} args - Arguments to create a Taggable_tags.
     * @example
     * // Create one Taggable_tags
     * const Taggable_tags = await prisma.taggable_tags.create({
     *   data: {
     *     // ... data to create a Taggable_tags
     *   }
     * })
     * 
    **/
    create<T extends taggable_tagsCreateArgs>(
      args: SelectSubset<T, taggable_tagsCreateArgs>
    ): Prisma__taggable_tagsClient<taggable_tagsGetPayload<T>>

    /**
     * Create many Taggable_tags.
     *     @param {taggable_tagsCreateManyArgs} args - Arguments to create many Taggable_tags.
     *     @example
     *     // Create many Taggable_tags
     *     const taggable_tags = await prisma.taggable_tags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends taggable_tagsCreateManyArgs>(
      args?: SelectSubset<T, taggable_tagsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Taggable_tags.
     * @param {taggable_tagsDeleteArgs} args - Arguments to delete one Taggable_tags.
     * @example
     * // Delete one Taggable_tags
     * const Taggable_tags = await prisma.taggable_tags.delete({
     *   where: {
     *     // ... filter to delete one Taggable_tags
     *   }
     * })
     * 
    **/
    delete<T extends taggable_tagsDeleteArgs>(
      args: SelectSubset<T, taggable_tagsDeleteArgs>
    ): Prisma__taggable_tagsClient<taggable_tagsGetPayload<T>>

    /**
     * Update one Taggable_tags.
     * @param {taggable_tagsUpdateArgs} args - Arguments to update one Taggable_tags.
     * @example
     * // Update one Taggable_tags
     * const taggable_tags = await prisma.taggable_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends taggable_tagsUpdateArgs>(
      args: SelectSubset<T, taggable_tagsUpdateArgs>
    ): Prisma__taggable_tagsClient<taggable_tagsGetPayload<T>>

    /**
     * Delete zero or more Taggable_tags.
     * @param {taggable_tagsDeleteManyArgs} args - Arguments to filter Taggable_tags to delete.
     * @example
     * // Delete a few Taggable_tags
     * const { count } = await prisma.taggable_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends taggable_tagsDeleteManyArgs>(
      args?: SelectSubset<T, taggable_tagsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Taggable_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taggable_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Taggable_tags
     * const taggable_tags = await prisma.taggable_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends taggable_tagsUpdateManyArgs>(
      args: SelectSubset<T, taggable_tagsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Taggable_tags.
     * @param {taggable_tagsUpsertArgs} args - Arguments to update or create a Taggable_tags.
     * @example
     * // Update or create a Taggable_tags
     * const taggable_tags = await prisma.taggable_tags.upsert({
     *   create: {
     *     // ... data to create a Taggable_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Taggable_tags we want to update
     *   }
     * })
    **/
    upsert<T extends taggable_tagsUpsertArgs>(
      args: SelectSubset<T, taggable_tagsUpsertArgs>
    ): Prisma__taggable_tagsClient<taggable_tagsGetPayload<T>>

    /**
     * Count the number of Taggable_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taggable_tagsCountArgs} args - Arguments to filter Taggable_tags to count.
     * @example
     * // Count the number of Taggable_tags
     * const count = await prisma.taggable_tags.count({
     *   where: {
     *     // ... the filter for the Taggable_tags we want to count
     *   }
     * })
    **/
    count<T extends taggable_tagsCountArgs>(
      args?: Subset<T, taggable_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Taggable_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Taggable_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Taggable_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Taggable_tagsAggregateArgs>(args: Subset<T, Taggable_tagsAggregateArgs>): Prisma.PrismaPromise<GetTaggable_tagsAggregateType<T>>

    /**
     * Group by Taggable_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Taggable_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Taggable_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Taggable_tagsGroupByArgs['orderBy'] }
        : { orderBy?: Taggable_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Taggable_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaggable_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for taggable_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__taggable_tagsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * taggable_tags base type for findUnique actions
   */
  export type taggable_tagsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the taggable_tags
     */
    select?: taggable_tagsSelect | null
    /**
     * Filter, which taggable_tags to fetch.
     */
    where: taggable_tagsWhereUniqueInput
  }

  /**
   * taggable_tags findUnique
   */
  export interface taggable_tagsFindUniqueArgs extends taggable_tagsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * taggable_tags findUniqueOrThrow
   */
  export type taggable_tagsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the taggable_tags
     */
    select?: taggable_tagsSelect | null
    /**
     * Filter, which taggable_tags to fetch.
     */
    where: taggable_tagsWhereUniqueInput
  }


  /**
   * taggable_tags base type for findFirst actions
   */
  export type taggable_tagsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the taggable_tags
     */
    select?: taggable_tagsSelect | null
    /**
     * Filter, which taggable_tags to fetch.
     */
    where?: taggable_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taggable_tags to fetch.
     */
    orderBy?: Enumerable<taggable_tagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for taggable_tags.
     */
    cursor?: taggable_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taggable_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taggable_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of taggable_tags.
     */
    distinct?: Enumerable<Taggable_tagsScalarFieldEnum>
  }

  /**
   * taggable_tags findFirst
   */
  export interface taggable_tagsFindFirstArgs extends taggable_tagsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * taggable_tags findFirstOrThrow
   */
  export type taggable_tagsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the taggable_tags
     */
    select?: taggable_tagsSelect | null
    /**
     * Filter, which taggable_tags to fetch.
     */
    where?: taggable_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taggable_tags to fetch.
     */
    orderBy?: Enumerable<taggable_tagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for taggable_tags.
     */
    cursor?: taggable_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taggable_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taggable_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of taggable_tags.
     */
    distinct?: Enumerable<Taggable_tagsScalarFieldEnum>
  }


  /**
   * taggable_tags findMany
   */
  export type taggable_tagsFindManyArgs = {
    /**
     * Select specific fields to fetch from the taggable_tags
     */
    select?: taggable_tagsSelect | null
    /**
     * Filter, which taggable_tags to fetch.
     */
    where?: taggable_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taggable_tags to fetch.
     */
    orderBy?: Enumerable<taggable_tagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing taggable_tags.
     */
    cursor?: taggable_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taggable_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taggable_tags.
     */
    skip?: number
    distinct?: Enumerable<Taggable_tagsScalarFieldEnum>
  }


  /**
   * taggable_tags create
   */
  export type taggable_tagsCreateArgs = {
    /**
     * Select specific fields to fetch from the taggable_tags
     */
    select?: taggable_tagsSelect | null
    /**
     * The data needed to create a taggable_tags.
     */
    data: XOR<taggable_tagsCreateInput, taggable_tagsUncheckedCreateInput>
  }


  /**
   * taggable_tags createMany
   */
  export type taggable_tagsCreateManyArgs = {
    /**
     * The data used to create many taggable_tags.
     */
    data: Enumerable<taggable_tagsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * taggable_tags update
   */
  export type taggable_tagsUpdateArgs = {
    /**
     * Select specific fields to fetch from the taggable_tags
     */
    select?: taggable_tagsSelect | null
    /**
     * The data needed to update a taggable_tags.
     */
    data: XOR<taggable_tagsUpdateInput, taggable_tagsUncheckedUpdateInput>
    /**
     * Choose, which taggable_tags to update.
     */
    where: taggable_tagsWhereUniqueInput
  }


  /**
   * taggable_tags updateMany
   */
  export type taggable_tagsUpdateManyArgs = {
    /**
     * The data used to update taggable_tags.
     */
    data: XOR<taggable_tagsUpdateManyMutationInput, taggable_tagsUncheckedUpdateManyInput>
    /**
     * Filter which taggable_tags to update
     */
    where?: taggable_tagsWhereInput
  }


  /**
   * taggable_tags upsert
   */
  export type taggable_tagsUpsertArgs = {
    /**
     * Select specific fields to fetch from the taggable_tags
     */
    select?: taggable_tagsSelect | null
    /**
     * The filter to search for the taggable_tags to update in case it exists.
     */
    where: taggable_tagsWhereUniqueInput
    /**
     * In case the taggable_tags found by the `where` argument doesn't exist, create a new taggable_tags with this data.
     */
    create: XOR<taggable_tagsCreateInput, taggable_tagsUncheckedCreateInput>
    /**
     * In case the taggable_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<taggable_tagsUpdateInput, taggable_tagsUncheckedUpdateInput>
  }


  /**
   * taggable_tags delete
   */
  export type taggable_tagsDeleteArgs = {
    /**
     * Select specific fields to fetch from the taggable_tags
     */
    select?: taggable_tagsSelect | null
    /**
     * Filter which taggable_tags to delete.
     */
    where: taggable_tagsWhereUniqueInput
  }


  /**
   * taggable_tags deleteMany
   */
  export type taggable_tagsDeleteManyArgs = {
    /**
     * Filter which taggable_tags to delete
     */
    where?: taggable_tagsWhereInput
  }


  /**
   * taggable_tags without action
   */
  export type taggable_tagsArgs = {
    /**
     * Select specific fields to fetch from the taggable_tags
     */
    select?: taggable_tagsSelect | null
  }



  /**
   * Model tasks
   */


  export type AggregateTasks = {
    _count: TasksCountAggregateOutputType | null
    _avg: TasksAvgAggregateOutputType | null
    _sum: TasksSumAggregateOutputType | null
    _min: TasksMinAggregateOutputType | null
    _max: TasksMaxAggregateOutputType | null
  }

  export type TasksAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    finished: number | null
  }

  export type TasksSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    finished: number | null
  }

  export type TasksMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    finished: number | null
    task_description: string | null
    task_deadline: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TasksMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    finished: number | null
    task_description: string | null
    task_deadline: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TasksCountAggregateOutputType = {
    id: number
    user_id: number
    finished: number
    task_description: number
    task_deadline: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TasksAvgAggregateInputType = {
    id?: true
    user_id?: true
    finished?: true
  }

  export type TasksSumAggregateInputType = {
    id?: true
    user_id?: true
    finished?: true
  }

  export type TasksMinAggregateInputType = {
    id?: true
    user_id?: true
    finished?: true
    task_description?: true
    task_deadline?: true
    created_at?: true
    updated_at?: true
  }

  export type TasksMaxAggregateInputType = {
    id?: true
    user_id?: true
    finished?: true
    task_description?: true
    task_deadline?: true
    created_at?: true
    updated_at?: true
  }

  export type TasksCountAggregateInputType = {
    id?: true
    user_id?: true
    finished?: true
    task_description?: true
    task_deadline?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TasksAggregateArgs = {
    /**
     * Filter which tasks to aggregate.
     */
    where?: tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tasks to fetch.
     */
    orderBy?: Enumerable<tasksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tasks
    **/
    _count?: true | TasksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TasksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TasksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TasksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TasksMaxAggregateInputType
  }

  export type GetTasksAggregateType<T extends TasksAggregateArgs> = {
        [P in keyof T & keyof AggregateTasks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTasks[P]>
      : GetScalarType<T[P], AggregateTasks[P]>
  }




  export type TasksGroupByArgs = {
    where?: tasksWhereInput
    orderBy?: Enumerable<tasksOrderByWithAggregationInput>
    by: TasksScalarFieldEnum[]
    having?: tasksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TasksCountAggregateInputType | true
    _avg?: TasksAvgAggregateInputType
    _sum?: TasksSumAggregateInputType
    _min?: TasksMinAggregateInputType
    _max?: TasksMaxAggregateInputType
  }


  export type TasksGroupByOutputType = {
    id: number
    user_id: number
    finished: number
    task_description: string
    task_deadline: Date
    created_at: Date | null
    updated_at: Date | null
    _count: TasksCountAggregateOutputType | null
    _avg: TasksAvgAggregateOutputType | null
    _sum: TasksSumAggregateOutputType | null
    _min: TasksMinAggregateOutputType | null
    _max: TasksMaxAggregateOutputType | null
  }

  type GetTasksGroupByPayload<T extends TasksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TasksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TasksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TasksGroupByOutputType[P]>
            : GetScalarType<T[P], TasksGroupByOutputType[P]>
        }
      >
    >


  export type tasksSelect = {
    id?: boolean
    user_id?: boolean
    finished?: boolean
    task_description?: boolean
    task_deadline?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type tasksGetPayload<S extends boolean | null | undefined | tasksArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tasks :
    S extends undefined ? never :
    S extends { include: any } & (tasksArgs | tasksFindManyArgs)
    ? tasks 
    : S extends { select: any } & (tasksArgs | tasksFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof tasks ? tasks[P] : never
  } 
      : tasks


  type tasksCountArgs = 
    Omit<tasksFindManyArgs, 'select' | 'include'> & {
      select?: TasksCountAggregateInputType | true
    }

  export interface tasksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tasks that matches the filter.
     * @param {tasksFindUniqueArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tasksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tasksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tasks'> extends True ? Prisma__tasksClient<tasksGetPayload<T>> : Prisma__tasksClient<tasksGetPayload<T> | null, null>

    /**
     * Find one Tasks that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tasksFindUniqueOrThrowArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tasksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tasksFindUniqueOrThrowArgs>
    ): Prisma__tasksClient<tasksGetPayload<T>>

    /**
     * Find the first Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tasksFindFirstArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tasksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tasksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tasks'> extends True ? Prisma__tasksClient<tasksGetPayload<T>> : Prisma__tasksClient<tasksGetPayload<T> | null, null>

    /**
     * Find the first Tasks that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tasksFindFirstOrThrowArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tasksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tasksFindFirstOrThrowArgs>
    ): Prisma__tasksClient<tasksGetPayload<T>>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tasksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.tasks.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.tasks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tasksWithIdOnly = await prisma.tasks.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tasksFindManyArgs>(
      args?: SelectSubset<T, tasksFindManyArgs>
    ): Prisma.PrismaPromise<Array<tasksGetPayload<T>>>

    /**
     * Create a Tasks.
     * @param {tasksCreateArgs} args - Arguments to create a Tasks.
     * @example
     * // Create one Tasks
     * const Tasks = await prisma.tasks.create({
     *   data: {
     *     // ... data to create a Tasks
     *   }
     * })
     * 
    **/
    create<T extends tasksCreateArgs>(
      args: SelectSubset<T, tasksCreateArgs>
    ): Prisma__tasksClient<tasksGetPayload<T>>

    /**
     * Create many Tasks.
     *     @param {tasksCreateManyArgs} args - Arguments to create many Tasks.
     *     @example
     *     // Create many Tasks
     *     const tasks = await prisma.tasks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tasksCreateManyArgs>(
      args?: SelectSubset<T, tasksCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tasks.
     * @param {tasksDeleteArgs} args - Arguments to delete one Tasks.
     * @example
     * // Delete one Tasks
     * const Tasks = await prisma.tasks.delete({
     *   where: {
     *     // ... filter to delete one Tasks
     *   }
     * })
     * 
    **/
    delete<T extends tasksDeleteArgs>(
      args: SelectSubset<T, tasksDeleteArgs>
    ): Prisma__tasksClient<tasksGetPayload<T>>

    /**
     * Update one Tasks.
     * @param {tasksUpdateArgs} args - Arguments to update one Tasks.
     * @example
     * // Update one Tasks
     * const tasks = await prisma.tasks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tasksUpdateArgs>(
      args: SelectSubset<T, tasksUpdateArgs>
    ): Prisma__tasksClient<tasksGetPayload<T>>

    /**
     * Delete zero or more Tasks.
     * @param {tasksDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.tasks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tasksDeleteManyArgs>(
      args?: SelectSubset<T, tasksDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tasksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const tasks = await prisma.tasks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tasksUpdateManyArgs>(
      args: SelectSubset<T, tasksUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tasks.
     * @param {tasksUpsertArgs} args - Arguments to update or create a Tasks.
     * @example
     * // Update or create a Tasks
     * const tasks = await prisma.tasks.upsert({
     *   create: {
     *     // ... data to create a Tasks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tasks we want to update
     *   }
     * })
    **/
    upsert<T extends tasksUpsertArgs>(
      args: SelectSubset<T, tasksUpsertArgs>
    ): Prisma__tasksClient<tasksGetPayload<T>>

    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tasksCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.tasks.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends tasksCountArgs>(
      args?: Subset<T, tasksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TasksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TasksAggregateArgs>(args: Subset<T, TasksAggregateArgs>): Prisma.PrismaPromise<GetTasksAggregateType<T>>

    /**
     * Group by Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TasksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TasksGroupByArgs['orderBy'] }
        : { orderBy?: TasksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TasksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTasksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tasks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tasksClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tasks base type for findUnique actions
   */
  export type tasksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tasks
     */
    select?: tasksSelect | null
    /**
     * Filter, which tasks to fetch.
     */
    where: tasksWhereUniqueInput
  }

  /**
   * tasks findUnique
   */
  export interface tasksFindUniqueArgs extends tasksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tasks findUniqueOrThrow
   */
  export type tasksFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tasks
     */
    select?: tasksSelect | null
    /**
     * Filter, which tasks to fetch.
     */
    where: tasksWhereUniqueInput
  }


  /**
   * tasks base type for findFirst actions
   */
  export type tasksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tasks
     */
    select?: tasksSelect | null
    /**
     * Filter, which tasks to fetch.
     */
    where?: tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tasks to fetch.
     */
    orderBy?: Enumerable<tasksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tasks.
     */
    cursor?: tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tasks.
     */
    distinct?: Enumerable<TasksScalarFieldEnum>
  }

  /**
   * tasks findFirst
   */
  export interface tasksFindFirstArgs extends tasksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tasks findFirstOrThrow
   */
  export type tasksFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tasks
     */
    select?: tasksSelect | null
    /**
     * Filter, which tasks to fetch.
     */
    where?: tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tasks to fetch.
     */
    orderBy?: Enumerable<tasksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tasks.
     */
    cursor?: tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tasks.
     */
    distinct?: Enumerable<TasksScalarFieldEnum>
  }


  /**
   * tasks findMany
   */
  export type tasksFindManyArgs = {
    /**
     * Select specific fields to fetch from the tasks
     */
    select?: tasksSelect | null
    /**
     * Filter, which tasks to fetch.
     */
    where?: tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tasks to fetch.
     */
    orderBy?: Enumerable<tasksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tasks.
     */
    cursor?: tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tasks.
     */
    skip?: number
    distinct?: Enumerable<TasksScalarFieldEnum>
  }


  /**
   * tasks create
   */
  export type tasksCreateArgs = {
    /**
     * Select specific fields to fetch from the tasks
     */
    select?: tasksSelect | null
    /**
     * The data needed to create a tasks.
     */
    data: XOR<tasksCreateInput, tasksUncheckedCreateInput>
  }


  /**
   * tasks createMany
   */
  export type tasksCreateManyArgs = {
    /**
     * The data used to create many tasks.
     */
    data: Enumerable<tasksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tasks update
   */
  export type tasksUpdateArgs = {
    /**
     * Select specific fields to fetch from the tasks
     */
    select?: tasksSelect | null
    /**
     * The data needed to update a tasks.
     */
    data: XOR<tasksUpdateInput, tasksUncheckedUpdateInput>
    /**
     * Choose, which tasks to update.
     */
    where: tasksWhereUniqueInput
  }


  /**
   * tasks updateMany
   */
  export type tasksUpdateManyArgs = {
    /**
     * The data used to update tasks.
     */
    data: XOR<tasksUpdateManyMutationInput, tasksUncheckedUpdateManyInput>
    /**
     * Filter which tasks to update
     */
    where?: tasksWhereInput
  }


  /**
   * tasks upsert
   */
  export type tasksUpsertArgs = {
    /**
     * Select specific fields to fetch from the tasks
     */
    select?: tasksSelect | null
    /**
     * The filter to search for the tasks to update in case it exists.
     */
    where: tasksWhereUniqueInput
    /**
     * In case the tasks found by the `where` argument doesn't exist, create a new tasks with this data.
     */
    create: XOR<tasksCreateInput, tasksUncheckedCreateInput>
    /**
     * In case the tasks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tasksUpdateInput, tasksUncheckedUpdateInput>
  }


  /**
   * tasks delete
   */
  export type tasksDeleteArgs = {
    /**
     * Select specific fields to fetch from the tasks
     */
    select?: tasksSelect | null
    /**
     * Filter which tasks to delete.
     */
    where: tasksWhereUniqueInput
  }


  /**
   * tasks deleteMany
   */
  export type tasksDeleteManyArgs = {
    /**
     * Filter which tasks to delete
     */
    where?: tasksWhereInput
  }


  /**
   * tasks without action
   */
  export type tasksArgs = {
    /**
     * Select specific fields to fetch from the tasks
     */
    select?: tasksSelect | null
  }



  /**
   * Model throttle
   */


  export type AggregateThrottle = {
    _count: ThrottleCountAggregateOutputType | null
    _avg: ThrottleAvgAggregateOutputType | null
    _sum: ThrottleSumAggregateOutputType | null
    _min: ThrottleMinAggregateOutputType | null
    _max: ThrottleMaxAggregateOutputType | null
  }

  export type ThrottleAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ThrottleSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ThrottleMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    type: string | null
    ip: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ThrottleMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    type: string | null
    ip: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ThrottleCountAggregateOutputType = {
    id: number
    user_id: number
    type: number
    ip: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ThrottleAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ThrottleSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ThrottleMinAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    ip?: true
    created_at?: true
    updated_at?: true
  }

  export type ThrottleMaxAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    ip?: true
    created_at?: true
    updated_at?: true
  }

  export type ThrottleCountAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    ip?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ThrottleAggregateArgs = {
    /**
     * Filter which throttle to aggregate.
     */
    where?: throttleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of throttles to fetch.
     */
    orderBy?: Enumerable<throttleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: throttleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` throttles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` throttles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned throttles
    **/
    _count?: true | ThrottleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ThrottleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ThrottleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThrottleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThrottleMaxAggregateInputType
  }

  export type GetThrottleAggregateType<T extends ThrottleAggregateArgs> = {
        [P in keyof T & keyof AggregateThrottle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThrottle[P]>
      : GetScalarType<T[P], AggregateThrottle[P]>
  }




  export type ThrottleGroupByArgs = {
    where?: throttleWhereInput
    orderBy?: Enumerable<throttleOrderByWithAggregationInput>
    by: ThrottleScalarFieldEnum[]
    having?: throttleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThrottleCountAggregateInputType | true
    _avg?: ThrottleAvgAggregateInputType
    _sum?: ThrottleSumAggregateInputType
    _min?: ThrottleMinAggregateInputType
    _max?: ThrottleMaxAggregateInputType
  }


  export type ThrottleGroupByOutputType = {
    id: number
    user_id: number | null
    type: string
    ip: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: ThrottleCountAggregateOutputType | null
    _avg: ThrottleAvgAggregateOutputType | null
    _sum: ThrottleSumAggregateOutputType | null
    _min: ThrottleMinAggregateOutputType | null
    _max: ThrottleMaxAggregateOutputType | null
  }

  type GetThrottleGroupByPayload<T extends ThrottleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ThrottleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThrottleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThrottleGroupByOutputType[P]>
            : GetScalarType<T[P], ThrottleGroupByOutputType[P]>
        }
      >
    >


  export type throttleSelect = {
    id?: boolean
    user_id?: boolean
    type?: boolean
    ip?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type throttleGetPayload<S extends boolean | null | undefined | throttleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? throttle :
    S extends undefined ? never :
    S extends { include: any } & (throttleArgs | throttleFindManyArgs)
    ? throttle 
    : S extends { select: any } & (throttleArgs | throttleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof throttle ? throttle[P] : never
  } 
      : throttle


  type throttleCountArgs = 
    Omit<throttleFindManyArgs, 'select' | 'include'> & {
      select?: ThrottleCountAggregateInputType | true
    }

  export interface throttleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Throttle that matches the filter.
     * @param {throttleFindUniqueArgs} args - Arguments to find a Throttle
     * @example
     * // Get one Throttle
     * const throttle = await prisma.throttle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends throttleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, throttleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'throttle'> extends True ? Prisma__throttleClient<throttleGetPayload<T>> : Prisma__throttleClient<throttleGetPayload<T> | null, null>

    /**
     * Find one Throttle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {throttleFindUniqueOrThrowArgs} args - Arguments to find a Throttle
     * @example
     * // Get one Throttle
     * const throttle = await prisma.throttle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends throttleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, throttleFindUniqueOrThrowArgs>
    ): Prisma__throttleClient<throttleGetPayload<T>>

    /**
     * Find the first Throttle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {throttleFindFirstArgs} args - Arguments to find a Throttle
     * @example
     * // Get one Throttle
     * const throttle = await prisma.throttle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends throttleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, throttleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'throttle'> extends True ? Prisma__throttleClient<throttleGetPayload<T>> : Prisma__throttleClient<throttleGetPayload<T> | null, null>

    /**
     * Find the first Throttle that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {throttleFindFirstOrThrowArgs} args - Arguments to find a Throttle
     * @example
     * // Get one Throttle
     * const throttle = await prisma.throttle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends throttleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, throttleFindFirstOrThrowArgs>
    ): Prisma__throttleClient<throttleGetPayload<T>>

    /**
     * Find zero or more Throttles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {throttleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Throttles
     * const throttles = await prisma.throttle.findMany()
     * 
     * // Get first 10 Throttles
     * const throttles = await prisma.throttle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const throttleWithIdOnly = await prisma.throttle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends throttleFindManyArgs>(
      args?: SelectSubset<T, throttleFindManyArgs>
    ): Prisma.PrismaPromise<Array<throttleGetPayload<T>>>

    /**
     * Create a Throttle.
     * @param {throttleCreateArgs} args - Arguments to create a Throttle.
     * @example
     * // Create one Throttle
     * const Throttle = await prisma.throttle.create({
     *   data: {
     *     // ... data to create a Throttle
     *   }
     * })
     * 
    **/
    create<T extends throttleCreateArgs>(
      args: SelectSubset<T, throttleCreateArgs>
    ): Prisma__throttleClient<throttleGetPayload<T>>

    /**
     * Create many Throttles.
     *     @param {throttleCreateManyArgs} args - Arguments to create many Throttles.
     *     @example
     *     // Create many Throttles
     *     const throttle = await prisma.throttle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends throttleCreateManyArgs>(
      args?: SelectSubset<T, throttleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Throttle.
     * @param {throttleDeleteArgs} args - Arguments to delete one Throttle.
     * @example
     * // Delete one Throttle
     * const Throttle = await prisma.throttle.delete({
     *   where: {
     *     // ... filter to delete one Throttle
     *   }
     * })
     * 
    **/
    delete<T extends throttleDeleteArgs>(
      args: SelectSubset<T, throttleDeleteArgs>
    ): Prisma__throttleClient<throttleGetPayload<T>>

    /**
     * Update one Throttle.
     * @param {throttleUpdateArgs} args - Arguments to update one Throttle.
     * @example
     * // Update one Throttle
     * const throttle = await prisma.throttle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends throttleUpdateArgs>(
      args: SelectSubset<T, throttleUpdateArgs>
    ): Prisma__throttleClient<throttleGetPayload<T>>

    /**
     * Delete zero or more Throttles.
     * @param {throttleDeleteManyArgs} args - Arguments to filter Throttles to delete.
     * @example
     * // Delete a few Throttles
     * const { count } = await prisma.throttle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends throttleDeleteManyArgs>(
      args?: SelectSubset<T, throttleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Throttles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {throttleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Throttles
     * const throttle = await prisma.throttle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends throttleUpdateManyArgs>(
      args: SelectSubset<T, throttleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Throttle.
     * @param {throttleUpsertArgs} args - Arguments to update or create a Throttle.
     * @example
     * // Update or create a Throttle
     * const throttle = await prisma.throttle.upsert({
     *   create: {
     *     // ... data to create a Throttle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Throttle we want to update
     *   }
     * })
    **/
    upsert<T extends throttleUpsertArgs>(
      args: SelectSubset<T, throttleUpsertArgs>
    ): Prisma__throttleClient<throttleGetPayload<T>>

    /**
     * Count the number of Throttles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {throttleCountArgs} args - Arguments to filter Throttles to count.
     * @example
     * // Count the number of Throttles
     * const count = await prisma.throttle.count({
     *   where: {
     *     // ... the filter for the Throttles we want to count
     *   }
     * })
    **/
    count<T extends throttleCountArgs>(
      args?: Subset<T, throttleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThrottleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Throttle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThrottleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThrottleAggregateArgs>(args: Subset<T, ThrottleAggregateArgs>): Prisma.PrismaPromise<GetThrottleAggregateType<T>>

    /**
     * Group by Throttle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThrottleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThrottleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThrottleGroupByArgs['orderBy'] }
        : { orderBy?: ThrottleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThrottleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThrottleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for throttle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__throttleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * throttle base type for findUnique actions
   */
  export type throttleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the throttle
     */
    select?: throttleSelect | null
    /**
     * Filter, which throttle to fetch.
     */
    where: throttleWhereUniqueInput
  }

  /**
   * throttle findUnique
   */
  export interface throttleFindUniqueArgs extends throttleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * throttle findUniqueOrThrow
   */
  export type throttleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the throttle
     */
    select?: throttleSelect | null
    /**
     * Filter, which throttle to fetch.
     */
    where: throttleWhereUniqueInput
  }


  /**
   * throttle base type for findFirst actions
   */
  export type throttleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the throttle
     */
    select?: throttleSelect | null
    /**
     * Filter, which throttle to fetch.
     */
    where?: throttleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of throttles to fetch.
     */
    orderBy?: Enumerable<throttleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for throttles.
     */
    cursor?: throttleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` throttles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` throttles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of throttles.
     */
    distinct?: Enumerable<ThrottleScalarFieldEnum>
  }

  /**
   * throttle findFirst
   */
  export interface throttleFindFirstArgs extends throttleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * throttle findFirstOrThrow
   */
  export type throttleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the throttle
     */
    select?: throttleSelect | null
    /**
     * Filter, which throttle to fetch.
     */
    where?: throttleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of throttles to fetch.
     */
    orderBy?: Enumerable<throttleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for throttles.
     */
    cursor?: throttleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` throttles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` throttles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of throttles.
     */
    distinct?: Enumerable<ThrottleScalarFieldEnum>
  }


  /**
   * throttle findMany
   */
  export type throttleFindManyArgs = {
    /**
     * Select specific fields to fetch from the throttle
     */
    select?: throttleSelect | null
    /**
     * Filter, which throttles to fetch.
     */
    where?: throttleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of throttles to fetch.
     */
    orderBy?: Enumerable<throttleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing throttles.
     */
    cursor?: throttleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` throttles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` throttles.
     */
    skip?: number
    distinct?: Enumerable<ThrottleScalarFieldEnum>
  }


  /**
   * throttle create
   */
  export type throttleCreateArgs = {
    /**
     * Select specific fields to fetch from the throttle
     */
    select?: throttleSelect | null
    /**
     * The data needed to create a throttle.
     */
    data: XOR<throttleCreateInput, throttleUncheckedCreateInput>
  }


  /**
   * throttle createMany
   */
  export type throttleCreateManyArgs = {
    /**
     * The data used to create many throttles.
     */
    data: Enumerable<throttleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * throttle update
   */
  export type throttleUpdateArgs = {
    /**
     * Select specific fields to fetch from the throttle
     */
    select?: throttleSelect | null
    /**
     * The data needed to update a throttle.
     */
    data: XOR<throttleUpdateInput, throttleUncheckedUpdateInput>
    /**
     * Choose, which throttle to update.
     */
    where: throttleWhereUniqueInput
  }


  /**
   * throttle updateMany
   */
  export type throttleUpdateManyArgs = {
    /**
     * The data used to update throttles.
     */
    data: XOR<throttleUpdateManyMutationInput, throttleUncheckedUpdateManyInput>
    /**
     * Filter which throttles to update
     */
    where?: throttleWhereInput
  }


  /**
   * throttle upsert
   */
  export type throttleUpsertArgs = {
    /**
     * Select specific fields to fetch from the throttle
     */
    select?: throttleSelect | null
    /**
     * The filter to search for the throttle to update in case it exists.
     */
    where: throttleWhereUniqueInput
    /**
     * In case the throttle found by the `where` argument doesn't exist, create a new throttle with this data.
     */
    create: XOR<throttleCreateInput, throttleUncheckedCreateInput>
    /**
     * In case the throttle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<throttleUpdateInput, throttleUncheckedUpdateInput>
  }


  /**
   * throttle delete
   */
  export type throttleDeleteArgs = {
    /**
     * Select specific fields to fetch from the throttle
     */
    select?: throttleSelect | null
    /**
     * Filter which throttle to delete.
     */
    where: throttleWhereUniqueInput
  }


  /**
   * throttle deleteMany
   */
  export type throttleDeleteManyArgs = {
    /**
     * Filter which throttles to delete
     */
    where?: throttleWhereInput
  }


  /**
   * throttle without action
   */
  export type throttleArgs = {
    /**
     * Select specific fields to fetch from the throttle
     */
    select?: throttleSelect | null
  }



  /**
   * Model tours
   */


  export type AggregateTours = {
    _count: ToursCountAggregateOutputType | null
    _avg: ToursAvgAggregateOutputType | null
    _sum: ToursSumAggregateOutputType | null
    _min: ToursMinAggregateOutputType | null
    _max: ToursMaxAggregateOutputType | null
  }

  export type ToursAvgAggregateOutputType = {
    id: number | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    price_per_passenger: number | null
    car_id: number | null
    luggage: number | null
  }

  export type ToursSumAggregateOutputType = {
    id: number | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    price_per_passenger: number | null
    car_id: number | null
    luggage: number | null
  }

  export type ToursMinAggregateOutputType = {
    id: number | null
    title: string | null
    pickup_location: string | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_location: string | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    price_per_passenger: number | null
    status: Buffer | null
    created_at: Date | null
    updated_at: Date | null
    isActive: boolean | null
    car_id: number | null
    description: string | null
    luggage: number | null
  }

  export type ToursMaxAggregateOutputType = {
    id: number | null
    title: string | null
    pickup_location: string | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_location: string | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    price_per_passenger: number | null
    status: Buffer | null
    created_at: Date | null
    updated_at: Date | null
    isActive: boolean | null
    car_id: number | null
    description: string | null
    luggage: number | null
  }

  export type ToursCountAggregateOutputType = {
    id: number
    title: number
    pickup_location: number
    pickup_lat: number
    pickup_lng: number
    dropoff_location: number
    dropoff_lat: number
    dropoff_lng: number
    price_per_passenger: number
    status: number
    created_at: number
    updated_at: number
    isActive: number
    car_id: number
    description: number
    luggage: number
    _all: number
  }


  export type ToursAvgAggregateInputType = {
    id?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_lat?: true
    dropoff_lng?: true
    price_per_passenger?: true
    car_id?: true
    luggage?: true
  }

  export type ToursSumAggregateInputType = {
    id?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_lat?: true
    dropoff_lng?: true
    price_per_passenger?: true
    car_id?: true
    luggage?: true
  }

  export type ToursMinAggregateInputType = {
    id?: true
    title?: true
    pickup_location?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_location?: true
    dropoff_lat?: true
    dropoff_lng?: true
    price_per_passenger?: true
    status?: true
    created_at?: true
    updated_at?: true
    isActive?: true
    car_id?: true
    description?: true
    luggage?: true
  }

  export type ToursMaxAggregateInputType = {
    id?: true
    title?: true
    pickup_location?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_location?: true
    dropoff_lat?: true
    dropoff_lng?: true
    price_per_passenger?: true
    status?: true
    created_at?: true
    updated_at?: true
    isActive?: true
    car_id?: true
    description?: true
    luggage?: true
  }

  export type ToursCountAggregateInputType = {
    id?: true
    title?: true
    pickup_location?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_location?: true
    dropoff_lat?: true
    dropoff_lng?: true
    price_per_passenger?: true
    status?: true
    created_at?: true
    updated_at?: true
    isActive?: true
    car_id?: true
    description?: true
    luggage?: true
    _all?: true
  }

  export type ToursAggregateArgs = {
    /**
     * Filter which tours to aggregate.
     */
    where?: toursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tours to fetch.
     */
    orderBy?: Enumerable<toursOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: toursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tours
    **/
    _count?: true | ToursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ToursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ToursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ToursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ToursMaxAggregateInputType
  }

  export type GetToursAggregateType<T extends ToursAggregateArgs> = {
        [P in keyof T & keyof AggregateTours]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTours[P]>
      : GetScalarType<T[P], AggregateTours[P]>
  }




  export type ToursGroupByArgs = {
    where?: toursWhereInput
    orderBy?: Enumerable<toursOrderByWithAggregationInput>
    by: ToursScalarFieldEnum[]
    having?: toursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ToursCountAggregateInputType | true
    _avg?: ToursAvgAggregateInputType
    _sum?: ToursSumAggregateInputType
    _min?: ToursMinAggregateInputType
    _max?: ToursMaxAggregateInputType
  }


  export type ToursGroupByOutputType = {
    id: number
    title: string | null
    pickup_location: string | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_location: string | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    price_per_passenger: number | null
    status: Buffer | null
    created_at: Date | null
    updated_at: Date | null
    isActive: boolean | null
    car_id: number | null
    description: string | null
    luggage: number | null
    _count: ToursCountAggregateOutputType | null
    _avg: ToursAvgAggregateOutputType | null
    _sum: ToursSumAggregateOutputType | null
    _min: ToursMinAggregateOutputType | null
    _max: ToursMaxAggregateOutputType | null
  }

  type GetToursGroupByPayload<T extends ToursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ToursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ToursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ToursGroupByOutputType[P]>
            : GetScalarType<T[P], ToursGroupByOutputType[P]>
        }
      >
    >


  export type toursSelect = {
    id?: boolean
    title?: boolean
    pickup_location?: boolean
    pickup_lat?: boolean
    pickup_lng?: boolean
    dropoff_location?: boolean
    dropoff_lat?: boolean
    dropoff_lng?: boolean
    price_per_passenger?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    isActive?: boolean
    car_id?: boolean
    description?: boolean
    luggage?: boolean
    cars?: boolean | carsArgs
  }


  export type toursInclude = {
    cars?: boolean | carsArgs
  }

  export type toursGetPayload<S extends boolean | null | undefined | toursArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tours :
    S extends undefined ? never :
    S extends { include: any } & (toursArgs | toursFindManyArgs)
    ? tours  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'cars' ? carsGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (toursArgs | toursFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'cars' ? carsGetPayload<S['select'][P]> | null :  P extends keyof tours ? tours[P] : never
  } 
      : tours


  type toursCountArgs = 
    Omit<toursFindManyArgs, 'select' | 'include'> & {
      select?: ToursCountAggregateInputType | true
    }

  export interface toursDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tours that matches the filter.
     * @param {toursFindUniqueArgs} args - Arguments to find a Tours
     * @example
     * // Get one Tours
     * const tours = await prisma.tours.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends toursFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, toursFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tours'> extends True ? Prisma__toursClient<toursGetPayload<T>> : Prisma__toursClient<toursGetPayload<T> | null, null>

    /**
     * Find one Tours that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {toursFindUniqueOrThrowArgs} args - Arguments to find a Tours
     * @example
     * // Get one Tours
     * const tours = await prisma.tours.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends toursFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, toursFindUniqueOrThrowArgs>
    ): Prisma__toursClient<toursGetPayload<T>>

    /**
     * Find the first Tours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {toursFindFirstArgs} args - Arguments to find a Tours
     * @example
     * // Get one Tours
     * const tours = await prisma.tours.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends toursFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, toursFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tours'> extends True ? Prisma__toursClient<toursGetPayload<T>> : Prisma__toursClient<toursGetPayload<T> | null, null>

    /**
     * Find the first Tours that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {toursFindFirstOrThrowArgs} args - Arguments to find a Tours
     * @example
     * // Get one Tours
     * const tours = await prisma.tours.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends toursFindFirstOrThrowArgs>(
      args?: SelectSubset<T, toursFindFirstOrThrowArgs>
    ): Prisma__toursClient<toursGetPayload<T>>

    /**
     * Find zero or more Tours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {toursFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tours
     * const tours = await prisma.tours.findMany()
     * 
     * // Get first 10 Tours
     * const tours = await prisma.tours.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const toursWithIdOnly = await prisma.tours.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends toursFindManyArgs>(
      args?: SelectSubset<T, toursFindManyArgs>
    ): Prisma.PrismaPromise<Array<toursGetPayload<T>>>

    /**
     * Create a Tours.
     * @param {toursCreateArgs} args - Arguments to create a Tours.
     * @example
     * // Create one Tours
     * const Tours = await prisma.tours.create({
     *   data: {
     *     // ... data to create a Tours
     *   }
     * })
     * 
    **/
    create<T extends toursCreateArgs>(
      args: SelectSubset<T, toursCreateArgs>
    ): Prisma__toursClient<toursGetPayload<T>>

    /**
     * Create many Tours.
     *     @param {toursCreateManyArgs} args - Arguments to create many Tours.
     *     @example
     *     // Create many Tours
     *     const tours = await prisma.tours.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends toursCreateManyArgs>(
      args?: SelectSubset<T, toursCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tours.
     * @param {toursDeleteArgs} args - Arguments to delete one Tours.
     * @example
     * // Delete one Tours
     * const Tours = await prisma.tours.delete({
     *   where: {
     *     // ... filter to delete one Tours
     *   }
     * })
     * 
    **/
    delete<T extends toursDeleteArgs>(
      args: SelectSubset<T, toursDeleteArgs>
    ): Prisma__toursClient<toursGetPayload<T>>

    /**
     * Update one Tours.
     * @param {toursUpdateArgs} args - Arguments to update one Tours.
     * @example
     * // Update one Tours
     * const tours = await prisma.tours.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends toursUpdateArgs>(
      args: SelectSubset<T, toursUpdateArgs>
    ): Prisma__toursClient<toursGetPayload<T>>

    /**
     * Delete zero or more Tours.
     * @param {toursDeleteManyArgs} args - Arguments to filter Tours to delete.
     * @example
     * // Delete a few Tours
     * const { count } = await prisma.tours.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends toursDeleteManyArgs>(
      args?: SelectSubset<T, toursDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {toursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tours
     * const tours = await prisma.tours.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends toursUpdateManyArgs>(
      args: SelectSubset<T, toursUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tours.
     * @param {toursUpsertArgs} args - Arguments to update or create a Tours.
     * @example
     * // Update or create a Tours
     * const tours = await prisma.tours.upsert({
     *   create: {
     *     // ... data to create a Tours
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tours we want to update
     *   }
     * })
    **/
    upsert<T extends toursUpsertArgs>(
      args: SelectSubset<T, toursUpsertArgs>
    ): Prisma__toursClient<toursGetPayload<T>>

    /**
     * Count the number of Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {toursCountArgs} args - Arguments to filter Tours to count.
     * @example
     * // Count the number of Tours
     * const count = await prisma.tours.count({
     *   where: {
     *     // ... the filter for the Tours we want to count
     *   }
     * })
    **/
    count<T extends toursCountArgs>(
      args?: Subset<T, toursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ToursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ToursAggregateArgs>(args: Subset<T, ToursAggregateArgs>): Prisma.PrismaPromise<GetToursAggregateType<T>>

    /**
     * Group by Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ToursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ToursGroupByArgs['orderBy'] }
        : { orderBy?: ToursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ToursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tours.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__toursClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cars<T extends carsArgs= {}>(args?: Subset<T, carsArgs>): Prisma__carsClient<carsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tours base type for findUnique actions
   */
  export type toursFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tours
     */
    select?: toursSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: toursInclude | null
    /**
     * Filter, which tours to fetch.
     */
    where: toursWhereUniqueInput
  }

  /**
   * tours findUnique
   */
  export interface toursFindUniqueArgs extends toursFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tours findUniqueOrThrow
   */
  export type toursFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tours
     */
    select?: toursSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: toursInclude | null
    /**
     * Filter, which tours to fetch.
     */
    where: toursWhereUniqueInput
  }


  /**
   * tours base type for findFirst actions
   */
  export type toursFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tours
     */
    select?: toursSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: toursInclude | null
    /**
     * Filter, which tours to fetch.
     */
    where?: toursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tours to fetch.
     */
    orderBy?: Enumerable<toursOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tours.
     */
    cursor?: toursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tours.
     */
    distinct?: Enumerable<ToursScalarFieldEnum>
  }

  /**
   * tours findFirst
   */
  export interface toursFindFirstArgs extends toursFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tours findFirstOrThrow
   */
  export type toursFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tours
     */
    select?: toursSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: toursInclude | null
    /**
     * Filter, which tours to fetch.
     */
    where?: toursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tours to fetch.
     */
    orderBy?: Enumerable<toursOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tours.
     */
    cursor?: toursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tours.
     */
    distinct?: Enumerable<ToursScalarFieldEnum>
  }


  /**
   * tours findMany
   */
  export type toursFindManyArgs = {
    /**
     * Select specific fields to fetch from the tours
     */
    select?: toursSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: toursInclude | null
    /**
     * Filter, which tours to fetch.
     */
    where?: toursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tours to fetch.
     */
    orderBy?: Enumerable<toursOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tours.
     */
    cursor?: toursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tours.
     */
    skip?: number
    distinct?: Enumerable<ToursScalarFieldEnum>
  }


  /**
   * tours create
   */
  export type toursCreateArgs = {
    /**
     * Select specific fields to fetch from the tours
     */
    select?: toursSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: toursInclude | null
    /**
     * The data needed to create a tours.
     */
    data: XOR<toursCreateInput, toursUncheckedCreateInput>
  }


  /**
   * tours createMany
   */
  export type toursCreateManyArgs = {
    /**
     * The data used to create many tours.
     */
    data: Enumerable<toursCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tours update
   */
  export type toursUpdateArgs = {
    /**
     * Select specific fields to fetch from the tours
     */
    select?: toursSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: toursInclude | null
    /**
     * The data needed to update a tours.
     */
    data: XOR<toursUpdateInput, toursUncheckedUpdateInput>
    /**
     * Choose, which tours to update.
     */
    where: toursWhereUniqueInput
  }


  /**
   * tours updateMany
   */
  export type toursUpdateManyArgs = {
    /**
     * The data used to update tours.
     */
    data: XOR<toursUpdateManyMutationInput, toursUncheckedUpdateManyInput>
    /**
     * Filter which tours to update
     */
    where?: toursWhereInput
  }


  /**
   * tours upsert
   */
  export type toursUpsertArgs = {
    /**
     * Select specific fields to fetch from the tours
     */
    select?: toursSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: toursInclude | null
    /**
     * The filter to search for the tours to update in case it exists.
     */
    where: toursWhereUniqueInput
    /**
     * In case the tours found by the `where` argument doesn't exist, create a new tours with this data.
     */
    create: XOR<toursCreateInput, toursUncheckedCreateInput>
    /**
     * In case the tours was found with the provided `where` argument, update it with this data.
     */
    update: XOR<toursUpdateInput, toursUncheckedUpdateInput>
  }


  /**
   * tours delete
   */
  export type toursDeleteArgs = {
    /**
     * Select specific fields to fetch from the tours
     */
    select?: toursSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: toursInclude | null
    /**
     * Filter which tours to delete.
     */
    where: toursWhereUniqueInput
  }


  /**
   * tours deleteMany
   */
  export type toursDeleteManyArgs = {
    /**
     * Filter which tours to delete
     */
    where?: toursWhereInput
  }


  /**
   * tours without action
   */
  export type toursArgs = {
    /**
     * Select specific fields to fetch from the tours
     */
    select?: toursSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: toursInclude | null
  }



  /**
   * Model transmissions
   */


  export type AggregateTransmissions = {
    _count: TransmissionsCountAggregateOutputType | null
    _avg: TransmissionsAvgAggregateOutputType | null
    _sum: TransmissionsSumAggregateOutputType | null
    _min: TransmissionsMinAggregateOutputType | null
    _max: TransmissionsMaxAggregateOutputType | null
  }

  export type TransmissionsAvgAggregateOutputType = {
    id: number | null
  }

  export type TransmissionsSumAggregateOutputType = {
    id: number | null
  }

  export type TransmissionsMinAggregateOutputType = {
    id: number | null
    transmission: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TransmissionsMaxAggregateOutputType = {
    id: number | null
    transmission: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TransmissionsCountAggregateOutputType = {
    id: number
    transmission: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TransmissionsAvgAggregateInputType = {
    id?: true
  }

  export type TransmissionsSumAggregateInputType = {
    id?: true
  }

  export type TransmissionsMinAggregateInputType = {
    id?: true
    transmission?: true
    created_at?: true
    updated_at?: true
  }

  export type TransmissionsMaxAggregateInputType = {
    id?: true
    transmission?: true
    created_at?: true
    updated_at?: true
  }

  export type TransmissionsCountAggregateInputType = {
    id?: true
    transmission?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TransmissionsAggregateArgs = {
    /**
     * Filter which transmissions to aggregate.
     */
    where?: transmissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transmissions to fetch.
     */
    orderBy?: Enumerable<transmissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transmissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transmissions
    **/
    _count?: true | TransmissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransmissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransmissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransmissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransmissionsMaxAggregateInputType
  }

  export type GetTransmissionsAggregateType<T extends TransmissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransmissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransmissions[P]>
      : GetScalarType<T[P], AggregateTransmissions[P]>
  }




  export type TransmissionsGroupByArgs = {
    where?: transmissionsWhereInput
    orderBy?: Enumerable<transmissionsOrderByWithAggregationInput>
    by: TransmissionsScalarFieldEnum[]
    having?: transmissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransmissionsCountAggregateInputType | true
    _avg?: TransmissionsAvgAggregateInputType
    _sum?: TransmissionsSumAggregateInputType
    _min?: TransmissionsMinAggregateInputType
    _max?: TransmissionsMaxAggregateInputType
  }


  export type TransmissionsGroupByOutputType = {
    id: number
    transmission: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: TransmissionsCountAggregateOutputType | null
    _avg: TransmissionsAvgAggregateOutputType | null
    _sum: TransmissionsSumAggregateOutputType | null
    _min: TransmissionsMinAggregateOutputType | null
    _max: TransmissionsMaxAggregateOutputType | null
  }

  type GetTransmissionsGroupByPayload<T extends TransmissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TransmissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransmissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransmissionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransmissionsGroupByOutputType[P]>
        }
      >
    >


  export type transmissionsSelect = {
    id?: boolean
    transmission?: boolean
    created_at?: boolean
    updated_at?: boolean
    cars?: boolean | transmissions$carsArgs
    _count?: boolean | TransmissionsCountOutputTypeArgs
  }


  export type transmissionsInclude = {
    cars?: boolean | transmissions$carsArgs
    _count?: boolean | TransmissionsCountOutputTypeArgs
  }

  export type transmissionsGetPayload<S extends boolean | null | undefined | transmissionsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? transmissions :
    S extends undefined ? never :
    S extends { include: any } & (transmissionsArgs | transmissionsFindManyArgs)
    ? transmissions  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'cars' ? Array < carsGetPayload<S['include'][P]>>  :
        P extends '_count' ? TransmissionsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (transmissionsArgs | transmissionsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'cars' ? Array < carsGetPayload<S['select'][P]>>  :
        P extends '_count' ? TransmissionsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof transmissions ? transmissions[P] : never
  } 
      : transmissions


  type transmissionsCountArgs = 
    Omit<transmissionsFindManyArgs, 'select' | 'include'> & {
      select?: TransmissionsCountAggregateInputType | true
    }

  export interface transmissionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Transmissions that matches the filter.
     * @param {transmissionsFindUniqueArgs} args - Arguments to find a Transmissions
     * @example
     * // Get one Transmissions
     * const transmissions = await prisma.transmissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends transmissionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, transmissionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'transmissions'> extends True ? Prisma__transmissionsClient<transmissionsGetPayload<T>> : Prisma__transmissionsClient<transmissionsGetPayload<T> | null, null>

    /**
     * Find one Transmissions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {transmissionsFindUniqueOrThrowArgs} args - Arguments to find a Transmissions
     * @example
     * // Get one Transmissions
     * const transmissions = await prisma.transmissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends transmissionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, transmissionsFindUniqueOrThrowArgs>
    ): Prisma__transmissionsClient<transmissionsGetPayload<T>>

    /**
     * Find the first Transmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transmissionsFindFirstArgs} args - Arguments to find a Transmissions
     * @example
     * // Get one Transmissions
     * const transmissions = await prisma.transmissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends transmissionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, transmissionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'transmissions'> extends True ? Prisma__transmissionsClient<transmissionsGetPayload<T>> : Prisma__transmissionsClient<transmissionsGetPayload<T> | null, null>

    /**
     * Find the first Transmissions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transmissionsFindFirstOrThrowArgs} args - Arguments to find a Transmissions
     * @example
     * // Get one Transmissions
     * const transmissions = await prisma.transmissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends transmissionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, transmissionsFindFirstOrThrowArgs>
    ): Prisma__transmissionsClient<transmissionsGetPayload<T>>

    /**
     * Find zero or more Transmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transmissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transmissions
     * const transmissions = await prisma.transmissions.findMany()
     * 
     * // Get first 10 Transmissions
     * const transmissions = await prisma.transmissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transmissionsWithIdOnly = await prisma.transmissions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends transmissionsFindManyArgs>(
      args?: SelectSubset<T, transmissionsFindManyArgs>
    ): Prisma.PrismaPromise<Array<transmissionsGetPayload<T>>>

    /**
     * Create a Transmissions.
     * @param {transmissionsCreateArgs} args - Arguments to create a Transmissions.
     * @example
     * // Create one Transmissions
     * const Transmissions = await prisma.transmissions.create({
     *   data: {
     *     // ... data to create a Transmissions
     *   }
     * })
     * 
    **/
    create<T extends transmissionsCreateArgs>(
      args: SelectSubset<T, transmissionsCreateArgs>
    ): Prisma__transmissionsClient<transmissionsGetPayload<T>>

    /**
     * Create many Transmissions.
     *     @param {transmissionsCreateManyArgs} args - Arguments to create many Transmissions.
     *     @example
     *     // Create many Transmissions
     *     const transmissions = await prisma.transmissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends transmissionsCreateManyArgs>(
      args?: SelectSubset<T, transmissionsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transmissions.
     * @param {transmissionsDeleteArgs} args - Arguments to delete one Transmissions.
     * @example
     * // Delete one Transmissions
     * const Transmissions = await prisma.transmissions.delete({
     *   where: {
     *     // ... filter to delete one Transmissions
     *   }
     * })
     * 
    **/
    delete<T extends transmissionsDeleteArgs>(
      args: SelectSubset<T, transmissionsDeleteArgs>
    ): Prisma__transmissionsClient<transmissionsGetPayload<T>>

    /**
     * Update one Transmissions.
     * @param {transmissionsUpdateArgs} args - Arguments to update one Transmissions.
     * @example
     * // Update one Transmissions
     * const transmissions = await prisma.transmissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends transmissionsUpdateArgs>(
      args: SelectSubset<T, transmissionsUpdateArgs>
    ): Prisma__transmissionsClient<transmissionsGetPayload<T>>

    /**
     * Delete zero or more Transmissions.
     * @param {transmissionsDeleteManyArgs} args - Arguments to filter Transmissions to delete.
     * @example
     * // Delete a few Transmissions
     * const { count } = await prisma.transmissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends transmissionsDeleteManyArgs>(
      args?: SelectSubset<T, transmissionsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transmissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transmissions
     * const transmissions = await prisma.transmissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends transmissionsUpdateManyArgs>(
      args: SelectSubset<T, transmissionsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transmissions.
     * @param {transmissionsUpsertArgs} args - Arguments to update or create a Transmissions.
     * @example
     * // Update or create a Transmissions
     * const transmissions = await prisma.transmissions.upsert({
     *   create: {
     *     // ... data to create a Transmissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transmissions we want to update
     *   }
     * })
    **/
    upsert<T extends transmissionsUpsertArgs>(
      args: SelectSubset<T, transmissionsUpsertArgs>
    ): Prisma__transmissionsClient<transmissionsGetPayload<T>>

    /**
     * Count the number of Transmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transmissionsCountArgs} args - Arguments to filter Transmissions to count.
     * @example
     * // Count the number of Transmissions
     * const count = await prisma.transmissions.count({
     *   where: {
     *     // ... the filter for the Transmissions we want to count
     *   }
     * })
    **/
    count<T extends transmissionsCountArgs>(
      args?: Subset<T, transmissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransmissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransmissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransmissionsAggregateArgs>(args: Subset<T, TransmissionsAggregateArgs>): Prisma.PrismaPromise<GetTransmissionsAggregateType<T>>

    /**
     * Group by Transmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransmissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransmissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransmissionsGroupByArgs['orderBy'] }
        : { orderBy?: TransmissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransmissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransmissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for transmissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__transmissionsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cars<T extends transmissions$carsArgs= {}>(args?: Subset<T, transmissions$carsArgs>): Prisma.PrismaPromise<Array<carsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * transmissions base type for findUnique actions
   */
  export type transmissionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the transmissions
     */
    select?: transmissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transmissionsInclude | null
    /**
     * Filter, which transmissions to fetch.
     */
    where: transmissionsWhereUniqueInput
  }

  /**
   * transmissions findUnique
   */
  export interface transmissionsFindUniqueArgs extends transmissionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * transmissions findUniqueOrThrow
   */
  export type transmissionsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the transmissions
     */
    select?: transmissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transmissionsInclude | null
    /**
     * Filter, which transmissions to fetch.
     */
    where: transmissionsWhereUniqueInput
  }


  /**
   * transmissions base type for findFirst actions
   */
  export type transmissionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the transmissions
     */
    select?: transmissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transmissionsInclude | null
    /**
     * Filter, which transmissions to fetch.
     */
    where?: transmissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transmissions to fetch.
     */
    orderBy?: Enumerable<transmissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transmissions.
     */
    cursor?: transmissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transmissions.
     */
    distinct?: Enumerable<TransmissionsScalarFieldEnum>
  }

  /**
   * transmissions findFirst
   */
  export interface transmissionsFindFirstArgs extends transmissionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * transmissions findFirstOrThrow
   */
  export type transmissionsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the transmissions
     */
    select?: transmissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transmissionsInclude | null
    /**
     * Filter, which transmissions to fetch.
     */
    where?: transmissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transmissions to fetch.
     */
    orderBy?: Enumerable<transmissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transmissions.
     */
    cursor?: transmissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transmissions.
     */
    distinct?: Enumerable<TransmissionsScalarFieldEnum>
  }


  /**
   * transmissions findMany
   */
  export type transmissionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the transmissions
     */
    select?: transmissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transmissionsInclude | null
    /**
     * Filter, which transmissions to fetch.
     */
    where?: transmissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transmissions to fetch.
     */
    orderBy?: Enumerable<transmissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transmissions.
     */
    cursor?: transmissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transmissions.
     */
    skip?: number
    distinct?: Enumerable<TransmissionsScalarFieldEnum>
  }


  /**
   * transmissions create
   */
  export type transmissionsCreateArgs = {
    /**
     * Select specific fields to fetch from the transmissions
     */
    select?: transmissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transmissionsInclude | null
    /**
     * The data needed to create a transmissions.
     */
    data: XOR<transmissionsCreateInput, transmissionsUncheckedCreateInput>
  }


  /**
   * transmissions createMany
   */
  export type transmissionsCreateManyArgs = {
    /**
     * The data used to create many transmissions.
     */
    data: Enumerable<transmissionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * transmissions update
   */
  export type transmissionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the transmissions
     */
    select?: transmissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transmissionsInclude | null
    /**
     * The data needed to update a transmissions.
     */
    data: XOR<transmissionsUpdateInput, transmissionsUncheckedUpdateInput>
    /**
     * Choose, which transmissions to update.
     */
    where: transmissionsWhereUniqueInput
  }


  /**
   * transmissions updateMany
   */
  export type transmissionsUpdateManyArgs = {
    /**
     * The data used to update transmissions.
     */
    data: XOR<transmissionsUpdateManyMutationInput, transmissionsUncheckedUpdateManyInput>
    /**
     * Filter which transmissions to update
     */
    where?: transmissionsWhereInput
  }


  /**
   * transmissions upsert
   */
  export type transmissionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the transmissions
     */
    select?: transmissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transmissionsInclude | null
    /**
     * The filter to search for the transmissions to update in case it exists.
     */
    where: transmissionsWhereUniqueInput
    /**
     * In case the transmissions found by the `where` argument doesn't exist, create a new transmissions with this data.
     */
    create: XOR<transmissionsCreateInput, transmissionsUncheckedCreateInput>
    /**
     * In case the transmissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transmissionsUpdateInput, transmissionsUncheckedUpdateInput>
  }


  /**
   * transmissions delete
   */
  export type transmissionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the transmissions
     */
    select?: transmissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transmissionsInclude | null
    /**
     * Filter which transmissions to delete.
     */
    where: transmissionsWhereUniqueInput
  }


  /**
   * transmissions deleteMany
   */
  export type transmissionsDeleteManyArgs = {
    /**
     * Filter which transmissions to delete
     */
    where?: transmissionsWhereInput
  }


  /**
   * transmissions.cars
   */
  export type transmissions$carsArgs = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    where?: carsWhereInput
    orderBy?: Enumerable<carsOrderByWithRelationInput>
    cursor?: carsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CarsScalarFieldEnum>
  }


  /**
   * transmissions without action
   */
  export type transmissionsArgs = {
    /**
     * Select specific fields to fetch from the transmissions
     */
    select?: transmissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transmissionsInclude | null
  }



  /**
   * Model users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    permissions: string | null
    last_login: Date | null
    first_name: string | null
    last_name: string | null
    bio: string | null
    gender: string | null
    dob: Date | null
    pic: string | null
    country: string | null
    state: string | null
    city: string | null
    address: string | null
    postal: string | null
    status: boolean | null
    reset_token: string | null
    token_expired_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    permissions: string | null
    last_login: Date | null
    first_name: string | null
    last_name: string | null
    bio: string | null
    gender: string | null
    dob: Date | null
    pic: string | null
    country: string | null
    state: string | null
    city: string | null
    address: string | null
    postal: string | null
    status: boolean | null
    reset_token: string | null
    token_expired_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    password: number
    permissions: number
    last_login: number
    first_name: number
    last_name: number
    bio: number
    gender: number
    dob: number
    pic: number
    country: number
    state: number
    city: number
    address: number
    postal: number
    status: number
    reset_token: number
    token_expired_at: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    permissions?: true
    last_login?: true
    first_name?: true
    last_name?: true
    bio?: true
    gender?: true
    dob?: true
    pic?: true
    country?: true
    state?: true
    city?: true
    address?: true
    postal?: true
    status?: true
    reset_token?: true
    token_expired_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    permissions?: true
    last_login?: true
    first_name?: true
    last_name?: true
    bio?: true
    gender?: true
    dob?: true
    pic?: true
    country?: true
    state?: true
    city?: true
    address?: true
    postal?: true
    status?: true
    reset_token?: true
    token_expired_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    permissions?: true
    last_login?: true
    first_name?: true
    last_name?: true
    bio?: true
    gender?: true
    dob?: true
    pic?: true
    country?: true
    state?: true
    city?: true
    address?: true
    postal?: true
    status?: true
    reset_token?: true
    token_expired_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs = {
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithAggregationInput>
    by: UsersScalarFieldEnum[]
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    id: number
    email: string
    password: string
    permissions: string | null
    last_login: Date | null
    first_name: string | null
    last_name: string | null
    bio: string | null
    gender: string | null
    dob: Date | null
    pic: string | null
    country: string | null
    state: string | null
    city: string | null
    address: string | null
    postal: string | null
    status: boolean | null
    reset_token: string | null
    token_expired_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect = {
    id?: boolean
    email?: boolean
    password?: boolean
    permissions?: boolean
    last_login?: boolean
    first_name?: boolean
    last_name?: boolean
    bio?: boolean
    gender?: boolean
    dob?: boolean
    pic?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    address?: boolean
    postal?: boolean
    status?: boolean
    reset_token?: boolean
    token_expired_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    role_users?: boolean | users$role_usersArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }


  export type usersInclude = {
    role_users?: boolean | users$role_usersArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersGetPayload<S extends boolean | null | undefined | usersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? users :
    S extends undefined ? never :
    S extends { include: any } & (usersArgs | usersFindManyArgs)
    ? users  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'role_users' ? Array < role_usersGetPayload<S['include'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (usersArgs | usersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'role_users' ? Array < role_usersGetPayload<S['select'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof users ? users[P] : never
  } 
      : users


  type usersCountArgs = 
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users'> extends True ? Prisma__usersClient<usersGetPayload<T>> : Prisma__usersClient<usersGetPayload<T> | null, null>

    /**
     * Find one Users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users'> extends True ? Prisma__usersClient<usersGetPayload<T>> : Prisma__usersClient<usersGetPayload<T> | null, null>

    /**
     * Find the first Users that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs>
    ): Prisma.PrismaPromise<Array<usersGetPayload<T>>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs>(
      args?: SelectSubset<T, usersCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    role_users<T extends users$role_usersArgs= {}>(args?: Subset<T, users$role_usersArgs>): Prisma.PrismaPromise<Array<role_usersGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * users base type for findUnique actions
   */
  export type usersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUnique
   */
  export interface usersFindUniqueArgs extends usersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users base type for findFirst actions
   */
  export type usersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UsersScalarFieldEnum>
  }

  /**
   * users findFirst
   */
  export interface usersFindFirstArgs extends usersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users findMany
   */
  export type usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users create
   */
  export type usersCreateArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs = {
    /**
     * The data used to create many users.
     */
    data: Enumerable<usersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }


  /**
   * users.role_users
   */
  export type users$role_usersArgs = {
    /**
     * Select specific fields to fetch from the role_users
     */
    select?: role_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: role_usersInclude | null
    where?: role_usersWhereInput
    orderBy?: Enumerable<role_usersOrderByWithRelationInput>
    cursor?: role_usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Role_usersScalarFieldEnum>
  }


  /**
   * users without action
   */
  export type usersArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
  }



  /**
   * Model location_exceptions
   */


  export type AggregateLocation_exceptions = {
    _count: Location_exceptionsCountAggregateOutputType | null
    _avg: Location_exceptionsAvgAggregateOutputType | null
    _sum: Location_exceptionsSumAggregateOutputType | null
    _min: Location_exceptionsMinAggregateOutputType | null
    _max: Location_exceptionsMaxAggregateOutputType | null
  }

  export type Location_exceptionsAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type Location_exceptionsSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type Location_exceptionsMinAggregateOutputType = {
    id: number | null
    pick_up_loc_name: string | null
    pick_up_postal_code: string | null
    drop_off_loc_name: string | null
    drop_off_postal_code: string | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Location_exceptionsMaxAggregateOutputType = {
    id: number | null
    pick_up_loc_name: string | null
    pick_up_postal_code: string | null
    drop_off_loc_name: string | null
    drop_off_postal_code: string | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Location_exceptionsCountAggregateOutputType = {
    id: number
    pick_up_loc_name: number
    pick_up_postal_code: number
    drop_off_loc_name: number
    drop_off_postal_code: number
    price: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Location_exceptionsAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type Location_exceptionsSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type Location_exceptionsMinAggregateInputType = {
    id?: true
    pick_up_loc_name?: true
    pick_up_postal_code?: true
    drop_off_loc_name?: true
    drop_off_postal_code?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type Location_exceptionsMaxAggregateInputType = {
    id?: true
    pick_up_loc_name?: true
    pick_up_postal_code?: true
    drop_off_loc_name?: true
    drop_off_postal_code?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type Location_exceptionsCountAggregateInputType = {
    id?: true
    pick_up_loc_name?: true
    pick_up_postal_code?: true
    drop_off_loc_name?: true
    drop_off_postal_code?: true
    price?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Location_exceptionsAggregateArgs = {
    /**
     * Filter which location_exceptions to aggregate.
     */
    where?: location_exceptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_exceptions to fetch.
     */
    orderBy?: Enumerable<location_exceptionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: location_exceptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_exceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_exceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned location_exceptions
    **/
    _count?: true | Location_exceptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Location_exceptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Location_exceptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Location_exceptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Location_exceptionsMaxAggregateInputType
  }

  export type GetLocation_exceptionsAggregateType<T extends Location_exceptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation_exceptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation_exceptions[P]>
      : GetScalarType<T[P], AggregateLocation_exceptions[P]>
  }




  export type Location_exceptionsGroupByArgs = {
    where?: location_exceptionsWhereInput
    orderBy?: Enumerable<location_exceptionsOrderByWithAggregationInput>
    by: Location_exceptionsScalarFieldEnum[]
    having?: location_exceptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Location_exceptionsCountAggregateInputType | true
    _avg?: Location_exceptionsAvgAggregateInputType
    _sum?: Location_exceptionsSumAggregateInputType
    _min?: Location_exceptionsMinAggregateInputType
    _max?: Location_exceptionsMaxAggregateInputType
  }


  export type Location_exceptionsGroupByOutputType = {
    id: number
    pick_up_loc_name: string | null
    pick_up_postal_code: string
    drop_off_loc_name: string | null
    drop_off_postal_code: string
    price: number
    created_at: Date | null
    updated_at: Date | null
    _count: Location_exceptionsCountAggregateOutputType | null
    _avg: Location_exceptionsAvgAggregateOutputType | null
    _sum: Location_exceptionsSumAggregateOutputType | null
    _min: Location_exceptionsMinAggregateOutputType | null
    _max: Location_exceptionsMaxAggregateOutputType | null
  }

  type GetLocation_exceptionsGroupByPayload<T extends Location_exceptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Location_exceptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Location_exceptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Location_exceptionsGroupByOutputType[P]>
            : GetScalarType<T[P], Location_exceptionsGroupByOutputType[P]>
        }
      >
    >


  export type location_exceptionsSelect = {
    id?: boolean
    pick_up_loc_name?: boolean
    pick_up_postal_code?: boolean
    drop_off_loc_name?: boolean
    drop_off_postal_code?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type location_exceptionsGetPayload<S extends boolean | null | undefined | location_exceptionsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? location_exceptions :
    S extends undefined ? never :
    S extends { include: any } & (location_exceptionsArgs | location_exceptionsFindManyArgs)
    ? location_exceptions 
    : S extends { select: any } & (location_exceptionsArgs | location_exceptionsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof location_exceptions ? location_exceptions[P] : never
  } 
      : location_exceptions


  type location_exceptionsCountArgs = 
    Omit<location_exceptionsFindManyArgs, 'select' | 'include'> & {
      select?: Location_exceptionsCountAggregateInputType | true
    }

  export interface location_exceptionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Location_exceptions that matches the filter.
     * @param {location_exceptionsFindUniqueArgs} args - Arguments to find a Location_exceptions
     * @example
     * // Get one Location_exceptions
     * const location_exceptions = await prisma.location_exceptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends location_exceptionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, location_exceptionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'location_exceptions'> extends True ? Prisma__location_exceptionsClient<location_exceptionsGetPayload<T>> : Prisma__location_exceptionsClient<location_exceptionsGetPayload<T> | null, null>

    /**
     * Find one Location_exceptions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {location_exceptionsFindUniqueOrThrowArgs} args - Arguments to find a Location_exceptions
     * @example
     * // Get one Location_exceptions
     * const location_exceptions = await prisma.location_exceptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends location_exceptionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, location_exceptionsFindUniqueOrThrowArgs>
    ): Prisma__location_exceptionsClient<location_exceptionsGetPayload<T>>

    /**
     * Find the first Location_exceptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_exceptionsFindFirstArgs} args - Arguments to find a Location_exceptions
     * @example
     * // Get one Location_exceptions
     * const location_exceptions = await prisma.location_exceptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends location_exceptionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, location_exceptionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'location_exceptions'> extends True ? Prisma__location_exceptionsClient<location_exceptionsGetPayload<T>> : Prisma__location_exceptionsClient<location_exceptionsGetPayload<T> | null, null>

    /**
     * Find the first Location_exceptions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_exceptionsFindFirstOrThrowArgs} args - Arguments to find a Location_exceptions
     * @example
     * // Get one Location_exceptions
     * const location_exceptions = await prisma.location_exceptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends location_exceptionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, location_exceptionsFindFirstOrThrowArgs>
    ): Prisma__location_exceptionsClient<location_exceptionsGetPayload<T>>

    /**
     * Find zero or more Location_exceptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_exceptionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Location_exceptions
     * const location_exceptions = await prisma.location_exceptions.findMany()
     * 
     * // Get first 10 Location_exceptions
     * const location_exceptions = await prisma.location_exceptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const location_exceptionsWithIdOnly = await prisma.location_exceptions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends location_exceptionsFindManyArgs>(
      args?: SelectSubset<T, location_exceptionsFindManyArgs>
    ): Prisma.PrismaPromise<Array<location_exceptionsGetPayload<T>>>

    /**
     * Create a Location_exceptions.
     * @param {location_exceptionsCreateArgs} args - Arguments to create a Location_exceptions.
     * @example
     * // Create one Location_exceptions
     * const Location_exceptions = await prisma.location_exceptions.create({
     *   data: {
     *     // ... data to create a Location_exceptions
     *   }
     * })
     * 
    **/
    create<T extends location_exceptionsCreateArgs>(
      args: SelectSubset<T, location_exceptionsCreateArgs>
    ): Prisma__location_exceptionsClient<location_exceptionsGetPayload<T>>

    /**
     * Create many Location_exceptions.
     *     @param {location_exceptionsCreateManyArgs} args - Arguments to create many Location_exceptions.
     *     @example
     *     // Create many Location_exceptions
     *     const location_exceptions = await prisma.location_exceptions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends location_exceptionsCreateManyArgs>(
      args?: SelectSubset<T, location_exceptionsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Location_exceptions.
     * @param {location_exceptionsDeleteArgs} args - Arguments to delete one Location_exceptions.
     * @example
     * // Delete one Location_exceptions
     * const Location_exceptions = await prisma.location_exceptions.delete({
     *   where: {
     *     // ... filter to delete one Location_exceptions
     *   }
     * })
     * 
    **/
    delete<T extends location_exceptionsDeleteArgs>(
      args: SelectSubset<T, location_exceptionsDeleteArgs>
    ): Prisma__location_exceptionsClient<location_exceptionsGetPayload<T>>

    /**
     * Update one Location_exceptions.
     * @param {location_exceptionsUpdateArgs} args - Arguments to update one Location_exceptions.
     * @example
     * // Update one Location_exceptions
     * const location_exceptions = await prisma.location_exceptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends location_exceptionsUpdateArgs>(
      args: SelectSubset<T, location_exceptionsUpdateArgs>
    ): Prisma__location_exceptionsClient<location_exceptionsGetPayload<T>>

    /**
     * Delete zero or more Location_exceptions.
     * @param {location_exceptionsDeleteManyArgs} args - Arguments to filter Location_exceptions to delete.
     * @example
     * // Delete a few Location_exceptions
     * const { count } = await prisma.location_exceptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends location_exceptionsDeleteManyArgs>(
      args?: SelectSubset<T, location_exceptionsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Location_exceptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_exceptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Location_exceptions
     * const location_exceptions = await prisma.location_exceptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends location_exceptionsUpdateManyArgs>(
      args: SelectSubset<T, location_exceptionsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location_exceptions.
     * @param {location_exceptionsUpsertArgs} args - Arguments to update or create a Location_exceptions.
     * @example
     * // Update or create a Location_exceptions
     * const location_exceptions = await prisma.location_exceptions.upsert({
     *   create: {
     *     // ... data to create a Location_exceptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location_exceptions we want to update
     *   }
     * })
    **/
    upsert<T extends location_exceptionsUpsertArgs>(
      args: SelectSubset<T, location_exceptionsUpsertArgs>
    ): Prisma__location_exceptionsClient<location_exceptionsGetPayload<T>>

    /**
     * Count the number of Location_exceptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_exceptionsCountArgs} args - Arguments to filter Location_exceptions to count.
     * @example
     * // Count the number of Location_exceptions
     * const count = await prisma.location_exceptions.count({
     *   where: {
     *     // ... the filter for the Location_exceptions we want to count
     *   }
     * })
    **/
    count<T extends location_exceptionsCountArgs>(
      args?: Subset<T, location_exceptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Location_exceptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location_exceptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Location_exceptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Location_exceptionsAggregateArgs>(args: Subset<T, Location_exceptionsAggregateArgs>): Prisma.PrismaPromise<GetLocation_exceptionsAggregateType<T>>

    /**
     * Group by Location_exceptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Location_exceptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Location_exceptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Location_exceptionsGroupByArgs['orderBy'] }
        : { orderBy?: Location_exceptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Location_exceptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocation_exceptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for location_exceptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__location_exceptionsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * location_exceptions base type for findUnique actions
   */
  export type location_exceptionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the location_exceptions
     */
    select?: location_exceptionsSelect | null
    /**
     * Filter, which location_exceptions to fetch.
     */
    where: location_exceptionsWhereUniqueInput
  }

  /**
   * location_exceptions findUnique
   */
  export interface location_exceptionsFindUniqueArgs extends location_exceptionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * location_exceptions findUniqueOrThrow
   */
  export type location_exceptionsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the location_exceptions
     */
    select?: location_exceptionsSelect | null
    /**
     * Filter, which location_exceptions to fetch.
     */
    where: location_exceptionsWhereUniqueInput
  }


  /**
   * location_exceptions base type for findFirst actions
   */
  export type location_exceptionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the location_exceptions
     */
    select?: location_exceptionsSelect | null
    /**
     * Filter, which location_exceptions to fetch.
     */
    where?: location_exceptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_exceptions to fetch.
     */
    orderBy?: Enumerable<location_exceptionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for location_exceptions.
     */
    cursor?: location_exceptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_exceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_exceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of location_exceptions.
     */
    distinct?: Enumerable<Location_exceptionsScalarFieldEnum>
  }

  /**
   * location_exceptions findFirst
   */
  export interface location_exceptionsFindFirstArgs extends location_exceptionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * location_exceptions findFirstOrThrow
   */
  export type location_exceptionsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the location_exceptions
     */
    select?: location_exceptionsSelect | null
    /**
     * Filter, which location_exceptions to fetch.
     */
    where?: location_exceptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_exceptions to fetch.
     */
    orderBy?: Enumerable<location_exceptionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for location_exceptions.
     */
    cursor?: location_exceptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_exceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_exceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of location_exceptions.
     */
    distinct?: Enumerable<Location_exceptionsScalarFieldEnum>
  }


  /**
   * location_exceptions findMany
   */
  export type location_exceptionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the location_exceptions
     */
    select?: location_exceptionsSelect | null
    /**
     * Filter, which location_exceptions to fetch.
     */
    where?: location_exceptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_exceptions to fetch.
     */
    orderBy?: Enumerable<location_exceptionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing location_exceptions.
     */
    cursor?: location_exceptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_exceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_exceptions.
     */
    skip?: number
    distinct?: Enumerable<Location_exceptionsScalarFieldEnum>
  }


  /**
   * location_exceptions create
   */
  export type location_exceptionsCreateArgs = {
    /**
     * Select specific fields to fetch from the location_exceptions
     */
    select?: location_exceptionsSelect | null
    /**
     * The data needed to create a location_exceptions.
     */
    data: XOR<location_exceptionsCreateInput, location_exceptionsUncheckedCreateInput>
  }


  /**
   * location_exceptions createMany
   */
  export type location_exceptionsCreateManyArgs = {
    /**
     * The data used to create many location_exceptions.
     */
    data: Enumerable<location_exceptionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * location_exceptions update
   */
  export type location_exceptionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the location_exceptions
     */
    select?: location_exceptionsSelect | null
    /**
     * The data needed to update a location_exceptions.
     */
    data: XOR<location_exceptionsUpdateInput, location_exceptionsUncheckedUpdateInput>
    /**
     * Choose, which location_exceptions to update.
     */
    where: location_exceptionsWhereUniqueInput
  }


  /**
   * location_exceptions updateMany
   */
  export type location_exceptionsUpdateManyArgs = {
    /**
     * The data used to update location_exceptions.
     */
    data: XOR<location_exceptionsUpdateManyMutationInput, location_exceptionsUncheckedUpdateManyInput>
    /**
     * Filter which location_exceptions to update
     */
    where?: location_exceptionsWhereInput
  }


  /**
   * location_exceptions upsert
   */
  export type location_exceptionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the location_exceptions
     */
    select?: location_exceptionsSelect | null
    /**
     * The filter to search for the location_exceptions to update in case it exists.
     */
    where: location_exceptionsWhereUniqueInput
    /**
     * In case the location_exceptions found by the `where` argument doesn't exist, create a new location_exceptions with this data.
     */
    create: XOR<location_exceptionsCreateInput, location_exceptionsUncheckedCreateInput>
    /**
     * In case the location_exceptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<location_exceptionsUpdateInput, location_exceptionsUncheckedUpdateInput>
  }


  /**
   * location_exceptions delete
   */
  export type location_exceptionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the location_exceptions
     */
    select?: location_exceptionsSelect | null
    /**
     * Filter which location_exceptions to delete.
     */
    where: location_exceptionsWhereUniqueInput
  }


  /**
   * location_exceptions deleteMany
   */
  export type location_exceptionsDeleteManyArgs = {
    /**
     * Filter which location_exceptions to delete
     */
    where?: location_exceptionsWhereInput
  }


  /**
   * location_exceptions without action
   */
  export type location_exceptionsArgs = {
    /**
     * Select specific fields to fetch from the location_exceptions
     */
    select?: location_exceptionsSelect | null
  }



  /**
   * Model package_serivce
   */


  export type AggregatePackage_serivce = {
    _count: Package_serivceCountAggregateOutputType | null
    _avg: Package_serivceAvgAggregateOutputType | null
    _sum: Package_serivceSumAggregateOutputType | null
    _min: Package_serivceMinAggregateOutputType | null
    _max: Package_serivceMaxAggregateOutputType | null
  }

  export type Package_serivceAvgAggregateOutputType = {
    id: number | null
    passenger_capacity: number | null
    price: number | null
    car_id: number | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    luggage: number | null
  }

  export type Package_serivceSumAggregateOutputType = {
    id: number | null
    passenger_capacity: number | null
    price: number | null
    car_id: number | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    luggage: number | null
  }

  export type Package_serivceMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    passenger_capacity: number | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
    car_id: number | null
    isActive: boolean | null
    pickup_location: string | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_location: string | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    luggage: number | null
  }

  export type Package_serivceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    passenger_capacity: number | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
    car_id: number | null
    isActive: boolean | null
    pickup_location: string | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_location: string | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    luggage: number | null
  }

  export type Package_serivceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    passenger_capacity: number
    price: number
    created_at: number
    updated_at: number
    car_id: number
    isActive: number
    pickup_location: number
    pickup_lat: number
    pickup_lng: number
    dropoff_location: number
    dropoff_lat: number
    dropoff_lng: number
    luggage: number
    _all: number
  }


  export type Package_serivceAvgAggregateInputType = {
    id?: true
    passenger_capacity?: true
    price?: true
    car_id?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_lat?: true
    dropoff_lng?: true
    luggage?: true
  }

  export type Package_serivceSumAggregateInputType = {
    id?: true
    passenger_capacity?: true
    price?: true
    car_id?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_lat?: true
    dropoff_lng?: true
    luggage?: true
  }

  export type Package_serivceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    passenger_capacity?: true
    price?: true
    created_at?: true
    updated_at?: true
    car_id?: true
    isActive?: true
    pickup_location?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_location?: true
    dropoff_lat?: true
    dropoff_lng?: true
    luggage?: true
  }

  export type Package_serivceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    passenger_capacity?: true
    price?: true
    created_at?: true
    updated_at?: true
    car_id?: true
    isActive?: true
    pickup_location?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_location?: true
    dropoff_lat?: true
    dropoff_lng?: true
    luggage?: true
  }

  export type Package_serivceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    passenger_capacity?: true
    price?: true
    created_at?: true
    updated_at?: true
    car_id?: true
    isActive?: true
    pickup_location?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_location?: true
    dropoff_lat?: true
    dropoff_lng?: true
    luggage?: true
    _all?: true
  }

  export type Package_serivceAggregateArgs = {
    /**
     * Filter which package_serivce to aggregate.
     */
    where?: package_serivceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_serivces to fetch.
     */
    orderBy?: Enumerable<package_serivceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: package_serivceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_serivces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_serivces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned package_serivces
    **/
    _count?: true | Package_serivceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Package_serivceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Package_serivceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Package_serivceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Package_serivceMaxAggregateInputType
  }

  export type GetPackage_serivceAggregateType<T extends Package_serivceAggregateArgs> = {
        [P in keyof T & keyof AggregatePackage_serivce]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackage_serivce[P]>
      : GetScalarType<T[P], AggregatePackage_serivce[P]>
  }




  export type Package_serivceGroupByArgs = {
    where?: package_serivceWhereInput
    orderBy?: Enumerable<package_serivceOrderByWithAggregationInput>
    by: Package_serivceScalarFieldEnum[]
    having?: package_serivceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Package_serivceCountAggregateInputType | true
    _avg?: Package_serivceAvgAggregateInputType
    _sum?: Package_serivceSumAggregateInputType
    _min?: Package_serivceMinAggregateInputType
    _max?: Package_serivceMaxAggregateInputType
  }


  export type Package_serivceGroupByOutputType = {
    id: number
    name: string | null
    description: string | null
    passenger_capacity: number
    price: number
    created_at: Date | null
    updated_at: Date | null
    car_id: number
    isActive: boolean | null
    pickup_location: string | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_location: string | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    luggage: number | null
    _count: Package_serivceCountAggregateOutputType | null
    _avg: Package_serivceAvgAggregateOutputType | null
    _sum: Package_serivceSumAggregateOutputType | null
    _min: Package_serivceMinAggregateOutputType | null
    _max: Package_serivceMaxAggregateOutputType | null
  }

  type GetPackage_serivceGroupByPayload<T extends Package_serivceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Package_serivceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Package_serivceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Package_serivceGroupByOutputType[P]>
            : GetScalarType<T[P], Package_serivceGroupByOutputType[P]>
        }
      >
    >


  export type package_serivceSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    passenger_capacity?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
    car_id?: boolean
    isActive?: boolean
    pickup_location?: boolean
    pickup_lat?: boolean
    pickup_lng?: boolean
    dropoff_location?: boolean
    dropoff_lat?: boolean
    dropoff_lng?: boolean
    luggage?: boolean
    cars?: boolean | carsArgs
  }


  export type package_serivceInclude = {
    cars?: boolean | carsArgs
  }

  export type package_serivceGetPayload<S extends boolean | null | undefined | package_serivceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? package_serivce :
    S extends undefined ? never :
    S extends { include: any } & (package_serivceArgs | package_serivceFindManyArgs)
    ? package_serivce  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'cars' ? carsGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (package_serivceArgs | package_serivceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'cars' ? carsGetPayload<S['select'][P]> :  P extends keyof package_serivce ? package_serivce[P] : never
  } 
      : package_serivce


  type package_serivceCountArgs = 
    Omit<package_serivceFindManyArgs, 'select' | 'include'> & {
      select?: Package_serivceCountAggregateInputType | true
    }

  export interface package_serivceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Package_serivce that matches the filter.
     * @param {package_serivceFindUniqueArgs} args - Arguments to find a Package_serivce
     * @example
     * // Get one Package_serivce
     * const package_serivce = await prisma.package_serivce.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends package_serivceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, package_serivceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'package_serivce'> extends True ? Prisma__package_serivceClient<package_serivceGetPayload<T>> : Prisma__package_serivceClient<package_serivceGetPayload<T> | null, null>

    /**
     * Find one Package_serivce that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {package_serivceFindUniqueOrThrowArgs} args - Arguments to find a Package_serivce
     * @example
     * // Get one Package_serivce
     * const package_serivce = await prisma.package_serivce.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends package_serivceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, package_serivceFindUniqueOrThrowArgs>
    ): Prisma__package_serivceClient<package_serivceGetPayload<T>>

    /**
     * Find the first Package_serivce that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_serivceFindFirstArgs} args - Arguments to find a Package_serivce
     * @example
     * // Get one Package_serivce
     * const package_serivce = await prisma.package_serivce.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends package_serivceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, package_serivceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'package_serivce'> extends True ? Prisma__package_serivceClient<package_serivceGetPayload<T>> : Prisma__package_serivceClient<package_serivceGetPayload<T> | null, null>

    /**
     * Find the first Package_serivce that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_serivceFindFirstOrThrowArgs} args - Arguments to find a Package_serivce
     * @example
     * // Get one Package_serivce
     * const package_serivce = await prisma.package_serivce.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends package_serivceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, package_serivceFindFirstOrThrowArgs>
    ): Prisma__package_serivceClient<package_serivceGetPayload<T>>

    /**
     * Find zero or more Package_serivces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_serivceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Package_serivces
     * const package_serivces = await prisma.package_serivce.findMany()
     * 
     * // Get first 10 Package_serivces
     * const package_serivces = await prisma.package_serivce.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const package_serivceWithIdOnly = await prisma.package_serivce.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends package_serivceFindManyArgs>(
      args?: SelectSubset<T, package_serivceFindManyArgs>
    ): Prisma.PrismaPromise<Array<package_serivceGetPayload<T>>>

    /**
     * Create a Package_serivce.
     * @param {package_serivceCreateArgs} args - Arguments to create a Package_serivce.
     * @example
     * // Create one Package_serivce
     * const Package_serivce = await prisma.package_serivce.create({
     *   data: {
     *     // ... data to create a Package_serivce
     *   }
     * })
     * 
    **/
    create<T extends package_serivceCreateArgs>(
      args: SelectSubset<T, package_serivceCreateArgs>
    ): Prisma__package_serivceClient<package_serivceGetPayload<T>>

    /**
     * Create many Package_serivces.
     *     @param {package_serivceCreateManyArgs} args - Arguments to create many Package_serivces.
     *     @example
     *     // Create many Package_serivces
     *     const package_serivce = await prisma.package_serivce.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends package_serivceCreateManyArgs>(
      args?: SelectSubset<T, package_serivceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Package_serivce.
     * @param {package_serivceDeleteArgs} args - Arguments to delete one Package_serivce.
     * @example
     * // Delete one Package_serivce
     * const Package_serivce = await prisma.package_serivce.delete({
     *   where: {
     *     // ... filter to delete one Package_serivce
     *   }
     * })
     * 
    **/
    delete<T extends package_serivceDeleteArgs>(
      args: SelectSubset<T, package_serivceDeleteArgs>
    ): Prisma__package_serivceClient<package_serivceGetPayload<T>>

    /**
     * Update one Package_serivce.
     * @param {package_serivceUpdateArgs} args - Arguments to update one Package_serivce.
     * @example
     * // Update one Package_serivce
     * const package_serivce = await prisma.package_serivce.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends package_serivceUpdateArgs>(
      args: SelectSubset<T, package_serivceUpdateArgs>
    ): Prisma__package_serivceClient<package_serivceGetPayload<T>>

    /**
     * Delete zero or more Package_serivces.
     * @param {package_serivceDeleteManyArgs} args - Arguments to filter Package_serivces to delete.
     * @example
     * // Delete a few Package_serivces
     * const { count } = await prisma.package_serivce.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends package_serivceDeleteManyArgs>(
      args?: SelectSubset<T, package_serivceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Package_serivces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_serivceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Package_serivces
     * const package_serivce = await prisma.package_serivce.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends package_serivceUpdateManyArgs>(
      args: SelectSubset<T, package_serivceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Package_serivce.
     * @param {package_serivceUpsertArgs} args - Arguments to update or create a Package_serivce.
     * @example
     * // Update or create a Package_serivce
     * const package_serivce = await prisma.package_serivce.upsert({
     *   create: {
     *     // ... data to create a Package_serivce
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Package_serivce we want to update
     *   }
     * })
    **/
    upsert<T extends package_serivceUpsertArgs>(
      args: SelectSubset<T, package_serivceUpsertArgs>
    ): Prisma__package_serivceClient<package_serivceGetPayload<T>>

    /**
     * Count the number of Package_serivces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {package_serivceCountArgs} args - Arguments to filter Package_serivces to count.
     * @example
     * // Count the number of Package_serivces
     * const count = await prisma.package_serivce.count({
     *   where: {
     *     // ... the filter for the Package_serivces we want to count
     *   }
     * })
    **/
    count<T extends package_serivceCountArgs>(
      args?: Subset<T, package_serivceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Package_serivceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Package_serivce.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Package_serivceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Package_serivceAggregateArgs>(args: Subset<T, Package_serivceAggregateArgs>): Prisma.PrismaPromise<GetPackage_serivceAggregateType<T>>

    /**
     * Group by Package_serivce.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Package_serivceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Package_serivceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Package_serivceGroupByArgs['orderBy'] }
        : { orderBy?: Package_serivceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Package_serivceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackage_serivceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for package_serivce.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__package_serivceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cars<T extends carsArgs= {}>(args?: Subset<T, carsArgs>): Prisma__carsClient<carsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * package_serivce base type for findUnique actions
   */
  export type package_serivceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the package_serivce
     */
    select?: package_serivceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: package_serivceInclude | null
    /**
     * Filter, which package_serivce to fetch.
     */
    where: package_serivceWhereUniqueInput
  }

  /**
   * package_serivce findUnique
   */
  export interface package_serivceFindUniqueArgs extends package_serivceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * package_serivce findUniqueOrThrow
   */
  export type package_serivceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the package_serivce
     */
    select?: package_serivceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: package_serivceInclude | null
    /**
     * Filter, which package_serivce to fetch.
     */
    where: package_serivceWhereUniqueInput
  }


  /**
   * package_serivce base type for findFirst actions
   */
  export type package_serivceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the package_serivce
     */
    select?: package_serivceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: package_serivceInclude | null
    /**
     * Filter, which package_serivce to fetch.
     */
    where?: package_serivceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_serivces to fetch.
     */
    orderBy?: Enumerable<package_serivceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for package_serivces.
     */
    cursor?: package_serivceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_serivces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_serivces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of package_serivces.
     */
    distinct?: Enumerable<Package_serivceScalarFieldEnum>
  }

  /**
   * package_serivce findFirst
   */
  export interface package_serivceFindFirstArgs extends package_serivceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * package_serivce findFirstOrThrow
   */
  export type package_serivceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the package_serivce
     */
    select?: package_serivceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: package_serivceInclude | null
    /**
     * Filter, which package_serivce to fetch.
     */
    where?: package_serivceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_serivces to fetch.
     */
    orderBy?: Enumerable<package_serivceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for package_serivces.
     */
    cursor?: package_serivceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_serivces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_serivces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of package_serivces.
     */
    distinct?: Enumerable<Package_serivceScalarFieldEnum>
  }


  /**
   * package_serivce findMany
   */
  export type package_serivceFindManyArgs = {
    /**
     * Select specific fields to fetch from the package_serivce
     */
    select?: package_serivceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: package_serivceInclude | null
    /**
     * Filter, which package_serivces to fetch.
     */
    where?: package_serivceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of package_serivces to fetch.
     */
    orderBy?: Enumerable<package_serivceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing package_serivces.
     */
    cursor?: package_serivceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` package_serivces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` package_serivces.
     */
    skip?: number
    distinct?: Enumerable<Package_serivceScalarFieldEnum>
  }


  /**
   * package_serivce create
   */
  export type package_serivceCreateArgs = {
    /**
     * Select specific fields to fetch from the package_serivce
     */
    select?: package_serivceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: package_serivceInclude | null
    /**
     * The data needed to create a package_serivce.
     */
    data: XOR<package_serivceCreateInput, package_serivceUncheckedCreateInput>
  }


  /**
   * package_serivce createMany
   */
  export type package_serivceCreateManyArgs = {
    /**
     * The data used to create many package_serivces.
     */
    data: Enumerable<package_serivceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * package_serivce update
   */
  export type package_serivceUpdateArgs = {
    /**
     * Select specific fields to fetch from the package_serivce
     */
    select?: package_serivceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: package_serivceInclude | null
    /**
     * The data needed to update a package_serivce.
     */
    data: XOR<package_serivceUpdateInput, package_serivceUncheckedUpdateInput>
    /**
     * Choose, which package_serivce to update.
     */
    where: package_serivceWhereUniqueInput
  }


  /**
   * package_serivce updateMany
   */
  export type package_serivceUpdateManyArgs = {
    /**
     * The data used to update package_serivces.
     */
    data: XOR<package_serivceUpdateManyMutationInput, package_serivceUncheckedUpdateManyInput>
    /**
     * Filter which package_serivces to update
     */
    where?: package_serivceWhereInput
  }


  /**
   * package_serivce upsert
   */
  export type package_serivceUpsertArgs = {
    /**
     * Select specific fields to fetch from the package_serivce
     */
    select?: package_serivceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: package_serivceInclude | null
    /**
     * The filter to search for the package_serivce to update in case it exists.
     */
    where: package_serivceWhereUniqueInput
    /**
     * In case the package_serivce found by the `where` argument doesn't exist, create a new package_serivce with this data.
     */
    create: XOR<package_serivceCreateInput, package_serivceUncheckedCreateInput>
    /**
     * In case the package_serivce was found with the provided `where` argument, update it with this data.
     */
    update: XOR<package_serivceUpdateInput, package_serivceUncheckedUpdateInput>
  }


  /**
   * package_serivce delete
   */
  export type package_serivceDeleteArgs = {
    /**
     * Select specific fields to fetch from the package_serivce
     */
    select?: package_serivceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: package_serivceInclude | null
    /**
     * Filter which package_serivce to delete.
     */
    where: package_serivceWhereUniqueInput
  }


  /**
   * package_serivce deleteMany
   */
  export type package_serivceDeleteManyArgs = {
    /**
     * Filter which package_serivces to delete
     */
    where?: package_serivceWhereInput
  }


  /**
   * package_serivce without action
   */
  export type package_serivceArgs = {
    /**
     * Select specific fields to fetch from the package_serivce
     */
    select?: package_serivceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: package_serivceInclude | null
  }



  /**
   * Model slabs
   */


  export type AggregateSlabs = {
    _count: SlabsCountAggregateOutputType | null
    _avg: SlabsAvgAggregateOutputType | null
    _sum: SlabsSumAggregateOutputType | null
    _min: SlabsMinAggregateOutputType | null
    _max: SlabsMaxAggregateOutputType | null
  }

  export type SlabsAvgAggregateOutputType = {
    id: number | null
    car_id: number | null
    initial_distance: number | null
    final_distance: number | null
    price: number | null
  }

  export type SlabsSumAggregateOutputType = {
    id: number | null
    car_id: number | null
    initial_distance: number | null
    final_distance: number | null
    price: number | null
  }

  export type SlabsMinAggregateOutputType = {
    id: number | null
    car_id: number | null
    initial_distance: number | null
    final_distance: number | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SlabsMaxAggregateOutputType = {
    id: number | null
    car_id: number | null
    initial_distance: number | null
    final_distance: number | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SlabsCountAggregateOutputType = {
    id: number
    car_id: number
    initial_distance: number
    final_distance: number
    price: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SlabsAvgAggregateInputType = {
    id?: true
    car_id?: true
    initial_distance?: true
    final_distance?: true
    price?: true
  }

  export type SlabsSumAggregateInputType = {
    id?: true
    car_id?: true
    initial_distance?: true
    final_distance?: true
    price?: true
  }

  export type SlabsMinAggregateInputType = {
    id?: true
    car_id?: true
    initial_distance?: true
    final_distance?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type SlabsMaxAggregateInputType = {
    id?: true
    car_id?: true
    initial_distance?: true
    final_distance?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type SlabsCountAggregateInputType = {
    id?: true
    car_id?: true
    initial_distance?: true
    final_distance?: true
    price?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SlabsAggregateArgs = {
    /**
     * Filter which slabs to aggregate.
     */
    where?: slabsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slabs to fetch.
     */
    orderBy?: Enumerable<slabsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: slabsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned slabs
    **/
    _count?: true | SlabsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SlabsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SlabsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SlabsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SlabsMaxAggregateInputType
  }

  export type GetSlabsAggregateType<T extends SlabsAggregateArgs> = {
        [P in keyof T & keyof AggregateSlabs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSlabs[P]>
      : GetScalarType<T[P], AggregateSlabs[P]>
  }




  export type SlabsGroupByArgs = {
    where?: slabsWhereInput
    orderBy?: Enumerable<slabsOrderByWithAggregationInput>
    by: SlabsScalarFieldEnum[]
    having?: slabsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SlabsCountAggregateInputType | true
    _avg?: SlabsAvgAggregateInputType
    _sum?: SlabsSumAggregateInputType
    _min?: SlabsMinAggregateInputType
    _max?: SlabsMaxAggregateInputType
  }


  export type SlabsGroupByOutputType = {
    id: number
    car_id: number
    initial_distance: number
    final_distance: number
    price: number
    created_at: Date | null
    updated_at: Date | null
    _count: SlabsCountAggregateOutputType | null
    _avg: SlabsAvgAggregateOutputType | null
    _sum: SlabsSumAggregateOutputType | null
    _min: SlabsMinAggregateOutputType | null
    _max: SlabsMaxAggregateOutputType | null
  }

  type GetSlabsGroupByPayload<T extends SlabsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SlabsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SlabsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SlabsGroupByOutputType[P]>
            : GetScalarType<T[P], SlabsGroupByOutputType[P]>
        }
      >
    >


  export type slabsSelect = {
    id?: boolean
    car_id?: boolean
    initial_distance?: boolean
    final_distance?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
    cars?: boolean | carsArgs
  }


  export type slabsInclude = {
    cars?: boolean | carsArgs
  }

  export type slabsGetPayload<S extends boolean | null | undefined | slabsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? slabs :
    S extends undefined ? never :
    S extends { include: any } & (slabsArgs | slabsFindManyArgs)
    ? slabs  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'cars' ? carsGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (slabsArgs | slabsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'cars' ? carsGetPayload<S['select'][P]> :  P extends keyof slabs ? slabs[P] : never
  } 
      : slabs


  type slabsCountArgs = 
    Omit<slabsFindManyArgs, 'select' | 'include'> & {
      select?: SlabsCountAggregateInputType | true
    }

  export interface slabsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Slabs that matches the filter.
     * @param {slabsFindUniqueArgs} args - Arguments to find a Slabs
     * @example
     * // Get one Slabs
     * const slabs = await prisma.slabs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends slabsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, slabsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'slabs'> extends True ? Prisma__slabsClient<slabsGetPayload<T>> : Prisma__slabsClient<slabsGetPayload<T> | null, null>

    /**
     * Find one Slabs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {slabsFindUniqueOrThrowArgs} args - Arguments to find a Slabs
     * @example
     * // Get one Slabs
     * const slabs = await prisma.slabs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends slabsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, slabsFindUniqueOrThrowArgs>
    ): Prisma__slabsClient<slabsGetPayload<T>>

    /**
     * Find the first Slabs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slabsFindFirstArgs} args - Arguments to find a Slabs
     * @example
     * // Get one Slabs
     * const slabs = await prisma.slabs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends slabsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, slabsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'slabs'> extends True ? Prisma__slabsClient<slabsGetPayload<T>> : Prisma__slabsClient<slabsGetPayload<T> | null, null>

    /**
     * Find the first Slabs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slabsFindFirstOrThrowArgs} args - Arguments to find a Slabs
     * @example
     * // Get one Slabs
     * const slabs = await prisma.slabs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends slabsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, slabsFindFirstOrThrowArgs>
    ): Prisma__slabsClient<slabsGetPayload<T>>

    /**
     * Find zero or more Slabs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slabsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Slabs
     * const slabs = await prisma.slabs.findMany()
     * 
     * // Get first 10 Slabs
     * const slabs = await prisma.slabs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const slabsWithIdOnly = await prisma.slabs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends slabsFindManyArgs>(
      args?: SelectSubset<T, slabsFindManyArgs>
    ): Prisma.PrismaPromise<Array<slabsGetPayload<T>>>

    /**
     * Create a Slabs.
     * @param {slabsCreateArgs} args - Arguments to create a Slabs.
     * @example
     * // Create one Slabs
     * const Slabs = await prisma.slabs.create({
     *   data: {
     *     // ... data to create a Slabs
     *   }
     * })
     * 
    **/
    create<T extends slabsCreateArgs>(
      args: SelectSubset<T, slabsCreateArgs>
    ): Prisma__slabsClient<slabsGetPayload<T>>

    /**
     * Create many Slabs.
     *     @param {slabsCreateManyArgs} args - Arguments to create many Slabs.
     *     @example
     *     // Create many Slabs
     *     const slabs = await prisma.slabs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends slabsCreateManyArgs>(
      args?: SelectSubset<T, slabsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Slabs.
     * @param {slabsDeleteArgs} args - Arguments to delete one Slabs.
     * @example
     * // Delete one Slabs
     * const Slabs = await prisma.slabs.delete({
     *   where: {
     *     // ... filter to delete one Slabs
     *   }
     * })
     * 
    **/
    delete<T extends slabsDeleteArgs>(
      args: SelectSubset<T, slabsDeleteArgs>
    ): Prisma__slabsClient<slabsGetPayload<T>>

    /**
     * Update one Slabs.
     * @param {slabsUpdateArgs} args - Arguments to update one Slabs.
     * @example
     * // Update one Slabs
     * const slabs = await prisma.slabs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends slabsUpdateArgs>(
      args: SelectSubset<T, slabsUpdateArgs>
    ): Prisma__slabsClient<slabsGetPayload<T>>

    /**
     * Delete zero or more Slabs.
     * @param {slabsDeleteManyArgs} args - Arguments to filter Slabs to delete.
     * @example
     * // Delete a few Slabs
     * const { count } = await prisma.slabs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends slabsDeleteManyArgs>(
      args?: SelectSubset<T, slabsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Slabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slabsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Slabs
     * const slabs = await prisma.slabs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends slabsUpdateManyArgs>(
      args: SelectSubset<T, slabsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Slabs.
     * @param {slabsUpsertArgs} args - Arguments to update or create a Slabs.
     * @example
     * // Update or create a Slabs
     * const slabs = await prisma.slabs.upsert({
     *   create: {
     *     // ... data to create a Slabs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Slabs we want to update
     *   }
     * })
    **/
    upsert<T extends slabsUpsertArgs>(
      args: SelectSubset<T, slabsUpsertArgs>
    ): Prisma__slabsClient<slabsGetPayload<T>>

    /**
     * Count the number of Slabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slabsCountArgs} args - Arguments to filter Slabs to count.
     * @example
     * // Count the number of Slabs
     * const count = await prisma.slabs.count({
     *   where: {
     *     // ... the filter for the Slabs we want to count
     *   }
     * })
    **/
    count<T extends slabsCountArgs>(
      args?: Subset<T, slabsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SlabsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Slabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlabsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SlabsAggregateArgs>(args: Subset<T, SlabsAggregateArgs>): Prisma.PrismaPromise<GetSlabsAggregateType<T>>

    /**
     * Group by Slabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlabsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SlabsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SlabsGroupByArgs['orderBy'] }
        : { orderBy?: SlabsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SlabsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSlabsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for slabs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__slabsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cars<T extends carsArgs= {}>(args?: Subset<T, carsArgs>): Prisma__carsClient<carsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * slabs base type for findUnique actions
   */
  export type slabsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the slabs
     */
    select?: slabsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slabsInclude | null
    /**
     * Filter, which slabs to fetch.
     */
    where: slabsWhereUniqueInput
  }

  /**
   * slabs findUnique
   */
  export interface slabsFindUniqueArgs extends slabsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * slabs findUniqueOrThrow
   */
  export type slabsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the slabs
     */
    select?: slabsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slabsInclude | null
    /**
     * Filter, which slabs to fetch.
     */
    where: slabsWhereUniqueInput
  }


  /**
   * slabs base type for findFirst actions
   */
  export type slabsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the slabs
     */
    select?: slabsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slabsInclude | null
    /**
     * Filter, which slabs to fetch.
     */
    where?: slabsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slabs to fetch.
     */
    orderBy?: Enumerable<slabsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for slabs.
     */
    cursor?: slabsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of slabs.
     */
    distinct?: Enumerable<SlabsScalarFieldEnum>
  }

  /**
   * slabs findFirst
   */
  export interface slabsFindFirstArgs extends slabsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * slabs findFirstOrThrow
   */
  export type slabsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the slabs
     */
    select?: slabsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slabsInclude | null
    /**
     * Filter, which slabs to fetch.
     */
    where?: slabsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slabs to fetch.
     */
    orderBy?: Enumerable<slabsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for slabs.
     */
    cursor?: slabsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of slabs.
     */
    distinct?: Enumerable<SlabsScalarFieldEnum>
  }


  /**
   * slabs findMany
   */
  export type slabsFindManyArgs = {
    /**
     * Select specific fields to fetch from the slabs
     */
    select?: slabsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slabsInclude | null
    /**
     * Filter, which slabs to fetch.
     */
    where?: slabsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slabs to fetch.
     */
    orderBy?: Enumerable<slabsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing slabs.
     */
    cursor?: slabsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slabs.
     */
    skip?: number
    distinct?: Enumerable<SlabsScalarFieldEnum>
  }


  /**
   * slabs create
   */
  export type slabsCreateArgs = {
    /**
     * Select specific fields to fetch from the slabs
     */
    select?: slabsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slabsInclude | null
    /**
     * The data needed to create a slabs.
     */
    data: XOR<slabsCreateInput, slabsUncheckedCreateInput>
  }


  /**
   * slabs createMany
   */
  export type slabsCreateManyArgs = {
    /**
     * The data used to create many slabs.
     */
    data: Enumerable<slabsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * slabs update
   */
  export type slabsUpdateArgs = {
    /**
     * Select specific fields to fetch from the slabs
     */
    select?: slabsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slabsInclude | null
    /**
     * The data needed to update a slabs.
     */
    data: XOR<slabsUpdateInput, slabsUncheckedUpdateInput>
    /**
     * Choose, which slabs to update.
     */
    where: slabsWhereUniqueInput
  }


  /**
   * slabs updateMany
   */
  export type slabsUpdateManyArgs = {
    /**
     * The data used to update slabs.
     */
    data: XOR<slabsUpdateManyMutationInput, slabsUncheckedUpdateManyInput>
    /**
     * Filter which slabs to update
     */
    where?: slabsWhereInput
  }


  /**
   * slabs upsert
   */
  export type slabsUpsertArgs = {
    /**
     * Select specific fields to fetch from the slabs
     */
    select?: slabsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slabsInclude | null
    /**
     * The filter to search for the slabs to update in case it exists.
     */
    where: slabsWhereUniqueInput
    /**
     * In case the slabs found by the `where` argument doesn't exist, create a new slabs with this data.
     */
    create: XOR<slabsCreateInput, slabsUncheckedCreateInput>
    /**
     * In case the slabs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<slabsUpdateInput, slabsUncheckedUpdateInput>
  }


  /**
   * slabs delete
   */
  export type slabsDeleteArgs = {
    /**
     * Select specific fields to fetch from the slabs
     */
    select?: slabsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slabsInclude | null
    /**
     * Filter which slabs to delete.
     */
    where: slabsWhereUniqueInput
  }


  /**
   * slabs deleteMany
   */
  export type slabsDeleteManyArgs = {
    /**
     * Filter which slabs to delete
     */
    where?: slabsWhereInput
  }


  /**
   * slabs without action
   */
  export type slabsArgs = {
    /**
     * Select specific fields to fetch from the slabs
     */
    select?: slabsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slabsInclude | null
  }



  /**
   * Model timeslots
   */


  export type AggregateTimeslots = {
    _count: TimeslotsCountAggregateOutputType | null
    _avg: TimeslotsAvgAggregateOutputType | null
    _sum: TimeslotsSumAggregateOutputType | null
    _min: TimeslotsMinAggregateOutputType | null
    _max: TimeslotsMaxAggregateOutputType | null
  }

  export type TimeslotsAvgAggregateOutputType = {
    id: number | null
    sub_service_id: number | null
  }

  export type TimeslotsSumAggregateOutputType = {
    id: number | null
    sub_service_id: number | null
  }

  export type TimeslotsMinAggregateOutputType = {
    id: number | null
    time: Date | null
    isActive: boolean | null
    sub_service_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TimeslotsMaxAggregateOutputType = {
    id: number | null
    time: Date | null
    isActive: boolean | null
    sub_service_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TimeslotsCountAggregateOutputType = {
    id: number
    time: number
    isActive: number
    sub_service_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TimeslotsAvgAggregateInputType = {
    id?: true
    sub_service_id?: true
  }

  export type TimeslotsSumAggregateInputType = {
    id?: true
    sub_service_id?: true
  }

  export type TimeslotsMinAggregateInputType = {
    id?: true
    time?: true
    isActive?: true
    sub_service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type TimeslotsMaxAggregateInputType = {
    id?: true
    time?: true
    isActive?: true
    sub_service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type TimeslotsCountAggregateInputType = {
    id?: true
    time?: true
    isActive?: true
    sub_service_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TimeslotsAggregateArgs = {
    /**
     * Filter which timeslots to aggregate.
     */
    where?: timeslotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of timeslots to fetch.
     */
    orderBy?: Enumerable<timeslotsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: timeslotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` timeslots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` timeslots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned timeslots
    **/
    _count?: true | TimeslotsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeslotsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeslotsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeslotsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeslotsMaxAggregateInputType
  }

  export type GetTimeslotsAggregateType<T extends TimeslotsAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeslots]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeslots[P]>
      : GetScalarType<T[P], AggregateTimeslots[P]>
  }




  export type TimeslotsGroupByArgs = {
    where?: timeslotsWhereInput
    orderBy?: Enumerable<timeslotsOrderByWithAggregationInput>
    by: TimeslotsScalarFieldEnum[]
    having?: timeslotsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeslotsCountAggregateInputType | true
    _avg?: TimeslotsAvgAggregateInputType
    _sum?: TimeslotsSumAggregateInputType
    _min?: TimeslotsMinAggregateInputType
    _max?: TimeslotsMaxAggregateInputType
  }


  export type TimeslotsGroupByOutputType = {
    id: number
    time: Date | null
    isActive: boolean | null
    sub_service_id: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: TimeslotsCountAggregateOutputType | null
    _avg: TimeslotsAvgAggregateOutputType | null
    _sum: TimeslotsSumAggregateOutputType | null
    _min: TimeslotsMinAggregateOutputType | null
    _max: TimeslotsMaxAggregateOutputType | null
  }

  type GetTimeslotsGroupByPayload<T extends TimeslotsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TimeslotsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeslotsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeslotsGroupByOutputType[P]>
            : GetScalarType<T[P], TimeslotsGroupByOutputType[P]>
        }
      >
    >


  export type timeslotsSelect = {
    id?: boolean
    time?: boolean
    isActive?: boolean
    sub_service_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    sub_services?: boolean | sub_servicesArgs
  }


  export type timeslotsInclude = {
    sub_services?: boolean | sub_servicesArgs
  }

  export type timeslotsGetPayload<S extends boolean | null | undefined | timeslotsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? timeslots :
    S extends undefined ? never :
    S extends { include: any } & (timeslotsArgs | timeslotsFindManyArgs)
    ? timeslots  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'sub_services' ? sub_servicesGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (timeslotsArgs | timeslotsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'sub_services' ? sub_servicesGetPayload<S['select'][P]> | null :  P extends keyof timeslots ? timeslots[P] : never
  } 
      : timeslots


  type timeslotsCountArgs = 
    Omit<timeslotsFindManyArgs, 'select' | 'include'> & {
      select?: TimeslotsCountAggregateInputType | true
    }

  export interface timeslotsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Timeslots that matches the filter.
     * @param {timeslotsFindUniqueArgs} args - Arguments to find a Timeslots
     * @example
     * // Get one Timeslots
     * const timeslots = await prisma.timeslots.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends timeslotsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, timeslotsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'timeslots'> extends True ? Prisma__timeslotsClient<timeslotsGetPayload<T>> : Prisma__timeslotsClient<timeslotsGetPayload<T> | null, null>

    /**
     * Find one Timeslots that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {timeslotsFindUniqueOrThrowArgs} args - Arguments to find a Timeslots
     * @example
     * // Get one Timeslots
     * const timeslots = await prisma.timeslots.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends timeslotsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, timeslotsFindUniqueOrThrowArgs>
    ): Prisma__timeslotsClient<timeslotsGetPayload<T>>

    /**
     * Find the first Timeslots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeslotsFindFirstArgs} args - Arguments to find a Timeslots
     * @example
     * // Get one Timeslots
     * const timeslots = await prisma.timeslots.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends timeslotsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, timeslotsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'timeslots'> extends True ? Prisma__timeslotsClient<timeslotsGetPayload<T>> : Prisma__timeslotsClient<timeslotsGetPayload<T> | null, null>

    /**
     * Find the first Timeslots that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeslotsFindFirstOrThrowArgs} args - Arguments to find a Timeslots
     * @example
     * // Get one Timeslots
     * const timeslots = await prisma.timeslots.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends timeslotsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, timeslotsFindFirstOrThrowArgs>
    ): Prisma__timeslotsClient<timeslotsGetPayload<T>>

    /**
     * Find zero or more Timeslots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeslotsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Timeslots
     * const timeslots = await prisma.timeslots.findMany()
     * 
     * // Get first 10 Timeslots
     * const timeslots = await prisma.timeslots.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeslotsWithIdOnly = await prisma.timeslots.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends timeslotsFindManyArgs>(
      args?: SelectSubset<T, timeslotsFindManyArgs>
    ): Prisma.PrismaPromise<Array<timeslotsGetPayload<T>>>

    /**
     * Create a Timeslots.
     * @param {timeslotsCreateArgs} args - Arguments to create a Timeslots.
     * @example
     * // Create one Timeslots
     * const Timeslots = await prisma.timeslots.create({
     *   data: {
     *     // ... data to create a Timeslots
     *   }
     * })
     * 
    **/
    create<T extends timeslotsCreateArgs>(
      args: SelectSubset<T, timeslotsCreateArgs>
    ): Prisma__timeslotsClient<timeslotsGetPayload<T>>

    /**
     * Create many Timeslots.
     *     @param {timeslotsCreateManyArgs} args - Arguments to create many Timeslots.
     *     @example
     *     // Create many Timeslots
     *     const timeslots = await prisma.timeslots.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends timeslotsCreateManyArgs>(
      args?: SelectSubset<T, timeslotsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Timeslots.
     * @param {timeslotsDeleteArgs} args - Arguments to delete one Timeslots.
     * @example
     * // Delete one Timeslots
     * const Timeslots = await prisma.timeslots.delete({
     *   where: {
     *     // ... filter to delete one Timeslots
     *   }
     * })
     * 
    **/
    delete<T extends timeslotsDeleteArgs>(
      args: SelectSubset<T, timeslotsDeleteArgs>
    ): Prisma__timeslotsClient<timeslotsGetPayload<T>>

    /**
     * Update one Timeslots.
     * @param {timeslotsUpdateArgs} args - Arguments to update one Timeslots.
     * @example
     * // Update one Timeslots
     * const timeslots = await prisma.timeslots.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends timeslotsUpdateArgs>(
      args: SelectSubset<T, timeslotsUpdateArgs>
    ): Prisma__timeslotsClient<timeslotsGetPayload<T>>

    /**
     * Delete zero or more Timeslots.
     * @param {timeslotsDeleteManyArgs} args - Arguments to filter Timeslots to delete.
     * @example
     * // Delete a few Timeslots
     * const { count } = await prisma.timeslots.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends timeslotsDeleteManyArgs>(
      args?: SelectSubset<T, timeslotsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Timeslots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeslotsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Timeslots
     * const timeslots = await prisma.timeslots.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends timeslotsUpdateManyArgs>(
      args: SelectSubset<T, timeslotsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Timeslots.
     * @param {timeslotsUpsertArgs} args - Arguments to update or create a Timeslots.
     * @example
     * // Update or create a Timeslots
     * const timeslots = await prisma.timeslots.upsert({
     *   create: {
     *     // ... data to create a Timeslots
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Timeslots we want to update
     *   }
     * })
    **/
    upsert<T extends timeslotsUpsertArgs>(
      args: SelectSubset<T, timeslotsUpsertArgs>
    ): Prisma__timeslotsClient<timeslotsGetPayload<T>>

    /**
     * Count the number of Timeslots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeslotsCountArgs} args - Arguments to filter Timeslots to count.
     * @example
     * // Count the number of Timeslots
     * const count = await prisma.timeslots.count({
     *   where: {
     *     // ... the filter for the Timeslots we want to count
     *   }
     * })
    **/
    count<T extends timeslotsCountArgs>(
      args?: Subset<T, timeslotsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeslotsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Timeslots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeslotsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeslotsAggregateArgs>(args: Subset<T, TimeslotsAggregateArgs>): Prisma.PrismaPromise<GetTimeslotsAggregateType<T>>

    /**
     * Group by Timeslots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeslotsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeslotsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeslotsGroupByArgs['orderBy'] }
        : { orderBy?: TimeslotsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeslotsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeslotsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for timeslots.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__timeslotsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    sub_services<T extends sub_servicesArgs= {}>(args?: Subset<T, sub_servicesArgs>): Prisma__sub_servicesClient<sub_servicesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * timeslots base type for findUnique actions
   */
  export type timeslotsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the timeslots
     */
    select?: timeslotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: timeslotsInclude | null
    /**
     * Filter, which timeslots to fetch.
     */
    where: timeslotsWhereUniqueInput
  }

  /**
   * timeslots findUnique
   */
  export interface timeslotsFindUniqueArgs extends timeslotsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * timeslots findUniqueOrThrow
   */
  export type timeslotsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the timeslots
     */
    select?: timeslotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: timeslotsInclude | null
    /**
     * Filter, which timeslots to fetch.
     */
    where: timeslotsWhereUniqueInput
  }


  /**
   * timeslots base type for findFirst actions
   */
  export type timeslotsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the timeslots
     */
    select?: timeslotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: timeslotsInclude | null
    /**
     * Filter, which timeslots to fetch.
     */
    where?: timeslotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of timeslots to fetch.
     */
    orderBy?: Enumerable<timeslotsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for timeslots.
     */
    cursor?: timeslotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` timeslots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` timeslots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of timeslots.
     */
    distinct?: Enumerable<TimeslotsScalarFieldEnum>
  }

  /**
   * timeslots findFirst
   */
  export interface timeslotsFindFirstArgs extends timeslotsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * timeslots findFirstOrThrow
   */
  export type timeslotsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the timeslots
     */
    select?: timeslotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: timeslotsInclude | null
    /**
     * Filter, which timeslots to fetch.
     */
    where?: timeslotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of timeslots to fetch.
     */
    orderBy?: Enumerable<timeslotsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for timeslots.
     */
    cursor?: timeslotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` timeslots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` timeslots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of timeslots.
     */
    distinct?: Enumerable<TimeslotsScalarFieldEnum>
  }


  /**
   * timeslots findMany
   */
  export type timeslotsFindManyArgs = {
    /**
     * Select specific fields to fetch from the timeslots
     */
    select?: timeslotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: timeslotsInclude | null
    /**
     * Filter, which timeslots to fetch.
     */
    where?: timeslotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of timeslots to fetch.
     */
    orderBy?: Enumerable<timeslotsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing timeslots.
     */
    cursor?: timeslotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` timeslots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` timeslots.
     */
    skip?: number
    distinct?: Enumerable<TimeslotsScalarFieldEnum>
  }


  /**
   * timeslots create
   */
  export type timeslotsCreateArgs = {
    /**
     * Select specific fields to fetch from the timeslots
     */
    select?: timeslotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: timeslotsInclude | null
    /**
     * The data needed to create a timeslots.
     */
    data: XOR<timeslotsCreateInput, timeslotsUncheckedCreateInput>
  }


  /**
   * timeslots createMany
   */
  export type timeslotsCreateManyArgs = {
    /**
     * The data used to create many timeslots.
     */
    data: Enumerable<timeslotsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * timeslots update
   */
  export type timeslotsUpdateArgs = {
    /**
     * Select specific fields to fetch from the timeslots
     */
    select?: timeslotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: timeslotsInclude | null
    /**
     * The data needed to update a timeslots.
     */
    data: XOR<timeslotsUpdateInput, timeslotsUncheckedUpdateInput>
    /**
     * Choose, which timeslots to update.
     */
    where: timeslotsWhereUniqueInput
  }


  /**
   * timeslots updateMany
   */
  export type timeslotsUpdateManyArgs = {
    /**
     * The data used to update timeslots.
     */
    data: XOR<timeslotsUpdateManyMutationInput, timeslotsUncheckedUpdateManyInput>
    /**
     * Filter which timeslots to update
     */
    where?: timeslotsWhereInput
  }


  /**
   * timeslots upsert
   */
  export type timeslotsUpsertArgs = {
    /**
     * Select specific fields to fetch from the timeslots
     */
    select?: timeslotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: timeslotsInclude | null
    /**
     * The filter to search for the timeslots to update in case it exists.
     */
    where: timeslotsWhereUniqueInput
    /**
     * In case the timeslots found by the `where` argument doesn't exist, create a new timeslots with this data.
     */
    create: XOR<timeslotsCreateInput, timeslotsUncheckedCreateInput>
    /**
     * In case the timeslots was found with the provided `where` argument, update it with this data.
     */
    update: XOR<timeslotsUpdateInput, timeslotsUncheckedUpdateInput>
  }


  /**
   * timeslots delete
   */
  export type timeslotsDeleteArgs = {
    /**
     * Select specific fields to fetch from the timeslots
     */
    select?: timeslotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: timeslotsInclude | null
    /**
     * Filter which timeslots to delete.
     */
    where: timeslotsWhereUniqueInput
  }


  /**
   * timeslots deleteMany
   */
  export type timeslotsDeleteManyArgs = {
    /**
     * Filter which timeslots to delete
     */
    where?: timeslotsWhereInput
  }


  /**
   * timeslots without action
   */
  export type timeslotsArgs = {
    /**
     * Select specific fields to fetch from the timeslots
     */
    select?: timeslotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: timeslotsInclude | null
  }



  /**
   * Model vehicle_types
   */


  export type AggregateVehicle_types = {
    _count: Vehicle_typesCountAggregateOutputType | null
    _avg: Vehicle_typesAvgAggregateOutputType | null
    _sum: Vehicle_typesSumAggregateOutputType | null
    _min: Vehicle_typesMinAggregateOutputType | null
    _max: Vehicle_typesMaxAggregateOutputType | null
  }

  export type Vehicle_typesAvgAggregateOutputType = {
    id: number | null
  }

  export type Vehicle_typesSumAggregateOutputType = {
    id: number | null
  }

  export type Vehicle_typesMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Vehicle_typesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Vehicle_typesCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Vehicle_typesAvgAggregateInputType = {
    id?: true
  }

  export type Vehicle_typesSumAggregateInputType = {
    id?: true
  }

  export type Vehicle_typesMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type Vehicle_typesMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type Vehicle_typesCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Vehicle_typesAggregateArgs = {
    /**
     * Filter which vehicle_types to aggregate.
     */
    where?: vehicle_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_types to fetch.
     */
    orderBy?: Enumerable<vehicle_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_types
    **/
    _count?: true | Vehicle_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Vehicle_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Vehicle_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_typesMaxAggregateInputType
  }

  export type GetVehicle_typesAggregateType<T extends Vehicle_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_types[P]>
      : GetScalarType<T[P], AggregateVehicle_types[P]>
  }




  export type Vehicle_typesGroupByArgs = {
    where?: vehicle_typesWhereInput
    orderBy?: Enumerable<vehicle_typesOrderByWithAggregationInput>
    by: Vehicle_typesScalarFieldEnum[]
    having?: vehicle_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_typesCountAggregateInputType | true
    _avg?: Vehicle_typesAvgAggregateInputType
    _sum?: Vehicle_typesSumAggregateInputType
    _min?: Vehicle_typesMinAggregateInputType
    _max?: Vehicle_typesMaxAggregateInputType
  }


  export type Vehicle_typesGroupByOutputType = {
    id: number
    name: string
    created_at: Date | null
    updated_at: Date | null
    _count: Vehicle_typesCountAggregateOutputType | null
    _avg: Vehicle_typesAvgAggregateOutputType | null
    _sum: Vehicle_typesSumAggregateOutputType | null
    _min: Vehicle_typesMinAggregateOutputType | null
    _max: Vehicle_typesMaxAggregateOutputType | null
  }

  type GetVehicle_typesGroupByPayload<T extends Vehicle_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Vehicle_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_typesGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_typesSelect = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    cars?: boolean | vehicle_types$carsArgs
    _count?: boolean | Vehicle_typesCountOutputTypeArgs
  }


  export type vehicle_typesInclude = {
    cars?: boolean | vehicle_types$carsArgs
    _count?: boolean | Vehicle_typesCountOutputTypeArgs
  }

  export type vehicle_typesGetPayload<S extends boolean | null | undefined | vehicle_typesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? vehicle_types :
    S extends undefined ? never :
    S extends { include: any } & (vehicle_typesArgs | vehicle_typesFindManyArgs)
    ? vehicle_types  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'cars' ? Array < carsGetPayload<S['include'][P]>>  :
        P extends '_count' ? Vehicle_typesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (vehicle_typesArgs | vehicle_typesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'cars' ? Array < carsGetPayload<S['select'][P]>>  :
        P extends '_count' ? Vehicle_typesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof vehicle_types ? vehicle_types[P] : never
  } 
      : vehicle_types


  type vehicle_typesCountArgs = 
    Omit<vehicle_typesFindManyArgs, 'select' | 'include'> & {
      select?: Vehicle_typesCountAggregateInputType | true
    }

  export interface vehicle_typesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Vehicle_types that matches the filter.
     * @param {vehicle_typesFindUniqueArgs} args - Arguments to find a Vehicle_types
     * @example
     * // Get one Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vehicle_typesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, vehicle_typesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'vehicle_types'> extends True ? Prisma__vehicle_typesClient<vehicle_typesGetPayload<T>> : Prisma__vehicle_typesClient<vehicle_typesGetPayload<T> | null, null>

    /**
     * Find one Vehicle_types that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {vehicle_typesFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_types
     * @example
     * // Get one Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vehicle_typesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, vehicle_typesFindUniqueOrThrowArgs>
    ): Prisma__vehicle_typesClient<vehicle_typesGetPayload<T>>

    /**
     * Find the first Vehicle_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typesFindFirstArgs} args - Arguments to find a Vehicle_types
     * @example
     * // Get one Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vehicle_typesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, vehicle_typesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'vehicle_types'> extends True ? Prisma__vehicle_typesClient<vehicle_typesGetPayload<T>> : Prisma__vehicle_typesClient<vehicle_typesGetPayload<T> | null, null>

    /**
     * Find the first Vehicle_types that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typesFindFirstOrThrowArgs} args - Arguments to find a Vehicle_types
     * @example
     * // Get one Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vehicle_typesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, vehicle_typesFindFirstOrThrowArgs>
    ): Prisma__vehicle_typesClient<vehicle_typesGetPayload<T>>

    /**
     * Find zero or more Vehicle_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.findMany()
     * 
     * // Get first 10 Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_typesWithIdOnly = await prisma.vehicle_types.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends vehicle_typesFindManyArgs>(
      args?: SelectSubset<T, vehicle_typesFindManyArgs>
    ): Prisma.PrismaPromise<Array<vehicle_typesGetPayload<T>>>

    /**
     * Create a Vehicle_types.
     * @param {vehicle_typesCreateArgs} args - Arguments to create a Vehicle_types.
     * @example
     * // Create one Vehicle_types
     * const Vehicle_types = await prisma.vehicle_types.create({
     *   data: {
     *     // ... data to create a Vehicle_types
     *   }
     * })
     * 
    **/
    create<T extends vehicle_typesCreateArgs>(
      args: SelectSubset<T, vehicle_typesCreateArgs>
    ): Prisma__vehicle_typesClient<vehicle_typesGetPayload<T>>

    /**
     * Create many Vehicle_types.
     *     @param {vehicle_typesCreateManyArgs} args - Arguments to create many Vehicle_types.
     *     @example
     *     // Create many Vehicle_types
     *     const vehicle_types = await prisma.vehicle_types.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vehicle_typesCreateManyArgs>(
      args?: SelectSubset<T, vehicle_typesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle_types.
     * @param {vehicle_typesDeleteArgs} args - Arguments to delete one Vehicle_types.
     * @example
     * // Delete one Vehicle_types
     * const Vehicle_types = await prisma.vehicle_types.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_types
     *   }
     * })
     * 
    **/
    delete<T extends vehicle_typesDeleteArgs>(
      args: SelectSubset<T, vehicle_typesDeleteArgs>
    ): Prisma__vehicle_typesClient<vehicle_typesGetPayload<T>>

    /**
     * Update one Vehicle_types.
     * @param {vehicle_typesUpdateArgs} args - Arguments to update one Vehicle_types.
     * @example
     * // Update one Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vehicle_typesUpdateArgs>(
      args: SelectSubset<T, vehicle_typesUpdateArgs>
    ): Prisma__vehicle_typesClient<vehicle_typesGetPayload<T>>

    /**
     * Delete zero or more Vehicle_types.
     * @param {vehicle_typesDeleteManyArgs} args - Arguments to filter Vehicle_types to delete.
     * @example
     * // Delete a few Vehicle_types
     * const { count } = await prisma.vehicle_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vehicle_typesDeleteManyArgs>(
      args?: SelectSubset<T, vehicle_typesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vehicle_typesUpdateManyArgs>(
      args: SelectSubset<T, vehicle_typesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle_types.
     * @param {vehicle_typesUpsertArgs} args - Arguments to update or create a Vehicle_types.
     * @example
     * // Update or create a Vehicle_types
     * const vehicle_types = await prisma.vehicle_types.upsert({
     *   create: {
     *     // ... data to create a Vehicle_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_types we want to update
     *   }
     * })
    **/
    upsert<T extends vehicle_typesUpsertArgs>(
      args: SelectSubset<T, vehicle_typesUpsertArgs>
    ): Prisma__vehicle_typesClient<vehicle_typesGetPayload<T>>

    /**
     * Count the number of Vehicle_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typesCountArgs} args - Arguments to filter Vehicle_types to count.
     * @example
     * // Count the number of Vehicle_types
     * const count = await prisma.vehicle_types.count({
     *   where: {
     *     // ... the filter for the Vehicle_types we want to count
     *   }
     * })
    **/
    count<T extends vehicle_typesCountArgs>(
      args?: Subset<T, vehicle_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_typesAggregateArgs>(args: Subset<T, Vehicle_typesAggregateArgs>): Prisma.PrismaPromise<GetVehicle_typesAggregateType<T>>

    /**
     * Group by Vehicle_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Vehicle_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Vehicle_typesGroupByArgs['orderBy'] }
        : { orderBy?: Vehicle_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Vehicle_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__vehicle_typesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    cars<T extends vehicle_types$carsArgs= {}>(args?: Subset<T, vehicle_types$carsArgs>): Prisma.PrismaPromise<Array<carsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * vehicle_types base type for findUnique actions
   */
  export type vehicle_typesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vehicle_typesInclude | null
    /**
     * Filter, which vehicle_types to fetch.
     */
    where: vehicle_typesWhereUniqueInput
  }

  /**
   * vehicle_types findUnique
   */
  export interface vehicle_typesFindUniqueArgs extends vehicle_typesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vehicle_types findUniqueOrThrow
   */
  export type vehicle_typesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vehicle_typesInclude | null
    /**
     * Filter, which vehicle_types to fetch.
     */
    where: vehicle_typesWhereUniqueInput
  }


  /**
   * vehicle_types base type for findFirst actions
   */
  export type vehicle_typesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vehicle_typesInclude | null
    /**
     * Filter, which vehicle_types to fetch.
     */
    where?: vehicle_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_types to fetch.
     */
    orderBy?: Enumerable<vehicle_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_types.
     */
    cursor?: vehicle_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_types.
     */
    distinct?: Enumerable<Vehicle_typesScalarFieldEnum>
  }

  /**
   * vehicle_types findFirst
   */
  export interface vehicle_typesFindFirstArgs extends vehicle_typesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vehicle_types findFirstOrThrow
   */
  export type vehicle_typesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vehicle_typesInclude | null
    /**
     * Filter, which vehicle_types to fetch.
     */
    where?: vehicle_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_types to fetch.
     */
    orderBy?: Enumerable<vehicle_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_types.
     */
    cursor?: vehicle_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_types.
     */
    distinct?: Enumerable<Vehicle_typesScalarFieldEnum>
  }


  /**
   * vehicle_types findMany
   */
  export type vehicle_typesFindManyArgs = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vehicle_typesInclude | null
    /**
     * Filter, which vehicle_types to fetch.
     */
    where?: vehicle_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_types to fetch.
     */
    orderBy?: Enumerable<vehicle_typesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_types.
     */
    cursor?: vehicle_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_types.
     */
    skip?: number
    distinct?: Enumerable<Vehicle_typesScalarFieldEnum>
  }


  /**
   * vehicle_types create
   */
  export type vehicle_typesCreateArgs = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vehicle_typesInclude | null
    /**
     * The data needed to create a vehicle_types.
     */
    data: XOR<vehicle_typesCreateInput, vehicle_typesUncheckedCreateInput>
  }


  /**
   * vehicle_types createMany
   */
  export type vehicle_typesCreateManyArgs = {
    /**
     * The data used to create many vehicle_types.
     */
    data: Enumerable<vehicle_typesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * vehicle_types update
   */
  export type vehicle_typesUpdateArgs = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vehicle_typesInclude | null
    /**
     * The data needed to update a vehicle_types.
     */
    data: XOR<vehicle_typesUpdateInput, vehicle_typesUncheckedUpdateInput>
    /**
     * Choose, which vehicle_types to update.
     */
    where: vehicle_typesWhereUniqueInput
  }


  /**
   * vehicle_types updateMany
   */
  export type vehicle_typesUpdateManyArgs = {
    /**
     * The data used to update vehicle_types.
     */
    data: XOR<vehicle_typesUpdateManyMutationInput, vehicle_typesUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_types to update
     */
    where?: vehicle_typesWhereInput
  }


  /**
   * vehicle_types upsert
   */
  export type vehicle_typesUpsertArgs = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vehicle_typesInclude | null
    /**
     * The filter to search for the vehicle_types to update in case it exists.
     */
    where: vehicle_typesWhereUniqueInput
    /**
     * In case the vehicle_types found by the `where` argument doesn't exist, create a new vehicle_types with this data.
     */
    create: XOR<vehicle_typesCreateInput, vehicle_typesUncheckedCreateInput>
    /**
     * In case the vehicle_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_typesUpdateInput, vehicle_typesUncheckedUpdateInput>
  }


  /**
   * vehicle_types delete
   */
  export type vehicle_typesDeleteArgs = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vehicle_typesInclude | null
    /**
     * Filter which vehicle_types to delete.
     */
    where: vehicle_typesWhereUniqueInput
  }


  /**
   * vehicle_types deleteMany
   */
  export type vehicle_typesDeleteManyArgs = {
    /**
     * Filter which vehicle_types to delete
     */
    where?: vehicle_typesWhereInput
  }


  /**
   * vehicle_types.cars
   */
  export type vehicle_types$carsArgs = {
    /**
     * Select specific fields to fetch from the cars
     */
    select?: carsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: carsInclude | null
    where?: carsWhereInput
    orderBy?: Enumerable<carsOrderByWithRelationInput>
    cursor?: carsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CarsScalarFieldEnum>
  }


  /**
   * vehicle_types without action
   */
  export type vehicle_typesArgs = {
    /**
     * Select specific fields to fetch from the vehicle_types
     */
    select?: vehicle_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vehicle_typesInclude | null
  }



  /**
   * Model sub_services
   */


  export type AggregateSub_services = {
    _count: Sub_servicesCountAggregateOutputType | null
    _avg: Sub_servicesAvgAggregateOutputType | null
    _sum: Sub_servicesSumAggregateOutputType | null
    _min: Sub_servicesMinAggregateOutputType | null
    _max: Sub_servicesMaxAggregateOutputType | null
  }

  export type Sub_servicesAvgAggregateOutputType = {
    id: number | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    price_per_passenger: number | null
    car_id: number | null
    service_id: number | null
    luggage: number | null
    passenger_capacity: number | null
  }

  export type Sub_servicesSumAggregateOutputType = {
    id: number | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    price_per_passenger: number | null
    car_id: number | null
    service_id: number | null
    luggage: number | null
    passenger_capacity: number | null
  }

  export type Sub_servicesMinAggregateOutputType = {
    id: number | null
    name: string | null
    pickup_location: string | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_location: string | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    price_per_passenger: number | null
    status: Buffer | null
    created_at: Date | null
    updated_at: Date | null
    isActive: boolean | null
    car_id: number | null
    service_id: number | null
    description: string | null
    luggage: number | null
    passenger_capacity: number | null
  }

  export type Sub_servicesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    pickup_location: string | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_location: string | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    price_per_passenger: number | null
    status: Buffer | null
    created_at: Date | null
    updated_at: Date | null
    isActive: boolean | null
    car_id: number | null
    service_id: number | null
    description: string | null
    luggage: number | null
    passenger_capacity: number | null
  }

  export type Sub_servicesCountAggregateOutputType = {
    id: number
    name: number
    pickup_location: number
    pickup_lat: number
    pickup_lng: number
    dropoff_location: number
    dropoff_lat: number
    dropoff_lng: number
    price_per_passenger: number
    status: number
    created_at: number
    updated_at: number
    isActive: number
    car_id: number
    service_id: number
    description: number
    luggage: number
    passenger_capacity: number
    _all: number
  }


  export type Sub_servicesAvgAggregateInputType = {
    id?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_lat?: true
    dropoff_lng?: true
    price_per_passenger?: true
    car_id?: true
    service_id?: true
    luggage?: true
    passenger_capacity?: true
  }

  export type Sub_servicesSumAggregateInputType = {
    id?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_lat?: true
    dropoff_lng?: true
    price_per_passenger?: true
    car_id?: true
    service_id?: true
    luggage?: true
    passenger_capacity?: true
  }

  export type Sub_servicesMinAggregateInputType = {
    id?: true
    name?: true
    pickup_location?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_location?: true
    dropoff_lat?: true
    dropoff_lng?: true
    price_per_passenger?: true
    status?: true
    created_at?: true
    updated_at?: true
    isActive?: true
    car_id?: true
    service_id?: true
    description?: true
    luggage?: true
    passenger_capacity?: true
  }

  export type Sub_servicesMaxAggregateInputType = {
    id?: true
    name?: true
    pickup_location?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_location?: true
    dropoff_lat?: true
    dropoff_lng?: true
    price_per_passenger?: true
    status?: true
    created_at?: true
    updated_at?: true
    isActive?: true
    car_id?: true
    service_id?: true
    description?: true
    luggage?: true
    passenger_capacity?: true
  }

  export type Sub_servicesCountAggregateInputType = {
    id?: true
    name?: true
    pickup_location?: true
    pickup_lat?: true
    pickup_lng?: true
    dropoff_location?: true
    dropoff_lat?: true
    dropoff_lng?: true
    price_per_passenger?: true
    status?: true
    created_at?: true
    updated_at?: true
    isActive?: true
    car_id?: true
    service_id?: true
    description?: true
    luggage?: true
    passenger_capacity?: true
    _all?: true
  }

  export type Sub_servicesAggregateArgs = {
    /**
     * Filter which sub_services to aggregate.
     */
    where?: sub_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_services to fetch.
     */
    orderBy?: Enumerable<sub_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sub_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sub_services
    **/
    _count?: true | Sub_servicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sub_servicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sub_servicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sub_servicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sub_servicesMaxAggregateInputType
  }

  export type GetSub_servicesAggregateType<T extends Sub_servicesAggregateArgs> = {
        [P in keyof T & keyof AggregateSub_services]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSub_services[P]>
      : GetScalarType<T[P], AggregateSub_services[P]>
  }




  export type Sub_servicesGroupByArgs = {
    where?: sub_servicesWhereInput
    orderBy?: Enumerable<sub_servicesOrderByWithAggregationInput>
    by: Sub_servicesScalarFieldEnum[]
    having?: sub_servicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sub_servicesCountAggregateInputType | true
    _avg?: Sub_servicesAvgAggregateInputType
    _sum?: Sub_servicesSumAggregateInputType
    _min?: Sub_servicesMinAggregateInputType
    _max?: Sub_servicesMaxAggregateInputType
  }


  export type Sub_servicesGroupByOutputType = {
    id: number
    name: string | null
    pickup_location: string | null
    pickup_lat: number | null
    pickup_lng: number | null
    dropoff_location: string | null
    dropoff_lat: number | null
    dropoff_lng: number | null
    price_per_passenger: number | null
    status: Buffer | null
    created_at: Date | null
    updated_at: Date | null
    isActive: boolean | null
    car_id: number | null
    service_id: number
    description: string | null
    luggage: number | null
    passenger_capacity: number | null
    _count: Sub_servicesCountAggregateOutputType | null
    _avg: Sub_servicesAvgAggregateOutputType | null
    _sum: Sub_servicesSumAggregateOutputType | null
    _min: Sub_servicesMinAggregateOutputType | null
    _max: Sub_servicesMaxAggregateOutputType | null
  }

  type GetSub_servicesGroupByPayload<T extends Sub_servicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Sub_servicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sub_servicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sub_servicesGroupByOutputType[P]>
            : GetScalarType<T[P], Sub_servicesGroupByOutputType[P]>
        }
      >
    >


  export type sub_servicesSelect = {
    id?: boolean
    name?: boolean
    pickup_location?: boolean
    pickup_lat?: boolean
    pickup_lng?: boolean
    dropoff_location?: boolean
    dropoff_lat?: boolean
    dropoff_lng?: boolean
    price_per_passenger?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    isActive?: boolean
    car_id?: boolean
    service_id?: boolean
    description?: boolean
    luggage?: boolean
    passenger_capacity?: boolean
    reservations?: boolean | sub_services$reservationsArgs
    services?: boolean | servicesArgs
    cars?: boolean | carsArgs
    timeslots?: boolean | sub_services$timeslotsArgs
    _count?: boolean | Sub_servicesCountOutputTypeArgs
  }


  export type sub_servicesInclude = {
    reservations?: boolean | sub_services$reservationsArgs
    services?: boolean | servicesArgs
    cars?: boolean | carsArgs
    timeslots?: boolean | sub_services$timeslotsArgs
    _count?: boolean | Sub_servicesCountOutputTypeArgs
  }

  export type sub_servicesGetPayload<S extends boolean | null | undefined | sub_servicesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? sub_services :
    S extends undefined ? never :
    S extends { include: any } & (sub_servicesArgs | sub_servicesFindManyArgs)
    ? sub_services  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'reservations' ? Array < reservationsGetPayload<S['include'][P]>>  :
        P extends 'services' ? servicesGetPayload<S['include'][P]> :
        P extends 'cars' ? carsGetPayload<S['include'][P]> | null :
        P extends 'timeslots' ? Array < timeslotsGetPayload<S['include'][P]>>  :
        P extends '_count' ? Sub_servicesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (sub_servicesArgs | sub_servicesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'reservations' ? Array < reservationsGetPayload<S['select'][P]>>  :
        P extends 'services' ? servicesGetPayload<S['select'][P]> :
        P extends 'cars' ? carsGetPayload<S['select'][P]> | null :
        P extends 'timeslots' ? Array < timeslotsGetPayload<S['select'][P]>>  :
        P extends '_count' ? Sub_servicesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof sub_services ? sub_services[P] : never
  } 
      : sub_services


  type sub_servicesCountArgs = 
    Omit<sub_servicesFindManyArgs, 'select' | 'include'> & {
      select?: Sub_servicesCountAggregateInputType | true
    }

  export interface sub_servicesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Sub_services that matches the filter.
     * @param {sub_servicesFindUniqueArgs} args - Arguments to find a Sub_services
     * @example
     * // Get one Sub_services
     * const sub_services = await prisma.sub_services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sub_servicesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sub_servicesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sub_services'> extends True ? Prisma__sub_servicesClient<sub_servicesGetPayload<T>> : Prisma__sub_servicesClient<sub_servicesGetPayload<T> | null, null>

    /**
     * Find one Sub_services that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sub_servicesFindUniqueOrThrowArgs} args - Arguments to find a Sub_services
     * @example
     * // Get one Sub_services
     * const sub_services = await prisma.sub_services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sub_servicesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, sub_servicesFindUniqueOrThrowArgs>
    ): Prisma__sub_servicesClient<sub_servicesGetPayload<T>>

    /**
     * Find the first Sub_services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_servicesFindFirstArgs} args - Arguments to find a Sub_services
     * @example
     * // Get one Sub_services
     * const sub_services = await prisma.sub_services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sub_servicesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sub_servicesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sub_services'> extends True ? Prisma__sub_servicesClient<sub_servicesGetPayload<T>> : Prisma__sub_servicesClient<sub_servicesGetPayload<T> | null, null>

    /**
     * Find the first Sub_services that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_servicesFindFirstOrThrowArgs} args - Arguments to find a Sub_services
     * @example
     * // Get one Sub_services
     * const sub_services = await prisma.sub_services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sub_servicesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, sub_servicesFindFirstOrThrowArgs>
    ): Prisma__sub_servicesClient<sub_servicesGetPayload<T>>

    /**
     * Find zero or more Sub_services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_servicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sub_services
     * const sub_services = await prisma.sub_services.findMany()
     * 
     * // Get first 10 Sub_services
     * const sub_services = await prisma.sub_services.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sub_servicesWithIdOnly = await prisma.sub_services.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sub_servicesFindManyArgs>(
      args?: SelectSubset<T, sub_servicesFindManyArgs>
    ): Prisma.PrismaPromise<Array<sub_servicesGetPayload<T>>>

    /**
     * Create a Sub_services.
     * @param {sub_servicesCreateArgs} args - Arguments to create a Sub_services.
     * @example
     * // Create one Sub_services
     * const Sub_services = await prisma.sub_services.create({
     *   data: {
     *     // ... data to create a Sub_services
     *   }
     * })
     * 
    **/
    create<T extends sub_servicesCreateArgs>(
      args: SelectSubset<T, sub_servicesCreateArgs>
    ): Prisma__sub_servicesClient<sub_servicesGetPayload<T>>

    /**
     * Create many Sub_services.
     *     @param {sub_servicesCreateManyArgs} args - Arguments to create many Sub_services.
     *     @example
     *     // Create many Sub_services
     *     const sub_services = await prisma.sub_services.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sub_servicesCreateManyArgs>(
      args?: SelectSubset<T, sub_servicesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sub_services.
     * @param {sub_servicesDeleteArgs} args - Arguments to delete one Sub_services.
     * @example
     * // Delete one Sub_services
     * const Sub_services = await prisma.sub_services.delete({
     *   where: {
     *     // ... filter to delete one Sub_services
     *   }
     * })
     * 
    **/
    delete<T extends sub_servicesDeleteArgs>(
      args: SelectSubset<T, sub_servicesDeleteArgs>
    ): Prisma__sub_servicesClient<sub_servicesGetPayload<T>>

    /**
     * Update one Sub_services.
     * @param {sub_servicesUpdateArgs} args - Arguments to update one Sub_services.
     * @example
     * // Update one Sub_services
     * const sub_services = await prisma.sub_services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sub_servicesUpdateArgs>(
      args: SelectSubset<T, sub_servicesUpdateArgs>
    ): Prisma__sub_servicesClient<sub_servicesGetPayload<T>>

    /**
     * Delete zero or more Sub_services.
     * @param {sub_servicesDeleteManyArgs} args - Arguments to filter Sub_services to delete.
     * @example
     * // Delete a few Sub_services
     * const { count } = await prisma.sub_services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sub_servicesDeleteManyArgs>(
      args?: SelectSubset<T, sub_servicesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sub_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_servicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sub_services
     * const sub_services = await prisma.sub_services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sub_servicesUpdateManyArgs>(
      args: SelectSubset<T, sub_servicesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sub_services.
     * @param {sub_servicesUpsertArgs} args - Arguments to update or create a Sub_services.
     * @example
     * // Update or create a Sub_services
     * const sub_services = await prisma.sub_services.upsert({
     *   create: {
     *     // ... data to create a Sub_services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sub_services we want to update
     *   }
     * })
    **/
    upsert<T extends sub_servicesUpsertArgs>(
      args: SelectSubset<T, sub_servicesUpsertArgs>
    ): Prisma__sub_servicesClient<sub_servicesGetPayload<T>>

    /**
     * Count the number of Sub_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_servicesCountArgs} args - Arguments to filter Sub_services to count.
     * @example
     * // Count the number of Sub_services
     * const count = await prisma.sub_services.count({
     *   where: {
     *     // ... the filter for the Sub_services we want to count
     *   }
     * })
    **/
    count<T extends sub_servicesCountArgs>(
      args?: Subset<T, sub_servicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sub_servicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sub_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sub_servicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sub_servicesAggregateArgs>(args: Subset<T, Sub_servicesAggregateArgs>): Prisma.PrismaPromise<GetSub_servicesAggregateType<T>>

    /**
     * Group by Sub_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sub_servicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Sub_servicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Sub_servicesGroupByArgs['orderBy'] }
        : { orderBy?: Sub_servicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Sub_servicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSub_servicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for sub_services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sub_servicesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    reservations<T extends sub_services$reservationsArgs= {}>(args?: Subset<T, sub_services$reservationsArgs>): Prisma.PrismaPromise<Array<reservationsGetPayload<T>>| Null>;

    services<T extends servicesArgs= {}>(args?: Subset<T, servicesArgs>): Prisma__servicesClient<servicesGetPayload<T> | Null>;

    cars<T extends carsArgs= {}>(args?: Subset<T, carsArgs>): Prisma__carsClient<carsGetPayload<T> | Null>;

    timeslots<T extends sub_services$timeslotsArgs= {}>(args?: Subset<T, sub_services$timeslotsArgs>): Prisma.PrismaPromise<Array<timeslotsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * sub_services base type for findUnique actions
   */
  export type sub_servicesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the sub_services
     */
    select?: sub_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_servicesInclude | null
    /**
     * Filter, which sub_services to fetch.
     */
    where: sub_servicesWhereUniqueInput
  }

  /**
   * sub_services findUnique
   */
  export interface sub_servicesFindUniqueArgs extends sub_servicesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sub_services findUniqueOrThrow
   */
  export type sub_servicesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the sub_services
     */
    select?: sub_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_servicesInclude | null
    /**
     * Filter, which sub_services to fetch.
     */
    where: sub_servicesWhereUniqueInput
  }


  /**
   * sub_services base type for findFirst actions
   */
  export type sub_servicesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the sub_services
     */
    select?: sub_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_servicesInclude | null
    /**
     * Filter, which sub_services to fetch.
     */
    where?: sub_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_services to fetch.
     */
    orderBy?: Enumerable<sub_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sub_services.
     */
    cursor?: sub_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sub_services.
     */
    distinct?: Enumerable<Sub_servicesScalarFieldEnum>
  }

  /**
   * sub_services findFirst
   */
  export interface sub_servicesFindFirstArgs extends sub_servicesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sub_services findFirstOrThrow
   */
  export type sub_servicesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the sub_services
     */
    select?: sub_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_servicesInclude | null
    /**
     * Filter, which sub_services to fetch.
     */
    where?: sub_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_services to fetch.
     */
    orderBy?: Enumerable<sub_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sub_services.
     */
    cursor?: sub_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sub_services.
     */
    distinct?: Enumerable<Sub_servicesScalarFieldEnum>
  }


  /**
   * sub_services findMany
   */
  export type sub_servicesFindManyArgs = {
    /**
     * Select specific fields to fetch from the sub_services
     */
    select?: sub_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_servicesInclude | null
    /**
     * Filter, which sub_services to fetch.
     */
    where?: sub_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_services to fetch.
     */
    orderBy?: Enumerable<sub_servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sub_services.
     */
    cursor?: sub_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_services.
     */
    skip?: number
    distinct?: Enumerable<Sub_servicesScalarFieldEnum>
  }


  /**
   * sub_services create
   */
  export type sub_servicesCreateArgs = {
    /**
     * Select specific fields to fetch from the sub_services
     */
    select?: sub_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_servicesInclude | null
    /**
     * The data needed to create a sub_services.
     */
    data: XOR<sub_servicesCreateInput, sub_servicesUncheckedCreateInput>
  }


  /**
   * sub_services createMany
   */
  export type sub_servicesCreateManyArgs = {
    /**
     * The data used to create many sub_services.
     */
    data: Enumerable<sub_servicesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * sub_services update
   */
  export type sub_servicesUpdateArgs = {
    /**
     * Select specific fields to fetch from the sub_services
     */
    select?: sub_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_servicesInclude | null
    /**
     * The data needed to update a sub_services.
     */
    data: XOR<sub_servicesUpdateInput, sub_servicesUncheckedUpdateInput>
    /**
     * Choose, which sub_services to update.
     */
    where: sub_servicesWhereUniqueInput
  }


  /**
   * sub_services updateMany
   */
  export type sub_servicesUpdateManyArgs = {
    /**
     * The data used to update sub_services.
     */
    data: XOR<sub_servicesUpdateManyMutationInput, sub_servicesUncheckedUpdateManyInput>
    /**
     * Filter which sub_services to update
     */
    where?: sub_servicesWhereInput
  }


  /**
   * sub_services upsert
   */
  export type sub_servicesUpsertArgs = {
    /**
     * Select specific fields to fetch from the sub_services
     */
    select?: sub_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_servicesInclude | null
    /**
     * The filter to search for the sub_services to update in case it exists.
     */
    where: sub_servicesWhereUniqueInput
    /**
     * In case the sub_services found by the `where` argument doesn't exist, create a new sub_services with this data.
     */
    create: XOR<sub_servicesCreateInput, sub_servicesUncheckedCreateInput>
    /**
     * In case the sub_services was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sub_servicesUpdateInput, sub_servicesUncheckedUpdateInput>
  }


  /**
   * sub_services delete
   */
  export type sub_servicesDeleteArgs = {
    /**
     * Select specific fields to fetch from the sub_services
     */
    select?: sub_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_servicesInclude | null
    /**
     * Filter which sub_services to delete.
     */
    where: sub_servicesWhereUniqueInput
  }


  /**
   * sub_services deleteMany
   */
  export type sub_servicesDeleteManyArgs = {
    /**
     * Filter which sub_services to delete
     */
    where?: sub_servicesWhereInput
  }


  /**
   * sub_services.reservations
   */
  export type sub_services$reservationsArgs = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reservationsInclude | null
    where?: reservationsWhereInput
    orderBy?: Enumerable<reservationsOrderByWithRelationInput>
    cursor?: reservationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReservationsScalarFieldEnum>
  }


  /**
   * sub_services.timeslots
   */
  export type sub_services$timeslotsArgs = {
    /**
     * Select specific fields to fetch from the timeslots
     */
    select?: timeslotsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: timeslotsInclude | null
    where?: timeslotsWhereInput
    orderBy?: Enumerable<timeslotsOrderByWithRelationInput>
    cursor?: timeslotsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TimeslotsScalarFieldEnum>
  }


  /**
   * sub_services without action
   */
  export type sub_servicesArgs = {
    /**
     * Select specific fields to fetch from the sub_services
     */
    select?: sub_servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sub_servicesInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ActivationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    code: 'code',
    completed: 'completed',
    completed_at: 'completed_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ActivationsScalarFieldEnum = (typeof ActivationsScalarFieldEnum)[keyof typeof ActivationsScalarFieldEnum]


  export const Activity_logScalarFieldEnum: {
    id: 'id',
    log_name: 'log_name',
    description: 'description',
    subject_id: 'subject_id',
    subject_type: 'subject_type',
    causer_id: 'causer_id',
    causer_type: 'causer_type',
    properties: 'properties',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Activity_logScalarFieldEnum = (typeof Activity_logScalarFieldEnum)[keyof typeof Activity_logScalarFieldEnum]


  export const AirlinesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    alias: 'alias',
    iata: 'iata',
    icao: 'icao',
    callsign: 'callsign',
    country: 'country',
    active: 'active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AirlinesScalarFieldEnum = (typeof AirlinesScalarFieldEnum)[keyof typeof AirlinesScalarFieldEnum]


  export const Airport_servicesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    pickup_dropoff: 'pickup_dropoff',
    pickup_date_time: 'pickup_date_time',
    num_passengers: 'num_passengers',
    pickup_from: 'pickup_from',
    dropoff_location: 'dropoff_location',
    airline: 'airline',
    flight_number: 'flight_number',
    status: 'status',
    pick_up_lat: 'pick_up_lat',
    drop_off_lat: 'drop_off_lat',
    pick_up_lon: 'pick_up_lon',
    drop_off_lon: 'drop_off_lon',
    service_id: 'service_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Airport_servicesScalarFieldEnum = (typeof Airport_servicesScalarFieldEnum)[keyof typeof Airport_servicesScalarFieldEnum]


  export const AirportsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    city: 'city',
    country: 'country',
    iata: 'iata',
    icao: 'icao',
    latitude: 'latitude',
    longitude: 'longitude',
    altitude: 'altitude',
    timezone: 'timezone',
    dst: 'dst',
    tz_database_time_zone: 'tz_database_time_zone',
    Type: 'Type',
    Source: 'Source',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AirportsScalarFieldEnum = (typeof AirportsScalarFieldEnum)[keyof typeof AirportsScalarFieldEnum]


  export const Blog_categoriesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Blog_categoriesScalarFieldEnum = (typeof Blog_categoriesScalarFieldEnum)[keyof typeof Blog_categoriesScalarFieldEnum]


  export const Blog_commentsScalarFieldEnum: {
    id: 'id',
    blog_id: 'blog_id',
    name: 'name',
    email: 'email',
    website: 'website',
    comment: 'comment',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Blog_commentsScalarFieldEnum = (typeof Blog_commentsScalarFieldEnum)[keyof typeof Blog_commentsScalarFieldEnum]


  export const BlogsScalarFieldEnum: {
    id: 'id',
    blog_category_id: 'blog_category_id',
    user_id: 'user_id',
    title: 'title',
    slug: 'slug',
    content: 'content',
    image: 'image',
    views: 'views',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type BlogsScalarFieldEnum = (typeof BlogsScalarFieldEnum)[keyof typeof BlogsScalarFieldEnum]


  export const Body_typesScalarFieldEnum: {
    id: 'id',
    body_type: 'body_type',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Body_typesScalarFieldEnum = (typeof Body_typesScalarFieldEnum)[keyof typeof Body_typesScalarFieldEnum]


  export const Car_featuresScalarFieldEnum: {
    id: 'id',
    car_id: 'car_id',
    feature_id: 'feature_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Car_featuresScalarFieldEnum = (typeof Car_featuresScalarFieldEnum)[keyof typeof Car_featuresScalarFieldEnum]


  export const Car_price_typesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Car_price_typesScalarFieldEnum = (typeof Car_price_typesScalarFieldEnum)[keyof typeof Car_price_typesScalarFieldEnum]


  export const Car_pricesScalarFieldEnum: {
    id: 'id',
    car_id: 'car_id',
    car_price_type_id: 'car_price_type_id',
    monday: 'monday',
    tuesday: 'tuesday',
    wednesday: 'wednesday',
    thursday: 'thursday',
    friday: 'friday',
    saturday: 'saturday',
    sunday: 'sunday',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Car_pricesScalarFieldEnum = (typeof Car_pricesScalarFieldEnum)[keyof typeof Car_pricesScalarFieldEnum]


  export const CarsScalarFieldEnum: {
    id: 'id',
    body_type_id: 'body_type_id',
    transmission_id: 'transmission_id',
    manufacturer_id: 'manufacturer_id',
    driver_id: 'driver_id',
    fuel_id: 'fuel_id',
    vehicle_type_id: 'vehicle_type_id',
    car_model: 'car_model',
    name: 'name',
    qty: 'qty',
    passenger_seats: 'passenger_seats',
    maximum_luggage: 'maximum_luggage',
    total_doors: 'total_doors',
    child_seat: 'child_seat',
    image: 'image',
    status: 'status',
    per_mile_rate: 'per_mile_rate',
    hourly_rate: 'hourly_rate',
    minimum_fare: 'minimum_fare',
    minimum_hours: 'minimum_hours',
    fixed_price: 'fixed_price',
    is_slab_enabled: 'is_slab_enabled',
    is_loc_enabled: 'is_loc_enabled',
    created_at: 'created_at',
    updated_at: 'updated_at',
    isActive: 'isActive',
    car_type: 'car_type'
  };

  export type CarsScalarFieldEnum = (typeof CarsScalarFieldEnum)[keyof typeof CarsScalarFieldEnum]


  export const City_toursScalarFieldEnum: {
    id: 'id',
    city_name: 'city_name',
    pick_up_location: 'pick_up_location',
    Created_on: 'Created_on'
  };

  export type City_toursScalarFieldEnum = (typeof City_toursScalarFieldEnum)[keyof typeof City_toursScalarFieldEnum]


  export const CountriesScalarFieldEnum: {
    id: 'id',
    sortname: 'sortname',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CountriesScalarFieldEnum = (typeof CountriesScalarFieldEnum)[keyof typeof CountriesScalarFieldEnum]


  export const CouponsScalarFieldEnum: {
    id: 'id',
    coupon_name: 'coupon_name',
    percentage: 'percentage',
    price: 'price',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CouponsScalarFieldEnum = (typeof CouponsScalarFieldEnum)[keyof typeof CouponsScalarFieldEnum]


  export const DatatablesScalarFieldEnum: {
    id: 'id',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    points: 'points',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at',
    age: 'age',
    job: 'job',
    gender: 'gender',
    country: 'country',
    sale_date: 'sale_date'
  };

  export type DatatablesScalarFieldEnum = (typeof DatatablesScalarFieldEnum)[keyof typeof DatatablesScalarFieldEnum]


  export const DriversScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DriversScalarFieldEnum = (typeof DriversScalarFieldEnum)[keyof typeof DriversScalarFieldEnum]


  export const FeaturesScalarFieldEnum: {
    id: 'id',
    feature: 'feature',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type FeaturesScalarFieldEnum = (typeof FeaturesScalarFieldEnum)[keyof typeof FeaturesScalarFieldEnum]


  export const FilesScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    mime: 'mime',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type FilesScalarFieldEnum = (typeof FilesScalarFieldEnum)[keyof typeof FilesScalarFieldEnum]


  export const Fuel_typesScalarFieldEnum: {
    id: 'id',
    fuel_type: 'fuel_type',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Fuel_typesScalarFieldEnum = (typeof Fuel_typesScalarFieldEnum)[keyof typeof Fuel_typesScalarFieldEnum]


  export const GratuitiesScalarFieldEnum: {
    id: 'id',
    percentage: 'percentage',
    status: 'status',
    name: 'name',
    price: 'price',
    service_id: 'service_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type GratuitiesScalarFieldEnum = (typeof GratuitiesScalarFieldEnum)[keyof typeof GratuitiesScalarFieldEnum]


  export const Hourly_servicesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    pickup_location: 'pickup_location',
    pickup_date_time: 'pickup_date_time',
    num_passengers: 'num_passengers',
    num_service_hours: 'num_service_hours',
    dropoff_location: 'dropoff_location',
    add_another_stop: 'add_another_stop',
    additional_comments: 'additional_comments',
    status: 'status',
    service_id: 'service_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Hourly_servicesScalarFieldEnum = (typeof Hourly_servicesScalarFieldEnum)[keyof typeof Hourly_servicesScalarFieldEnum]


  export const Location_exceptionsScalarFieldEnum: {
    id: 'id',
    pick_up_loc_name: 'pick_up_loc_name',
    pick_up_postal_code: 'pick_up_postal_code',
    drop_off_loc_name: 'drop_off_loc_name',
    drop_off_postal_code: 'drop_off_postal_code',
    price: 'price',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Location_exceptionsScalarFieldEnum = (typeof Location_exceptionsScalarFieldEnum)[keyof typeof Location_exceptionsScalarFieldEnum]


  export const LocationsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    pickup_location: 'pickup_location',
    pickup_lat: 'pickup_lat',
    pickup_lng: 'pickup_lng',
    dropoff_location: 'dropoff_location',
    dropoff_lat: 'dropoff_lat',
    dropoff_lng: 'dropoff_lng',
    fee: 'fee',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type LocationsScalarFieldEnum = (typeof LocationsScalarFieldEnum)[keyof typeof LocationsScalarFieldEnum]


  export const ManufacturersScalarFieldEnum: {
    id: 'id',
    Manufacturer: 'Manufacturer',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ManufacturersScalarFieldEnum = (typeof ManufacturersScalarFieldEnum)[keyof typeof ManufacturersScalarFieldEnum]


  export const MigrationsScalarFieldEnum: {
    id: 'id',
    migration: 'migration',
    batch: 'batch'
  };

  export type MigrationsScalarFieldEnum = (typeof MigrationsScalarFieldEnum)[keyof typeof MigrationsScalarFieldEnum]


  export const Package_serivceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    passenger_capacity: 'passenger_capacity',
    price: 'price',
    created_at: 'created_at',
    updated_at: 'updated_at',
    car_id: 'car_id',
    isActive: 'isActive',
    pickup_location: 'pickup_location',
    pickup_lat: 'pickup_lat',
    pickup_lng: 'pickup_lng',
    dropoff_location: 'dropoff_location',
    dropoff_lat: 'dropoff_lat',
    dropoff_lng: 'dropoff_lng',
    luggage: 'luggage'
  };

  export type Package_serivceScalarFieldEnum = (typeof Package_serivceScalarFieldEnum)[keyof typeof Package_serivceScalarFieldEnum]


  export const Package_typesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    password: 'password',
    Created_on: 'Created_on'
  };

  export type Package_typesScalarFieldEnum = (typeof Package_typesScalarFieldEnum)[keyof typeof Package_typesScalarFieldEnum]


  export const PersistencesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    code: 'code',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PersistencesScalarFieldEnum = (typeof PersistencesScalarFieldEnum)[keyof typeof PersistencesScalarFieldEnum]


  export const Point_to_point_servicesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    pickup_location: 'pickup_location',
    pickup_date_time: 'pickup_date_time',
    num_passengers: 'num_passengers',
    dropoff_location: 'dropoff_location',
    add_another_stop: 'add_another_stop',
    additional_comments: 'additional_comments',
    status: 'status',
    pick_up_lat: 'pick_up_lat',
    pick_up_lon: 'pick_up_lon',
    drop_off_lat: 'drop_off_lat',
    drop_off_lon: 'drop_off_lon',
    service_id: 'service_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Point_to_point_servicesScalarFieldEnum = (typeof Point_to_point_servicesScalarFieldEnum)[keyof typeof Point_to_point_servicesScalarFieldEnum]


  export const RemindersScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    code: 'code',
    completed: 'completed',
    completed_at: 'completed_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RemindersScalarFieldEnum = (typeof RemindersScalarFieldEnum)[keyof typeof RemindersScalarFieldEnum]


  export const ReservationsScalarFieldEnum: {
    id: 'id',
    order_number: 'order_number',
    service_id: 'service_id',
    car_id: 'car_id',
    pick_up_postal_code: 'pick_up_postal_code',
    pick_up_lat: 'pick_up_lat',
    pick_up_lon: 'pick_up_lon',
    pick_up_loc_name: 'pick_up_loc_name',
    drop_off_postal_code: 'drop_off_postal_code',
    drop_off_lat: 'drop_off_lat',
    drop_off_lon: 'drop_off_lon',
    drop_off_loc_name: 'drop_off_loc_name',
    pick_up_date: 'pick_up_date',
    price: 'price',
    tax: 'tax',
    airline: 'airline',
    flight_no: 'flight_no',
    no_of_hours: 'no_of_hours',
    maximum_passenger: 'maximum_passenger',
    maximum_luggage: 'maximum_luggage',
    customer_first_name: 'customer_first_name',
    customer_last_name: 'customer_last_name',
    customer_cnic: 'customer_cnic',
    customer_email: 'customer_email',
    customer_phone: 'customer_phone',
    created_at: 'created_at',
    updated_at: 'updated_at',
    uuid: 'uuid',
    payment_method: 'payment_method',
    isPaid: 'isPaid',
    special_instruction: 'special_instruction'
  };

  export type ReservationsScalarFieldEnum = (typeof ReservationsScalarFieldEnum)[keyof typeof ReservationsScalarFieldEnum]


  export const Role_usersScalarFieldEnum: {
    user_id: 'user_id',
    role_id: 'role_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Role_usersScalarFieldEnum = (typeof Role_usersScalarFieldEnum)[keyof typeof Role_usersScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    permissions: 'permissions',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const ServicesScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ServicesScalarFieldEnum = (typeof ServicesScalarFieldEnum)[keyof typeof ServicesScalarFieldEnum]


  export const SlabsScalarFieldEnum: {
    id: 'id',
    car_id: 'car_id',
    initial_distance: 'initial_distance',
    final_distance: 'final_distance',
    price: 'price',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SlabsScalarFieldEnum = (typeof SlabsScalarFieldEnum)[keyof typeof SlabsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const Sub_servicesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    pickup_location: 'pickup_location',
    pickup_lat: 'pickup_lat',
    pickup_lng: 'pickup_lng',
    dropoff_location: 'dropoff_location',
    dropoff_lat: 'dropoff_lat',
    dropoff_lng: 'dropoff_lng',
    price_per_passenger: 'price_per_passenger',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    isActive: 'isActive',
    car_id: 'car_id',
    service_id: 'service_id',
    description: 'description',
    luggage: 'luggage',
    passenger_capacity: 'passenger_capacity'
  };

  export type Sub_servicesScalarFieldEnum = (typeof Sub_servicesScalarFieldEnum)[keyof typeof Sub_servicesScalarFieldEnum]


  export const Sys_settingsScalarFieldEnum: {
    id: 'id',
    sys_name: 'sys_name',
    sys_details: 'sys_details',
    Created_on: 'Created_on',
    setting_key: 'setting_key'
  };

  export type Sys_settingsScalarFieldEnum = (typeof Sys_settingsScalarFieldEnum)[keyof typeof Sys_settingsScalarFieldEnum]


  export const Taggable_tagsScalarFieldEnum: {
    tag_id: 'tag_id',
    name: 'name',
    normalized: 'normalized',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Taggable_tagsScalarFieldEnum = (typeof Taggable_tagsScalarFieldEnum)[keyof typeof Taggable_tagsScalarFieldEnum]


  export const TasksScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    finished: 'finished',
    task_description: 'task_description',
    task_deadline: 'task_deadline',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TasksScalarFieldEnum = (typeof TasksScalarFieldEnum)[keyof typeof TasksScalarFieldEnum]


  export const ThrottleScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    type: 'type',
    ip: 'ip',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ThrottleScalarFieldEnum = (typeof ThrottleScalarFieldEnum)[keyof typeof ThrottleScalarFieldEnum]


  export const TimeslotsScalarFieldEnum: {
    id: 'id',
    time: 'time',
    isActive: 'isActive',
    sub_service_id: 'sub_service_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TimeslotsScalarFieldEnum = (typeof TimeslotsScalarFieldEnum)[keyof typeof TimeslotsScalarFieldEnum]


  export const ToursScalarFieldEnum: {
    id: 'id',
    title: 'title',
    pickup_location: 'pickup_location',
    pickup_lat: 'pickup_lat',
    pickup_lng: 'pickup_lng',
    dropoff_location: 'dropoff_location',
    dropoff_lat: 'dropoff_lat',
    dropoff_lng: 'dropoff_lng',
    price_per_passenger: 'price_per_passenger',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    isActive: 'isActive',
    car_id: 'car_id',
    description: 'description',
    luggage: 'luggage'
  };

  export type ToursScalarFieldEnum = (typeof ToursScalarFieldEnum)[keyof typeof ToursScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TransmissionsScalarFieldEnum: {
    id: 'id',
    transmission: 'transmission',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TransmissionsScalarFieldEnum = (typeof TransmissionsScalarFieldEnum)[keyof typeof TransmissionsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    permissions: 'permissions',
    last_login: 'last_login',
    first_name: 'first_name',
    last_name: 'last_name',
    bio: 'bio',
    gender: 'gender',
    dob: 'dob',
    pic: 'pic',
    country: 'country',
    state: 'state',
    city: 'city',
    address: 'address',
    postal: 'postal',
    status: 'status',
    reset_token: 'reset_token',
    token_expired_at: 'token_expired_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Vehicle_typesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Vehicle_typesScalarFieldEnum = (typeof Vehicle_typesScalarFieldEnum)[keyof typeof Vehicle_typesScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type activationsWhereInput = {
    AND?: Enumerable<activationsWhereInput>
    OR?: Enumerable<activationsWhereInput>
    NOT?: Enumerable<activationsWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    code?: StringFilter | string
    completed?: BoolFilter | boolean
    completed_at?: DateTimeNullableFilter | Date | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type activationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type activationsWhereUniqueInput = {
    id?: number
  }

  export type activationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: activationsCountOrderByAggregateInput
    _avg?: activationsAvgOrderByAggregateInput
    _max?: activationsMaxOrderByAggregateInput
    _min?: activationsMinOrderByAggregateInput
    _sum?: activationsSumOrderByAggregateInput
  }

  export type activationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<activationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<activationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<activationsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    code?: StringWithAggregatesFilter | string
    completed?: BoolWithAggregatesFilter | boolean
    completed_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type activity_logWhereInput = {
    AND?: Enumerable<activity_logWhereInput>
    OR?: Enumerable<activity_logWhereInput>
    NOT?: Enumerable<activity_logWhereInput>
    id?: IntFilter | number
    log_name?: StringNullableFilter | string | null
    description?: StringFilter | string
    subject_id?: IntNullableFilter | number | null
    subject_type?: StringNullableFilter | string | null
    causer_id?: IntNullableFilter | number | null
    causer_type?: StringNullableFilter | string | null
    properties?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type activity_logOrderByWithRelationInput = {
    id?: SortOrder
    log_name?: SortOrder
    description?: SortOrder
    subject_id?: SortOrder
    subject_type?: SortOrder
    causer_id?: SortOrder
    causer_type?: SortOrder
    properties?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type activity_logWhereUniqueInput = {
    id?: number
  }

  export type activity_logOrderByWithAggregationInput = {
    id?: SortOrder
    log_name?: SortOrder
    description?: SortOrder
    subject_id?: SortOrder
    subject_type?: SortOrder
    causer_id?: SortOrder
    causer_type?: SortOrder
    properties?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: activity_logCountOrderByAggregateInput
    _avg?: activity_logAvgOrderByAggregateInput
    _max?: activity_logMaxOrderByAggregateInput
    _min?: activity_logMinOrderByAggregateInput
    _sum?: activity_logSumOrderByAggregateInput
  }

  export type activity_logScalarWhereWithAggregatesInput = {
    AND?: Enumerable<activity_logScalarWhereWithAggregatesInput>
    OR?: Enumerable<activity_logScalarWhereWithAggregatesInput>
    NOT?: Enumerable<activity_logScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    log_name?: StringNullableWithAggregatesFilter | string | null
    description?: StringWithAggregatesFilter | string
    subject_id?: IntNullableWithAggregatesFilter | number | null
    subject_type?: StringNullableWithAggregatesFilter | string | null
    causer_id?: IntNullableWithAggregatesFilter | number | null
    causer_type?: StringNullableWithAggregatesFilter | string | null
    properties?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type airlinesWhereInput = {
    AND?: Enumerable<airlinesWhereInput>
    OR?: Enumerable<airlinesWhereInput>
    NOT?: Enumerable<airlinesWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    alias?: StringNullableFilter | string | null
    iata?: StringNullableFilter | string | null
    icao?: StringNullableFilter | string | null
    callsign?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    active?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type airlinesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    alias?: SortOrder
    iata?: SortOrder
    icao?: SortOrder
    callsign?: SortOrder
    country?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type airlinesWhereUniqueInput = {
    id?: number
  }

  export type airlinesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    alias?: SortOrder
    iata?: SortOrder
    icao?: SortOrder
    callsign?: SortOrder
    country?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: airlinesCountOrderByAggregateInput
    _avg?: airlinesAvgOrderByAggregateInput
    _max?: airlinesMaxOrderByAggregateInput
    _min?: airlinesMinOrderByAggregateInput
    _sum?: airlinesSumOrderByAggregateInput
  }

  export type airlinesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<airlinesScalarWhereWithAggregatesInput>
    OR?: Enumerable<airlinesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<airlinesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    alias?: StringNullableWithAggregatesFilter | string | null
    iata?: StringNullableWithAggregatesFilter | string | null
    icao?: StringNullableWithAggregatesFilter | string | null
    callsign?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    active?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type airport_servicesWhereInput = {
    AND?: Enumerable<airport_servicesWhereInput>
    OR?: Enumerable<airport_servicesWhereInput>
    NOT?: Enumerable<airport_servicesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    pickup_dropoff?: BoolFilter | boolean
    pickup_date_time?: DateTimeFilter | Date | string
    num_passengers?: IntFilter | number
    pickup_from?: StringFilter | string
    dropoff_location?: StringFilter | string
    airline?: StringNullableFilter | string | null
    flight_number?: StringNullableFilter | string | null
    status?: BoolFilter | boolean
    pick_up_lat?: StringFilter | string
    drop_off_lat?: StringFilter | string
    pick_up_lon?: StringFilter | string
    drop_off_lon?: StringFilter | string
    service_id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    services?: XOR<ServicesRelationFilter, servicesWhereInput>
  }

  export type airport_servicesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_dropoff?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    pickup_from?: SortOrder
    dropoff_location?: SortOrder
    airline?: SortOrder
    flight_number?: SortOrder
    status?: SortOrder
    pick_up_lat?: SortOrder
    drop_off_lat?: SortOrder
    pick_up_lon?: SortOrder
    drop_off_lon?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    services?: servicesOrderByWithRelationInput
  }

  export type airport_servicesWhereUniqueInput = {
    id?: number
  }

  export type airport_servicesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_dropoff?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    pickup_from?: SortOrder
    dropoff_location?: SortOrder
    airline?: SortOrder
    flight_number?: SortOrder
    status?: SortOrder
    pick_up_lat?: SortOrder
    drop_off_lat?: SortOrder
    pick_up_lon?: SortOrder
    drop_off_lon?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: airport_servicesCountOrderByAggregateInput
    _avg?: airport_servicesAvgOrderByAggregateInput
    _max?: airport_servicesMaxOrderByAggregateInput
    _min?: airport_servicesMinOrderByAggregateInput
    _sum?: airport_servicesSumOrderByAggregateInput
  }

  export type airport_servicesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<airport_servicesScalarWhereWithAggregatesInput>
    OR?: Enumerable<airport_servicesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<airport_servicesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    pickup_dropoff?: BoolWithAggregatesFilter | boolean
    pickup_date_time?: DateTimeWithAggregatesFilter | Date | string
    num_passengers?: IntWithAggregatesFilter | number
    pickup_from?: StringWithAggregatesFilter | string
    dropoff_location?: StringWithAggregatesFilter | string
    airline?: StringNullableWithAggregatesFilter | string | null
    flight_number?: StringNullableWithAggregatesFilter | string | null
    status?: BoolWithAggregatesFilter | boolean
    pick_up_lat?: StringWithAggregatesFilter | string
    drop_off_lat?: StringWithAggregatesFilter | string
    pick_up_lon?: StringWithAggregatesFilter | string
    drop_off_lon?: StringWithAggregatesFilter | string
    service_id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type airportsWhereInput = {
    AND?: Enumerable<airportsWhereInput>
    OR?: Enumerable<airportsWhereInput>
    NOT?: Enumerable<airportsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    iata?: StringNullableFilter | string | null
    icao?: StringNullableFilter | string | null
    latitude?: StringNullableFilter | string | null
    longitude?: StringNullableFilter | string | null
    altitude?: StringNullableFilter | string | null
    timezone?: StringNullableFilter | string | null
    dst?: StringNullableFilter | string | null
    tz_database_time_zone?: StringNullableFilter | string | null
    Type?: StringNullableFilter | string | null
    Source?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type airportsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    country?: SortOrder
    iata?: SortOrder
    icao?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    altitude?: SortOrder
    timezone?: SortOrder
    dst?: SortOrder
    tz_database_time_zone?: SortOrder
    Type?: SortOrder
    Source?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type airportsWhereUniqueInput = {
    id?: number
  }

  export type airportsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    country?: SortOrder
    iata?: SortOrder
    icao?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    altitude?: SortOrder
    timezone?: SortOrder
    dst?: SortOrder
    tz_database_time_zone?: SortOrder
    Type?: SortOrder
    Source?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: airportsCountOrderByAggregateInput
    _avg?: airportsAvgOrderByAggregateInput
    _max?: airportsMaxOrderByAggregateInput
    _min?: airportsMinOrderByAggregateInput
    _sum?: airportsSumOrderByAggregateInput
  }

  export type airportsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<airportsScalarWhereWithAggregatesInput>
    OR?: Enumerable<airportsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<airportsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    city?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    iata?: StringNullableWithAggregatesFilter | string | null
    icao?: StringNullableWithAggregatesFilter | string | null
    latitude?: StringNullableWithAggregatesFilter | string | null
    longitude?: StringNullableWithAggregatesFilter | string | null
    altitude?: StringNullableWithAggregatesFilter | string | null
    timezone?: StringNullableWithAggregatesFilter | string | null
    dst?: StringNullableWithAggregatesFilter | string | null
    tz_database_time_zone?: StringNullableWithAggregatesFilter | string | null
    Type?: StringNullableWithAggregatesFilter | string | null
    Source?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type blog_categoriesWhereInput = {
    AND?: Enumerable<blog_categoriesWhereInput>
    OR?: Enumerable<blog_categoriesWhereInput>
    NOT?: Enumerable<blog_categoriesWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
  }

  export type blog_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blog_categoriesWhereUniqueInput = {
    id?: number
  }

  export type blog_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: blog_categoriesCountOrderByAggregateInput
    _avg?: blog_categoriesAvgOrderByAggregateInput
    _max?: blog_categoriesMaxOrderByAggregateInput
    _min?: blog_categoriesMinOrderByAggregateInput
    _sum?: blog_categoriesSumOrderByAggregateInput
  }

  export type blog_categoriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<blog_categoriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<blog_categoriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<blog_categoriesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type blog_commentsWhereInput = {
    AND?: Enumerable<blog_commentsWhereInput>
    OR?: Enumerable<blog_commentsWhereInput>
    NOT?: Enumerable<blog_commentsWhereInput>
    id?: IntFilter | number
    blog_id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    website?: StringNullableFilter | string | null
    comment?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
  }

  export type blog_commentsOrderByWithRelationInput = {
    id?: SortOrder
    blog_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    website?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blog_commentsWhereUniqueInput = {
    id?: number
  }

  export type blog_commentsOrderByWithAggregationInput = {
    id?: SortOrder
    blog_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    website?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: blog_commentsCountOrderByAggregateInput
    _avg?: blog_commentsAvgOrderByAggregateInput
    _max?: blog_commentsMaxOrderByAggregateInput
    _min?: blog_commentsMinOrderByAggregateInput
    _sum?: blog_commentsSumOrderByAggregateInput
  }

  export type blog_commentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<blog_commentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<blog_commentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<blog_commentsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    blog_id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    website?: StringNullableWithAggregatesFilter | string | null
    comment?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type blogsWhereInput = {
    AND?: Enumerable<blogsWhereInput>
    OR?: Enumerable<blogsWhereInput>
    NOT?: Enumerable<blogsWhereInput>
    id?: IntFilter | number
    blog_category_id?: IntFilter | number
    user_id?: IntFilter | number
    title?: StringFilter | string
    slug?: StringNullableFilter | string | null
    content?: StringFilter | string
    image?: StringNullableFilter | string | null
    views?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
  }

  export type blogsOrderByWithRelationInput = {
    id?: SortOrder
    blog_category_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    image?: SortOrder
    views?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blogsWhereUniqueInput = {
    id?: number
  }

  export type blogsOrderByWithAggregationInput = {
    id?: SortOrder
    blog_category_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    image?: SortOrder
    views?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: blogsCountOrderByAggregateInput
    _avg?: blogsAvgOrderByAggregateInput
    _max?: blogsMaxOrderByAggregateInput
    _min?: blogsMinOrderByAggregateInput
    _sum?: blogsSumOrderByAggregateInput
  }

  export type blogsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<blogsScalarWhereWithAggregatesInput>
    OR?: Enumerable<blogsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<blogsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    blog_category_id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    slug?: StringNullableWithAggregatesFilter | string | null
    content?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    views?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type body_typesWhereInput = {
    AND?: Enumerable<body_typesWhereInput>
    OR?: Enumerable<body_typesWhereInput>
    NOT?: Enumerable<body_typesWhereInput>
    id?: IntFilter | number
    body_type?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    cars?: CarsListRelationFilter
  }

  export type body_typesOrderByWithRelationInput = {
    id?: SortOrder
    body_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cars?: carsOrderByRelationAggregateInput
  }

  export type body_typesWhereUniqueInput = {
    id?: number
  }

  export type body_typesOrderByWithAggregationInput = {
    id?: SortOrder
    body_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: body_typesCountOrderByAggregateInput
    _avg?: body_typesAvgOrderByAggregateInput
    _max?: body_typesMaxOrderByAggregateInput
    _min?: body_typesMinOrderByAggregateInput
    _sum?: body_typesSumOrderByAggregateInput
  }

  export type body_typesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<body_typesScalarWhereWithAggregatesInput>
    OR?: Enumerable<body_typesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<body_typesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    body_type?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type car_featuresWhereInput = {
    AND?: Enumerable<car_featuresWhereInput>
    OR?: Enumerable<car_featuresWhereInput>
    NOT?: Enumerable<car_featuresWhereInput>
    id?: IntFilter | number
    car_id?: IntFilter | number
    feature_id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type car_featuresOrderByWithRelationInput = {
    id?: SortOrder
    car_id?: SortOrder
    feature_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type car_featuresWhereUniqueInput = {
    id?: number
  }

  export type car_featuresOrderByWithAggregationInput = {
    id?: SortOrder
    car_id?: SortOrder
    feature_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: car_featuresCountOrderByAggregateInput
    _avg?: car_featuresAvgOrderByAggregateInput
    _max?: car_featuresMaxOrderByAggregateInput
    _min?: car_featuresMinOrderByAggregateInput
    _sum?: car_featuresSumOrderByAggregateInput
  }

  export type car_featuresScalarWhereWithAggregatesInput = {
    AND?: Enumerable<car_featuresScalarWhereWithAggregatesInput>
    OR?: Enumerable<car_featuresScalarWhereWithAggregatesInput>
    NOT?: Enumerable<car_featuresScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    car_id?: IntWithAggregatesFilter | number
    feature_id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type car_price_typesWhereInput = {
    AND?: Enumerable<car_price_typesWhereInput>
    OR?: Enumerable<car_price_typesWhereInput>
    NOT?: Enumerable<car_price_typesWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    car_prices?: Car_pricesListRelationFilter
  }

  export type car_price_typesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    car_prices?: car_pricesOrderByRelationAggregateInput
  }

  export type car_price_typesWhereUniqueInput = {
    id?: number
  }

  export type car_price_typesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: car_price_typesCountOrderByAggregateInput
    _avg?: car_price_typesAvgOrderByAggregateInput
    _max?: car_price_typesMaxOrderByAggregateInput
    _min?: car_price_typesMinOrderByAggregateInput
    _sum?: car_price_typesSumOrderByAggregateInput
  }

  export type car_price_typesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<car_price_typesScalarWhereWithAggregatesInput>
    OR?: Enumerable<car_price_typesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<car_price_typesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type car_pricesWhereInput = {
    AND?: Enumerable<car_pricesWhereInput>
    OR?: Enumerable<car_pricesWhereInput>
    NOT?: Enumerable<car_pricesWhereInput>
    id?: IntFilter | number
    car_id?: IntFilter | number
    car_price_type_id?: IntFilter | number
    monday?: IntNullableFilter | number | null
    tuesday?: IntNullableFilter | number | null
    wednesday?: IntNullableFilter | number | null
    thursday?: IntNullableFilter | number | null
    friday?: IntNullableFilter | number | null
    saturday?: IntNullableFilter | number | null
    sunday?: IntNullableFilter | number | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    cars?: XOR<CarsRelationFilter, carsWhereInput>
    car_price_types?: XOR<Car_price_typesRelationFilter, car_price_typesWhereInput>
  }

  export type car_pricesOrderByWithRelationInput = {
    id?: SortOrder
    car_id?: SortOrder
    car_price_type_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cars?: carsOrderByWithRelationInput
    car_price_types?: car_price_typesOrderByWithRelationInput
  }

  export type car_pricesWhereUniqueInput = {
    id?: number
  }

  export type car_pricesOrderByWithAggregationInput = {
    id?: SortOrder
    car_id?: SortOrder
    car_price_type_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: car_pricesCountOrderByAggregateInput
    _avg?: car_pricesAvgOrderByAggregateInput
    _max?: car_pricesMaxOrderByAggregateInput
    _min?: car_pricesMinOrderByAggregateInput
    _sum?: car_pricesSumOrderByAggregateInput
  }

  export type car_pricesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<car_pricesScalarWhereWithAggregatesInput>
    OR?: Enumerable<car_pricesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<car_pricesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    car_id?: IntWithAggregatesFilter | number
    car_price_type_id?: IntWithAggregatesFilter | number
    monday?: IntNullableWithAggregatesFilter | number | null
    tuesday?: IntNullableWithAggregatesFilter | number | null
    wednesday?: IntNullableWithAggregatesFilter | number | null
    thursday?: IntNullableWithAggregatesFilter | number | null
    friday?: IntNullableWithAggregatesFilter | number | null
    saturday?: IntNullableWithAggregatesFilter | number | null
    sunday?: IntNullableWithAggregatesFilter | number | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type carsWhereInput = {
    AND?: Enumerable<carsWhereInput>
    OR?: Enumerable<carsWhereInput>
    NOT?: Enumerable<carsWhereInput>
    id?: IntFilter | number
    body_type_id?: IntFilter | number
    transmission_id?: IntFilter | number
    manufacturer_id?: IntFilter | number
    driver_id?: IntFilter | number
    fuel_id?: IntFilter | number
    vehicle_type_id?: IntFilter | number
    car_model?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    qty?: StringNullableFilter | string | null
    passenger_seats?: IntNullableFilter | number | null
    maximum_luggage?: IntNullableFilter | number | null
    total_doors?: IntNullableFilter | number | null
    child_seat?: IntNullableFilter | number | null
    image?: StringNullableFilter | string | null
    status?: BoolNullableFilter | boolean | null
    per_mile_rate?: FloatNullableFilter | number | null
    hourly_rate?: FloatNullableFilter | number | null
    minimum_fare?: FloatNullableFilter | number | null
    minimum_hours?: IntNullableFilter | number | null
    fixed_price?: FloatNullableFilter | number | null
    is_slab_enabled?: BoolNullableFilter | boolean | null
    is_loc_enabled?: BoolNullableFilter | boolean | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    isActive?: BoolNullableFilter | boolean | null
    car_type?: Enumcars_car_typeNullableFilter | cars_car_type | null
    car_prices?: Car_pricesListRelationFilter
    body_types?: XOR<Body_typesRelationFilter, body_typesWhereInput>
    drivers?: XOR<DriversRelationFilter, driversWhereInput>
    fuel_types?: XOR<Fuel_typesRelationFilter, fuel_typesWhereInput>
    manufacturers?: XOR<ManufacturersRelationFilter, manufacturersWhereInput>
    transmissions?: XOR<TransmissionsRelationFilter, transmissionsWhereInput>
    vehicle_types?: XOR<Vehicle_typesRelationFilter, vehicle_typesWhereInput>
    package_serivce?: Package_serivceListRelationFilter
    reservations?: ReservationsListRelationFilter
    slabs?: SlabsListRelationFilter
    sub_services?: Sub_servicesListRelationFilter
    tours?: ToursListRelationFilter
  }

  export type carsOrderByWithRelationInput = {
    id?: SortOrder
    body_type_id?: SortOrder
    transmission_id?: SortOrder
    manufacturer_id?: SortOrder
    driver_id?: SortOrder
    fuel_id?: SortOrder
    vehicle_type_id?: SortOrder
    car_model?: SortOrder
    name?: SortOrder
    qty?: SortOrder
    passenger_seats?: SortOrder
    maximum_luggage?: SortOrder
    total_doors?: SortOrder
    child_seat?: SortOrder
    image?: SortOrder
    status?: SortOrder
    per_mile_rate?: SortOrder
    hourly_rate?: SortOrder
    minimum_fare?: SortOrder
    minimum_hours?: SortOrder
    fixed_price?: SortOrder
    is_slab_enabled?: SortOrder
    is_loc_enabled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_type?: SortOrder
    car_prices?: car_pricesOrderByRelationAggregateInput
    body_types?: body_typesOrderByWithRelationInput
    drivers?: driversOrderByWithRelationInput
    fuel_types?: fuel_typesOrderByWithRelationInput
    manufacturers?: manufacturersOrderByWithRelationInput
    transmissions?: transmissionsOrderByWithRelationInput
    vehicle_types?: vehicle_typesOrderByWithRelationInput
    package_serivce?: package_serivceOrderByRelationAggregateInput
    reservations?: reservationsOrderByRelationAggregateInput
    slabs?: slabsOrderByRelationAggregateInput
    sub_services?: sub_servicesOrderByRelationAggregateInput
    tours?: toursOrderByRelationAggregateInput
  }

  export type carsWhereUniqueInput = {
    id?: number
  }

  export type carsOrderByWithAggregationInput = {
    id?: SortOrder
    body_type_id?: SortOrder
    transmission_id?: SortOrder
    manufacturer_id?: SortOrder
    driver_id?: SortOrder
    fuel_id?: SortOrder
    vehicle_type_id?: SortOrder
    car_model?: SortOrder
    name?: SortOrder
    qty?: SortOrder
    passenger_seats?: SortOrder
    maximum_luggage?: SortOrder
    total_doors?: SortOrder
    child_seat?: SortOrder
    image?: SortOrder
    status?: SortOrder
    per_mile_rate?: SortOrder
    hourly_rate?: SortOrder
    minimum_fare?: SortOrder
    minimum_hours?: SortOrder
    fixed_price?: SortOrder
    is_slab_enabled?: SortOrder
    is_loc_enabled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_type?: SortOrder
    _count?: carsCountOrderByAggregateInput
    _avg?: carsAvgOrderByAggregateInput
    _max?: carsMaxOrderByAggregateInput
    _min?: carsMinOrderByAggregateInput
    _sum?: carsSumOrderByAggregateInput
  }

  export type carsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<carsScalarWhereWithAggregatesInput>
    OR?: Enumerable<carsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<carsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    body_type_id?: IntWithAggregatesFilter | number
    transmission_id?: IntWithAggregatesFilter | number
    manufacturer_id?: IntWithAggregatesFilter | number
    driver_id?: IntWithAggregatesFilter | number
    fuel_id?: IntWithAggregatesFilter | number
    vehicle_type_id?: IntWithAggregatesFilter | number
    car_model?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    qty?: StringNullableWithAggregatesFilter | string | null
    passenger_seats?: IntNullableWithAggregatesFilter | number | null
    maximum_luggage?: IntNullableWithAggregatesFilter | number | null
    total_doors?: IntNullableWithAggregatesFilter | number | null
    child_seat?: IntNullableWithAggregatesFilter | number | null
    image?: StringNullableWithAggregatesFilter | string | null
    status?: BoolNullableWithAggregatesFilter | boolean | null
    per_mile_rate?: FloatNullableWithAggregatesFilter | number | null
    hourly_rate?: FloatNullableWithAggregatesFilter | number | null
    minimum_fare?: FloatNullableWithAggregatesFilter | number | null
    minimum_hours?: IntNullableWithAggregatesFilter | number | null
    fixed_price?: FloatNullableWithAggregatesFilter | number | null
    is_slab_enabled?: BoolNullableWithAggregatesFilter | boolean | null
    is_loc_enabled?: BoolNullableWithAggregatesFilter | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isActive?: BoolNullableWithAggregatesFilter | boolean | null
    car_type?: Enumcars_car_typeNullableWithAggregatesFilter | cars_car_type | null
  }

  export type city_toursWhereInput = {
    AND?: Enumerable<city_toursWhereInput>
    OR?: Enumerable<city_toursWhereInput>
    NOT?: Enumerable<city_toursWhereInput>
    id?: IntFilter | number
    city_name?: StringFilter | string
    pick_up_location?: StringFilter | string
    Created_on?: DateTimeFilter | Date | string
  }

  export type city_toursOrderByWithRelationInput = {
    id?: SortOrder
    city_name?: SortOrder
    pick_up_location?: SortOrder
    Created_on?: SortOrder
  }

  export type city_toursWhereUniqueInput = {
    id?: number
  }

  export type city_toursOrderByWithAggregationInput = {
    id?: SortOrder
    city_name?: SortOrder
    pick_up_location?: SortOrder
    Created_on?: SortOrder
    _count?: city_toursCountOrderByAggregateInput
    _avg?: city_toursAvgOrderByAggregateInput
    _max?: city_toursMaxOrderByAggregateInput
    _min?: city_toursMinOrderByAggregateInput
    _sum?: city_toursSumOrderByAggregateInput
  }

  export type city_toursScalarWhereWithAggregatesInput = {
    AND?: Enumerable<city_toursScalarWhereWithAggregatesInput>
    OR?: Enumerable<city_toursScalarWhereWithAggregatesInput>
    NOT?: Enumerable<city_toursScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    city_name?: StringWithAggregatesFilter | string
    pick_up_location?: StringWithAggregatesFilter | string
    Created_on?: DateTimeWithAggregatesFilter | Date | string
  }

  export type countriesWhereInput = {
    AND?: Enumerable<countriesWhereInput>
    OR?: Enumerable<countriesWhereInput>
    NOT?: Enumerable<countriesWhereInput>
    id?: IntFilter | number
    sortname?: StringFilter | string
    name?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type countriesOrderByWithRelationInput = {
    id?: SortOrder
    sortname?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type countriesWhereUniqueInput = {
    id?: number
  }

  export type countriesOrderByWithAggregationInput = {
    id?: SortOrder
    sortname?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: countriesCountOrderByAggregateInput
    _avg?: countriesAvgOrderByAggregateInput
    _max?: countriesMaxOrderByAggregateInput
    _min?: countriesMinOrderByAggregateInput
    _sum?: countriesSumOrderByAggregateInput
  }

  export type countriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<countriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<countriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<countriesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sortname?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type couponsWhereInput = {
    AND?: Enumerable<couponsWhereInput>
    OR?: Enumerable<couponsWhereInput>
    NOT?: Enumerable<couponsWhereInput>
    id?: IntFilter | number
    coupon_name?: StringNullableFilter | string | null
    percentage?: IntNullableFilter | number | null
    price?: IntNullableFilter | number | null
    status?: BoolFilter | boolean
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type couponsOrderByWithRelationInput = {
    id?: SortOrder
    coupon_name?: SortOrder
    percentage?: SortOrder
    price?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type couponsWhereUniqueInput = {
    id?: number
  }

  export type couponsOrderByWithAggregationInput = {
    id?: SortOrder
    coupon_name?: SortOrder
    percentage?: SortOrder
    price?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: couponsCountOrderByAggregateInput
    _avg?: couponsAvgOrderByAggregateInput
    _max?: couponsMaxOrderByAggregateInput
    _min?: couponsMinOrderByAggregateInput
    _sum?: couponsSumOrderByAggregateInput
  }

  export type couponsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<couponsScalarWhereWithAggregatesInput>
    OR?: Enumerable<couponsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<couponsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    coupon_name?: StringNullableWithAggregatesFilter | string | null
    percentage?: IntNullableWithAggregatesFilter | number | null
    price?: IntNullableWithAggregatesFilter | number | null
    status?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type datatablesWhereInput = {
    AND?: Enumerable<datatablesWhereInput>
    OR?: Enumerable<datatablesWhereInput>
    NOT?: Enumerable<datatablesWhereInput>
    id?: IntFilter | number
    firstname?: StringNullableFilter | string | null
    lastname?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    points?: StringNullableFilter | string | null
    notes?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    age?: IntNullableFilter | number | null
    job?: StringNullableFilter | string | null
    gender?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    sale_date?: StringNullableFilter | string | null
  }

  export type datatablesOrderByWithRelationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    points?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    age?: SortOrder
    job?: SortOrder
    gender?: SortOrder
    country?: SortOrder
    sale_date?: SortOrder
  }

  export type datatablesWhereUniqueInput = {
    id?: number
  }

  export type datatablesOrderByWithAggregationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    points?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    age?: SortOrder
    job?: SortOrder
    gender?: SortOrder
    country?: SortOrder
    sale_date?: SortOrder
    _count?: datatablesCountOrderByAggregateInput
    _avg?: datatablesAvgOrderByAggregateInput
    _max?: datatablesMaxOrderByAggregateInput
    _min?: datatablesMinOrderByAggregateInput
    _sum?: datatablesSumOrderByAggregateInput
  }

  export type datatablesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<datatablesScalarWhereWithAggregatesInput>
    OR?: Enumerable<datatablesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<datatablesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    firstname?: StringNullableWithAggregatesFilter | string | null
    lastname?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    points?: StringNullableWithAggregatesFilter | string | null
    notes?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    age?: IntNullableWithAggregatesFilter | number | null
    job?: StringNullableWithAggregatesFilter | string | null
    gender?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    sale_date?: StringNullableWithAggregatesFilter | string | null
  }

  export type driversWhereInput = {
    AND?: Enumerable<driversWhereInput>
    OR?: Enumerable<driversWhereInput>
    NOT?: Enumerable<driversWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    cars?: CarsListRelationFilter
  }

  export type driversOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cars?: carsOrderByRelationAggregateInput
  }

  export type driversWhereUniqueInput = {
    id?: number
  }

  export type driversOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: driversCountOrderByAggregateInput
    _avg?: driversAvgOrderByAggregateInput
    _max?: driversMaxOrderByAggregateInput
    _min?: driversMinOrderByAggregateInput
    _sum?: driversSumOrderByAggregateInput
  }

  export type driversScalarWhereWithAggregatesInput = {
    AND?: Enumerable<driversScalarWhereWithAggregatesInput>
    OR?: Enumerable<driversScalarWhereWithAggregatesInput>
    NOT?: Enumerable<driversScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type featuresWhereInput = {
    AND?: Enumerable<featuresWhereInput>
    OR?: Enumerable<featuresWhereInput>
    NOT?: Enumerable<featuresWhereInput>
    id?: IntFilter | number
    feature?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type featuresOrderByWithRelationInput = {
    id?: SortOrder
    feature?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type featuresWhereUniqueInput = {
    id?: number
  }

  export type featuresOrderByWithAggregationInput = {
    id?: SortOrder
    feature?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: featuresCountOrderByAggregateInput
    _avg?: featuresAvgOrderByAggregateInput
    _max?: featuresMaxOrderByAggregateInput
    _min?: featuresMinOrderByAggregateInput
    _sum?: featuresSumOrderByAggregateInput
  }

  export type featuresScalarWhereWithAggregatesInput = {
    AND?: Enumerable<featuresScalarWhereWithAggregatesInput>
    OR?: Enumerable<featuresScalarWhereWithAggregatesInput>
    NOT?: Enumerable<featuresScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    feature?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type filesWhereInput = {
    AND?: Enumerable<filesWhereInput>
    OR?: Enumerable<filesWhereInput>
    NOT?: Enumerable<filesWhereInput>
    id?: IntFilter | number
    filename?: StringFilter | string
    mime?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type filesOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    mime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type filesWhereUniqueInput = {
    id?: number
  }

  export type filesOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    mime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: filesCountOrderByAggregateInput
    _avg?: filesAvgOrderByAggregateInput
    _max?: filesMaxOrderByAggregateInput
    _min?: filesMinOrderByAggregateInput
    _sum?: filesSumOrderByAggregateInput
  }

  export type filesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<filesScalarWhereWithAggregatesInput>
    OR?: Enumerable<filesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<filesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    filename?: StringWithAggregatesFilter | string
    mime?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type fuel_typesWhereInput = {
    AND?: Enumerable<fuel_typesWhereInput>
    OR?: Enumerable<fuel_typesWhereInput>
    NOT?: Enumerable<fuel_typesWhereInput>
    id?: IntFilter | number
    fuel_type?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    cars?: CarsListRelationFilter
  }

  export type fuel_typesOrderByWithRelationInput = {
    id?: SortOrder
    fuel_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cars?: carsOrderByRelationAggregateInput
  }

  export type fuel_typesWhereUniqueInput = {
    id?: number
  }

  export type fuel_typesOrderByWithAggregationInput = {
    id?: SortOrder
    fuel_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: fuel_typesCountOrderByAggregateInput
    _avg?: fuel_typesAvgOrderByAggregateInput
    _max?: fuel_typesMaxOrderByAggregateInput
    _min?: fuel_typesMinOrderByAggregateInput
    _sum?: fuel_typesSumOrderByAggregateInput
  }

  export type fuel_typesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fuel_typesScalarWhereWithAggregatesInput>
    OR?: Enumerable<fuel_typesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fuel_typesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fuel_type?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type gratuitiesWhereInput = {
    AND?: Enumerable<gratuitiesWhereInput>
    OR?: Enumerable<gratuitiesWhereInput>
    NOT?: Enumerable<gratuitiesWhereInput>
    id?: IntFilter | number
    percentage?: IntNullableFilter | number | null
    status?: BoolNullableFilter | boolean | null
    name?: StringNullableFilter | string | null
    price?: IntFilter | number
    service_id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    services?: XOR<ServicesRelationFilter, servicesWhereInput>
  }

  export type gratuitiesOrderByWithRelationInput = {
    id?: SortOrder
    percentage?: SortOrder
    status?: SortOrder
    name?: SortOrder
    price?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    services?: servicesOrderByWithRelationInput
  }

  export type gratuitiesWhereUniqueInput = {
    id?: number
  }

  export type gratuitiesOrderByWithAggregationInput = {
    id?: SortOrder
    percentage?: SortOrder
    status?: SortOrder
    name?: SortOrder
    price?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: gratuitiesCountOrderByAggregateInput
    _avg?: gratuitiesAvgOrderByAggregateInput
    _max?: gratuitiesMaxOrderByAggregateInput
    _min?: gratuitiesMinOrderByAggregateInput
    _sum?: gratuitiesSumOrderByAggregateInput
  }

  export type gratuitiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<gratuitiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<gratuitiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<gratuitiesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    percentage?: IntNullableWithAggregatesFilter | number | null
    status?: BoolNullableWithAggregatesFilter | boolean | null
    name?: StringNullableWithAggregatesFilter | string | null
    price?: IntWithAggregatesFilter | number
    service_id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type hourly_servicesWhereInput = {
    AND?: Enumerable<hourly_servicesWhereInput>
    OR?: Enumerable<hourly_servicesWhereInput>
    NOT?: Enumerable<hourly_servicesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    pickup_location?: StringFilter | string
    pickup_date_time?: DateTimeFilter | Date | string
    num_passengers?: IntFilter | number
    num_service_hours?: IntFilter | number
    dropoff_location?: StringFilter | string
    add_another_stop?: BoolFilter | boolean
    additional_comments?: StringNullableFilter | string | null
    status?: BoolFilter | boolean
    service_id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    services?: XOR<ServicesRelationFilter, servicesWhereInput>
  }

  export type hourly_servicesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_location?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    num_service_hours?: SortOrder
    dropoff_location?: SortOrder
    add_another_stop?: SortOrder
    additional_comments?: SortOrder
    status?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    services?: servicesOrderByWithRelationInput
  }

  export type hourly_servicesWhereUniqueInput = {
    id?: number
  }

  export type hourly_servicesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_location?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    num_service_hours?: SortOrder
    dropoff_location?: SortOrder
    add_another_stop?: SortOrder
    additional_comments?: SortOrder
    status?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: hourly_servicesCountOrderByAggregateInput
    _avg?: hourly_servicesAvgOrderByAggregateInput
    _max?: hourly_servicesMaxOrderByAggregateInput
    _min?: hourly_servicesMinOrderByAggregateInput
    _sum?: hourly_servicesSumOrderByAggregateInput
  }

  export type hourly_servicesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<hourly_servicesScalarWhereWithAggregatesInput>
    OR?: Enumerable<hourly_servicesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<hourly_servicesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    pickup_location?: StringWithAggregatesFilter | string
    pickup_date_time?: DateTimeWithAggregatesFilter | Date | string
    num_passengers?: IntWithAggregatesFilter | number
    num_service_hours?: IntWithAggregatesFilter | number
    dropoff_location?: StringWithAggregatesFilter | string
    add_another_stop?: BoolWithAggregatesFilter | boolean
    additional_comments?: StringNullableWithAggregatesFilter | string | null
    status?: BoolWithAggregatesFilter | boolean
    service_id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type locationsWhereInput = {
    AND?: Enumerable<locationsWhereInput>
    OR?: Enumerable<locationsWhereInput>
    NOT?: Enumerable<locationsWhereInput>
    id?: IntFilter | number
    title?: StringNullableFilter | string | null
    pickup_location?: StringNullableFilter | string | null
    pickup_lat?: StringNullableFilter | string | null
    pickup_lng?: StringNullableFilter | string | null
    dropoff_location?: StringNullableFilter | string | null
    dropoff_lat?: StringNullableFilter | string | null
    dropoff_lng?: StringNullableFilter | string | null
    fee?: FloatNullableFilter | number | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type locationsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    fee?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type locationsWhereUniqueInput = {
    id?: number
  }

  export type locationsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    fee?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: locationsCountOrderByAggregateInput
    _avg?: locationsAvgOrderByAggregateInput
    _max?: locationsMaxOrderByAggregateInput
    _min?: locationsMinOrderByAggregateInput
    _sum?: locationsSumOrderByAggregateInput
  }

  export type locationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<locationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<locationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<locationsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringNullableWithAggregatesFilter | string | null
    pickup_location?: StringNullableWithAggregatesFilter | string | null
    pickup_lat?: StringNullableWithAggregatesFilter | string | null
    pickup_lng?: StringNullableWithAggregatesFilter | string | null
    dropoff_location?: StringNullableWithAggregatesFilter | string | null
    dropoff_lat?: StringNullableWithAggregatesFilter | string | null
    dropoff_lng?: StringNullableWithAggregatesFilter | string | null
    fee?: FloatNullableWithAggregatesFilter | number | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type manufacturersWhereInput = {
    AND?: Enumerable<manufacturersWhereInput>
    OR?: Enumerable<manufacturersWhereInput>
    NOT?: Enumerable<manufacturersWhereInput>
    id?: IntFilter | number
    Manufacturer?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    cars?: CarsListRelationFilter
  }

  export type manufacturersOrderByWithRelationInput = {
    id?: SortOrder
    Manufacturer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cars?: carsOrderByRelationAggregateInput
  }

  export type manufacturersWhereUniqueInput = {
    id?: number
    Manufacturer?: string
  }

  export type manufacturersOrderByWithAggregationInput = {
    id?: SortOrder
    Manufacturer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: manufacturersCountOrderByAggregateInput
    _avg?: manufacturersAvgOrderByAggregateInput
    _max?: manufacturersMaxOrderByAggregateInput
    _min?: manufacturersMinOrderByAggregateInput
    _sum?: manufacturersSumOrderByAggregateInput
  }

  export type manufacturersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<manufacturersScalarWhereWithAggregatesInput>
    OR?: Enumerable<manufacturersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<manufacturersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    Manufacturer?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type migrationsWhereInput = {
    AND?: Enumerable<migrationsWhereInput>
    OR?: Enumerable<migrationsWhereInput>
    NOT?: Enumerable<migrationsWhereInput>
    id?: IntFilter | number
    migration?: StringFilter | string
    batch?: IntFilter | number
  }

  export type migrationsOrderByWithRelationInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsWhereUniqueInput = {
    id?: number
  }

  export type migrationsOrderByWithAggregationInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
    _count?: migrationsCountOrderByAggregateInput
    _avg?: migrationsAvgOrderByAggregateInput
    _max?: migrationsMaxOrderByAggregateInput
    _min?: migrationsMinOrderByAggregateInput
    _sum?: migrationsSumOrderByAggregateInput
  }

  export type migrationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<migrationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<migrationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<migrationsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    migration?: StringWithAggregatesFilter | string
    batch?: IntWithAggregatesFilter | number
  }

  export type package_typesWhereInput = {
    AND?: Enumerable<package_typesWhereInput>
    OR?: Enumerable<package_typesWhereInput>
    NOT?: Enumerable<package_typesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    password?: StringFilter | string
    Created_on?: DateTimeFilter | Date | string
  }

  export type package_typesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    Created_on?: SortOrder
  }

  export type package_typesWhereUniqueInput = {
    id?: number
  }

  export type package_typesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    Created_on?: SortOrder
    _count?: package_typesCountOrderByAggregateInput
    _avg?: package_typesAvgOrderByAggregateInput
    _max?: package_typesMaxOrderByAggregateInput
    _min?: package_typesMinOrderByAggregateInput
    _sum?: package_typesSumOrderByAggregateInput
  }

  export type package_typesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<package_typesScalarWhereWithAggregatesInput>
    OR?: Enumerable<package_typesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<package_typesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    Created_on?: DateTimeWithAggregatesFilter | Date | string
  }

  export type persistencesWhereInput = {
    AND?: Enumerable<persistencesWhereInput>
    OR?: Enumerable<persistencesWhereInput>
    NOT?: Enumerable<persistencesWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    code?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type persistencesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type persistencesWhereUniqueInput = {
    id?: number
    code?: string
  }

  export type persistencesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: persistencesCountOrderByAggregateInput
    _avg?: persistencesAvgOrderByAggregateInput
    _max?: persistencesMaxOrderByAggregateInput
    _min?: persistencesMinOrderByAggregateInput
    _sum?: persistencesSumOrderByAggregateInput
  }

  export type persistencesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<persistencesScalarWhereWithAggregatesInput>
    OR?: Enumerable<persistencesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<persistencesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    code?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type point_to_point_servicesWhereInput = {
    AND?: Enumerable<point_to_point_servicesWhereInput>
    OR?: Enumerable<point_to_point_servicesWhereInput>
    NOT?: Enumerable<point_to_point_servicesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    pickup_location?: StringFilter | string
    pickup_date_time?: DateTimeFilter | Date | string
    num_passengers?: IntFilter | number
    dropoff_location?: StringFilter | string
    add_another_stop?: BoolFilter | boolean
    additional_comments?: StringNullableFilter | string | null
    status?: BoolFilter | boolean
    pick_up_lat?: StringFilter | string
    pick_up_lon?: StringFilter | string
    drop_off_lat?: StringFilter | string
    drop_off_lon?: StringFilter | string
    service_id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    services?: XOR<ServicesRelationFilter, servicesWhereInput>
  }

  export type point_to_point_servicesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_location?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    dropoff_location?: SortOrder
    add_another_stop?: SortOrder
    additional_comments?: SortOrder
    status?: SortOrder
    pick_up_lat?: SortOrder
    pick_up_lon?: SortOrder
    drop_off_lat?: SortOrder
    drop_off_lon?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    services?: servicesOrderByWithRelationInput
  }

  export type point_to_point_servicesWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type point_to_point_servicesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_location?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    dropoff_location?: SortOrder
    add_another_stop?: SortOrder
    additional_comments?: SortOrder
    status?: SortOrder
    pick_up_lat?: SortOrder
    pick_up_lon?: SortOrder
    drop_off_lat?: SortOrder
    drop_off_lon?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: point_to_point_servicesCountOrderByAggregateInput
    _avg?: point_to_point_servicesAvgOrderByAggregateInput
    _max?: point_to_point_servicesMaxOrderByAggregateInput
    _min?: point_to_point_servicesMinOrderByAggregateInput
    _sum?: point_to_point_servicesSumOrderByAggregateInput
  }

  export type point_to_point_servicesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<point_to_point_servicesScalarWhereWithAggregatesInput>
    OR?: Enumerable<point_to_point_servicesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<point_to_point_servicesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    pickup_location?: StringWithAggregatesFilter | string
    pickup_date_time?: DateTimeWithAggregatesFilter | Date | string
    num_passengers?: IntWithAggregatesFilter | number
    dropoff_location?: StringWithAggregatesFilter | string
    add_another_stop?: BoolWithAggregatesFilter | boolean
    additional_comments?: StringNullableWithAggregatesFilter | string | null
    status?: BoolWithAggregatesFilter | boolean
    pick_up_lat?: StringWithAggregatesFilter | string
    pick_up_lon?: StringWithAggregatesFilter | string
    drop_off_lat?: StringWithAggregatesFilter | string
    drop_off_lon?: StringWithAggregatesFilter | string
    service_id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type remindersWhereInput = {
    AND?: Enumerable<remindersWhereInput>
    OR?: Enumerable<remindersWhereInput>
    NOT?: Enumerable<remindersWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    code?: StringFilter | string
    completed?: BoolFilter | boolean
    completed_at?: DateTimeNullableFilter | Date | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type remindersOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type remindersWhereUniqueInput = {
    id?: number
  }

  export type remindersOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: remindersCountOrderByAggregateInput
    _avg?: remindersAvgOrderByAggregateInput
    _max?: remindersMaxOrderByAggregateInput
    _min?: remindersMinOrderByAggregateInput
    _sum?: remindersSumOrderByAggregateInput
  }

  export type remindersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<remindersScalarWhereWithAggregatesInput>
    OR?: Enumerable<remindersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<remindersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    code?: StringWithAggregatesFilter | string
    completed?: BoolWithAggregatesFilter | boolean
    completed_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type reservationsWhereInput = {
    AND?: Enumerable<reservationsWhereInput>
    OR?: Enumerable<reservationsWhereInput>
    NOT?: Enumerable<reservationsWhereInput>
    id?: IntFilter | number
    order_number?: StringNullableFilter | string | null
    service_id?: IntFilter | number
    car_id?: IntFilter | number
    pick_up_postal_code?: StringNullableFilter | string | null
    pick_up_lat?: FloatNullableFilter | number | null
    pick_up_lon?: FloatNullableFilter | number | null
    pick_up_loc_name?: StringNullableFilter | string | null
    drop_off_postal_code?: StringNullableFilter | string | null
    drop_off_lat?: FloatNullableFilter | number | null
    drop_off_lon?: FloatNullableFilter | number | null
    drop_off_loc_name?: StringNullableFilter | string | null
    pick_up_date?: DateTimeNullableFilter | Date | string | null
    price?: FloatNullableFilter | number | null
    tax?: FloatNullableFilter | number | null
    airline?: StringNullableFilter | string | null
    flight_no?: StringNullableFilter | string | null
    no_of_hours?: IntNullableFilter | number | null
    maximum_passenger?: IntNullableFilter | number | null
    maximum_luggage?: IntNullableFilter | number | null
    customer_first_name?: StringNullableFilter | string | null
    customer_last_name?: StringNullableFilter | string | null
    customer_cnic?: StringNullableFilter | string | null
    customer_email?: StringNullableFilter | string | null
    customer_phone?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    payment_method?: StringNullableFilter | string | null
    isPaid?: IntNullableFilter | number | null
    special_instruction?: StringNullableFilter | string | null
    cars?: XOR<CarsRelationFilter, carsWhereInput>
    sub_services?: XOR<Sub_servicesRelationFilter, sub_servicesWhereInput>
  }

  export type reservationsOrderByWithRelationInput = {
    id?: SortOrder
    order_number?: SortOrder
    service_id?: SortOrder
    car_id?: SortOrder
    pick_up_postal_code?: SortOrder
    pick_up_lat?: SortOrder
    pick_up_lon?: SortOrder
    pick_up_loc_name?: SortOrder
    drop_off_postal_code?: SortOrder
    drop_off_lat?: SortOrder
    drop_off_lon?: SortOrder
    drop_off_loc_name?: SortOrder
    pick_up_date?: SortOrder
    price?: SortOrder
    tax?: SortOrder
    airline?: SortOrder
    flight_no?: SortOrder
    no_of_hours?: SortOrder
    maximum_passenger?: SortOrder
    maximum_luggage?: SortOrder
    customer_first_name?: SortOrder
    customer_last_name?: SortOrder
    customer_cnic?: SortOrder
    customer_email?: SortOrder
    customer_phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    uuid?: SortOrder
    payment_method?: SortOrder
    isPaid?: SortOrder
    special_instruction?: SortOrder
    cars?: carsOrderByWithRelationInput
    sub_services?: sub_servicesOrderByWithRelationInput
  }

  export type reservationsWhereUniqueInput = {
    id?: number
    uuid?: string
  }

  export type reservationsOrderByWithAggregationInput = {
    id?: SortOrder
    order_number?: SortOrder
    service_id?: SortOrder
    car_id?: SortOrder
    pick_up_postal_code?: SortOrder
    pick_up_lat?: SortOrder
    pick_up_lon?: SortOrder
    pick_up_loc_name?: SortOrder
    drop_off_postal_code?: SortOrder
    drop_off_lat?: SortOrder
    drop_off_lon?: SortOrder
    drop_off_loc_name?: SortOrder
    pick_up_date?: SortOrder
    price?: SortOrder
    tax?: SortOrder
    airline?: SortOrder
    flight_no?: SortOrder
    no_of_hours?: SortOrder
    maximum_passenger?: SortOrder
    maximum_luggage?: SortOrder
    customer_first_name?: SortOrder
    customer_last_name?: SortOrder
    customer_cnic?: SortOrder
    customer_email?: SortOrder
    customer_phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    uuid?: SortOrder
    payment_method?: SortOrder
    isPaid?: SortOrder
    special_instruction?: SortOrder
    _count?: reservationsCountOrderByAggregateInput
    _avg?: reservationsAvgOrderByAggregateInput
    _max?: reservationsMaxOrderByAggregateInput
    _min?: reservationsMinOrderByAggregateInput
    _sum?: reservationsSumOrderByAggregateInput
  }

  export type reservationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reservationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<reservationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reservationsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    order_number?: StringNullableWithAggregatesFilter | string | null
    service_id?: IntWithAggregatesFilter | number
    car_id?: IntWithAggregatesFilter | number
    pick_up_postal_code?: StringNullableWithAggregatesFilter | string | null
    pick_up_lat?: FloatNullableWithAggregatesFilter | number | null
    pick_up_lon?: FloatNullableWithAggregatesFilter | number | null
    pick_up_loc_name?: StringNullableWithAggregatesFilter | string | null
    drop_off_postal_code?: StringNullableWithAggregatesFilter | string | null
    drop_off_lat?: FloatNullableWithAggregatesFilter | number | null
    drop_off_lon?: FloatNullableWithAggregatesFilter | number | null
    drop_off_loc_name?: StringNullableWithAggregatesFilter | string | null
    pick_up_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    price?: FloatNullableWithAggregatesFilter | number | null
    tax?: FloatNullableWithAggregatesFilter | number | null
    airline?: StringNullableWithAggregatesFilter | string | null
    flight_no?: StringNullableWithAggregatesFilter | string | null
    no_of_hours?: IntNullableWithAggregatesFilter | number | null
    maximum_passenger?: IntNullableWithAggregatesFilter | number | null
    maximum_luggage?: IntNullableWithAggregatesFilter | number | null
    customer_first_name?: StringNullableWithAggregatesFilter | string | null
    customer_last_name?: StringNullableWithAggregatesFilter | string | null
    customer_cnic?: StringNullableWithAggregatesFilter | string | null
    customer_email?: StringNullableWithAggregatesFilter | string | null
    customer_phone?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    payment_method?: StringNullableWithAggregatesFilter | string | null
    isPaid?: IntNullableWithAggregatesFilter | number | null
    special_instruction?: StringNullableWithAggregatesFilter | string | null
  }

  export type role_usersWhereInput = {
    AND?: Enumerable<role_usersWhereInput>
    OR?: Enumerable<role_usersWhereInput>
    NOT?: Enumerable<role_usersWhereInput>
    user_id?: IntFilter | number
    role_id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type role_usersOrderByWithRelationInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    roles?: rolesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type role_usersWhereUniqueInput = {
    user_id_role_id?: role_usersUser_idRole_idCompoundUniqueInput
  }

  export type role_usersOrderByWithAggregationInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: role_usersCountOrderByAggregateInput
    _avg?: role_usersAvgOrderByAggregateInput
    _max?: role_usersMaxOrderByAggregateInput
    _min?: role_usersMinOrderByAggregateInput
    _sum?: role_usersSumOrderByAggregateInput
  }

  export type role_usersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<role_usersScalarWhereWithAggregatesInput>
    OR?: Enumerable<role_usersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<role_usersScalarWhereWithAggregatesInput>
    user_id?: IntWithAggregatesFilter | number
    role_id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type rolesWhereInput = {
    AND?: Enumerable<rolesWhereInput>
    OR?: Enumerable<rolesWhereInput>
    NOT?: Enumerable<rolesWhereInput>
    id?: IntFilter | number
    slug?: StringFilter | string
    name?: StringFilter | string
    permissions?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    role_users?: Role_usersListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role_users?: role_usersOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = {
    id?: number
    slug?: string
  }

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<rolesScalarWhereWithAggregatesInput>
    OR?: Enumerable<rolesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<rolesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    slug?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    permissions?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type servicesWhereInput = {
    AND?: Enumerable<servicesWhereInput>
    OR?: Enumerable<servicesWhereInput>
    NOT?: Enumerable<servicesWhereInput>
    id?: IntFilter | number
    Name?: StringNullableFilter | string | null
    Status?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    airport_services?: Airport_servicesListRelationFilter
    gratuities?: GratuitiesListRelationFilter
    hourly_services?: Hourly_servicesListRelationFilter
    point_to_point_services?: Point_to_point_servicesListRelationFilter
    sub_services?: Sub_servicesListRelationFilter
  }

  export type servicesOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    airport_services?: airport_servicesOrderByRelationAggregateInput
    gratuities?: gratuitiesOrderByRelationAggregateInput
    hourly_services?: hourly_servicesOrderByRelationAggregateInput
    point_to_point_services?: point_to_point_servicesOrderByRelationAggregateInput
    sub_services?: sub_servicesOrderByRelationAggregateInput
  }

  export type servicesWhereUniqueInput = {
    id?: number
  }

  export type servicesOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: servicesCountOrderByAggregateInput
    _avg?: servicesAvgOrderByAggregateInput
    _max?: servicesMaxOrderByAggregateInput
    _min?: servicesMinOrderByAggregateInput
    _sum?: servicesSumOrderByAggregateInput
  }

  export type servicesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<servicesScalarWhereWithAggregatesInput>
    OR?: Enumerable<servicesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<servicesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    Name?: StringNullableWithAggregatesFilter | string | null
    Status?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type sys_settingsWhereInput = {
    AND?: Enumerable<sys_settingsWhereInput>
    OR?: Enumerable<sys_settingsWhereInput>
    NOT?: Enumerable<sys_settingsWhereInput>
    id?: IntFilter | number
    sys_name?: StringFilter | string
    sys_details?: StringFilter | string
    Created_on?: DateTimeFilter | Date | string
    setting_key?: StringFilter | string
  }

  export type sys_settingsOrderByWithRelationInput = {
    id?: SortOrder
    sys_name?: SortOrder
    sys_details?: SortOrder
    Created_on?: SortOrder
    setting_key?: SortOrder
  }

  export type sys_settingsWhereUniqueInput = {
    id?: number
  }

  export type sys_settingsOrderByWithAggregationInput = {
    id?: SortOrder
    sys_name?: SortOrder
    sys_details?: SortOrder
    Created_on?: SortOrder
    setting_key?: SortOrder
    _count?: sys_settingsCountOrderByAggregateInput
    _avg?: sys_settingsAvgOrderByAggregateInput
    _max?: sys_settingsMaxOrderByAggregateInput
    _min?: sys_settingsMinOrderByAggregateInput
    _sum?: sys_settingsSumOrderByAggregateInput
  }

  export type sys_settingsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sys_settingsScalarWhereWithAggregatesInput>
    OR?: Enumerable<sys_settingsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sys_settingsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sys_name?: StringWithAggregatesFilter | string
    sys_details?: StringWithAggregatesFilter | string
    Created_on?: DateTimeWithAggregatesFilter | Date | string
    setting_key?: StringWithAggregatesFilter | string
  }

  export type taggable_tagsWhereInput = {
    AND?: Enumerable<taggable_tagsWhereInput>
    OR?: Enumerable<taggable_tagsWhereInput>
    NOT?: Enumerable<taggable_tagsWhereInput>
    tag_id?: IntFilter | number
    name?: StringFilter | string
    normalized?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type taggable_tagsOrderByWithRelationInput = {
    tag_id?: SortOrder
    name?: SortOrder
    normalized?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type taggable_tagsWhereUniqueInput = {
    tag_id?: number
  }

  export type taggable_tagsOrderByWithAggregationInput = {
    tag_id?: SortOrder
    name?: SortOrder
    normalized?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: taggable_tagsCountOrderByAggregateInput
    _avg?: taggable_tagsAvgOrderByAggregateInput
    _max?: taggable_tagsMaxOrderByAggregateInput
    _min?: taggable_tagsMinOrderByAggregateInput
    _sum?: taggable_tagsSumOrderByAggregateInput
  }

  export type taggable_tagsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<taggable_tagsScalarWhereWithAggregatesInput>
    OR?: Enumerable<taggable_tagsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<taggable_tagsScalarWhereWithAggregatesInput>
    tag_id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    normalized?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type tasksWhereInput = {
    AND?: Enumerable<tasksWhereInput>
    OR?: Enumerable<tasksWhereInput>
    NOT?: Enumerable<tasksWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    finished?: IntFilter | number
    task_description?: StringFilter | string
    task_deadline?: DateTimeFilter | Date | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type tasksOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    finished?: SortOrder
    task_description?: SortOrder
    task_deadline?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tasksWhereUniqueInput = {
    id?: number
  }

  export type tasksOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    finished?: SortOrder
    task_description?: SortOrder
    task_deadline?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tasksCountOrderByAggregateInput
    _avg?: tasksAvgOrderByAggregateInput
    _max?: tasksMaxOrderByAggregateInput
    _min?: tasksMinOrderByAggregateInput
    _sum?: tasksSumOrderByAggregateInput
  }

  export type tasksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tasksScalarWhereWithAggregatesInput>
    OR?: Enumerable<tasksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tasksScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    finished?: IntWithAggregatesFilter | number
    task_description?: StringWithAggregatesFilter | string
    task_deadline?: DateTimeWithAggregatesFilter | Date | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type throttleWhereInput = {
    AND?: Enumerable<throttleWhereInput>
    OR?: Enumerable<throttleWhereInput>
    NOT?: Enumerable<throttleWhereInput>
    id?: IntFilter | number
    user_id?: IntNullableFilter | number | null
    type?: StringFilter | string
    ip?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type throttleOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    ip?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type throttleWhereUniqueInput = {
    id?: number
  }

  export type throttleOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    ip?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: throttleCountOrderByAggregateInput
    _avg?: throttleAvgOrderByAggregateInput
    _max?: throttleMaxOrderByAggregateInput
    _min?: throttleMinOrderByAggregateInput
    _sum?: throttleSumOrderByAggregateInput
  }

  export type throttleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<throttleScalarWhereWithAggregatesInput>
    OR?: Enumerable<throttleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<throttleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntNullableWithAggregatesFilter | number | null
    type?: StringWithAggregatesFilter | string
    ip?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type toursWhereInput = {
    AND?: Enumerable<toursWhereInput>
    OR?: Enumerable<toursWhereInput>
    NOT?: Enumerable<toursWhereInput>
    id?: IntFilter | number
    title?: StringNullableFilter | string | null
    pickup_location?: StringNullableFilter | string | null
    pickup_lat?: FloatNullableFilter | number | null
    pickup_lng?: FloatNullableFilter | number | null
    dropoff_location?: StringNullableFilter | string | null
    dropoff_lat?: FloatNullableFilter | number | null
    dropoff_lng?: FloatNullableFilter | number | null
    price_per_passenger?: IntNullableFilter | number | null
    status?: BytesNullableFilter | Buffer | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    isActive?: BoolNullableFilter | boolean | null
    car_id?: IntNullableFilter | number | null
    description?: StringNullableFilter | string | null
    luggage?: IntNullableFilter | number | null
    cars?: XOR<CarsRelationFilter, carsWhereInput> | null
  }

  export type toursOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    price_per_passenger?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_id?: SortOrder
    description?: SortOrder
    luggage?: SortOrder
    cars?: carsOrderByWithRelationInput
  }

  export type toursWhereUniqueInput = {
    id?: number
  }

  export type toursOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    price_per_passenger?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_id?: SortOrder
    description?: SortOrder
    luggage?: SortOrder
    _count?: toursCountOrderByAggregateInput
    _avg?: toursAvgOrderByAggregateInput
    _max?: toursMaxOrderByAggregateInput
    _min?: toursMinOrderByAggregateInput
    _sum?: toursSumOrderByAggregateInput
  }

  export type toursScalarWhereWithAggregatesInput = {
    AND?: Enumerable<toursScalarWhereWithAggregatesInput>
    OR?: Enumerable<toursScalarWhereWithAggregatesInput>
    NOT?: Enumerable<toursScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringNullableWithAggregatesFilter | string | null
    pickup_location?: StringNullableWithAggregatesFilter | string | null
    pickup_lat?: FloatNullableWithAggregatesFilter | number | null
    pickup_lng?: FloatNullableWithAggregatesFilter | number | null
    dropoff_location?: StringNullableWithAggregatesFilter | string | null
    dropoff_lat?: FloatNullableWithAggregatesFilter | number | null
    dropoff_lng?: FloatNullableWithAggregatesFilter | number | null
    price_per_passenger?: IntNullableWithAggregatesFilter | number | null
    status?: BytesNullableWithAggregatesFilter | Buffer | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isActive?: BoolNullableWithAggregatesFilter | boolean | null
    car_id?: IntNullableWithAggregatesFilter | number | null
    description?: StringNullableWithAggregatesFilter | string | null
    luggage?: IntNullableWithAggregatesFilter | number | null
  }

  export type transmissionsWhereInput = {
    AND?: Enumerable<transmissionsWhereInput>
    OR?: Enumerable<transmissionsWhereInput>
    NOT?: Enumerable<transmissionsWhereInput>
    id?: IntFilter | number
    transmission?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    cars?: CarsListRelationFilter
  }

  export type transmissionsOrderByWithRelationInput = {
    id?: SortOrder
    transmission?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cars?: carsOrderByRelationAggregateInput
  }

  export type transmissionsWhereUniqueInput = {
    id?: number
  }

  export type transmissionsOrderByWithAggregationInput = {
    id?: SortOrder
    transmission?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: transmissionsCountOrderByAggregateInput
    _avg?: transmissionsAvgOrderByAggregateInput
    _max?: transmissionsMaxOrderByAggregateInput
    _min?: transmissionsMinOrderByAggregateInput
    _sum?: transmissionsSumOrderByAggregateInput
  }

  export type transmissionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<transmissionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<transmissionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<transmissionsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    transmission?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type usersWhereInput = {
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    password?: StringFilter | string
    permissions?: StringNullableFilter | string | null
    last_login?: DateTimeNullableFilter | Date | string | null
    first_name?: StringNullableFilter | string | null
    last_name?: StringNullableFilter | string | null
    bio?: StringNullableFilter | string | null
    gender?: StringNullableFilter | string | null
    dob?: DateTimeNullableFilter | Date | string | null
    pic?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    postal?: StringNullableFilter | string | null
    status?: BoolNullableFilter | boolean | null
    reset_token?: StringNullableFilter | string | null
    token_expired_at?: DateTimeNullableFilter | Date | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
    role_users?: Role_usersListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    permissions?: SortOrder
    last_login?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    bio?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    pic?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    address?: SortOrder
    postal?: SortOrder
    status?: SortOrder
    reset_token?: SortOrder
    token_expired_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    role_users?: role_usersOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    permissions?: SortOrder
    last_login?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    bio?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    pic?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    address?: SortOrder
    postal?: SortOrder
    status?: SortOrder
    reset_token?: SortOrder
    token_expired_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usersScalarWhereWithAggregatesInput>
    OR?: Enumerable<usersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    permissions?: StringNullableWithAggregatesFilter | string | null
    last_login?: DateTimeNullableWithAggregatesFilter | Date | string | null
    first_name?: StringNullableWithAggregatesFilter | string | null
    last_name?: StringNullableWithAggregatesFilter | string | null
    bio?: StringNullableWithAggregatesFilter | string | null
    gender?: StringNullableWithAggregatesFilter | string | null
    dob?: DateTimeNullableWithAggregatesFilter | Date | string | null
    pic?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    state?: StringNullableWithAggregatesFilter | string | null
    city?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    postal?: StringNullableWithAggregatesFilter | string | null
    status?: BoolNullableWithAggregatesFilter | boolean | null
    reset_token?: StringNullableWithAggregatesFilter | string | null
    token_expired_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type location_exceptionsWhereInput = {
    AND?: Enumerable<location_exceptionsWhereInput>
    OR?: Enumerable<location_exceptionsWhereInput>
    NOT?: Enumerable<location_exceptionsWhereInput>
    id?: IntFilter | number
    pick_up_loc_name?: StringNullableFilter | string | null
    pick_up_postal_code?: StringFilter | string
    drop_off_loc_name?: StringNullableFilter | string | null
    drop_off_postal_code?: StringFilter | string
    price?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type location_exceptionsOrderByWithRelationInput = {
    id?: SortOrder
    pick_up_loc_name?: SortOrder
    pick_up_postal_code?: SortOrder
    drop_off_loc_name?: SortOrder
    drop_off_postal_code?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type location_exceptionsWhereUniqueInput = {
    id?: number
  }

  export type location_exceptionsOrderByWithAggregationInput = {
    id?: SortOrder
    pick_up_loc_name?: SortOrder
    pick_up_postal_code?: SortOrder
    drop_off_loc_name?: SortOrder
    drop_off_postal_code?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: location_exceptionsCountOrderByAggregateInput
    _avg?: location_exceptionsAvgOrderByAggregateInput
    _max?: location_exceptionsMaxOrderByAggregateInput
    _min?: location_exceptionsMinOrderByAggregateInput
    _sum?: location_exceptionsSumOrderByAggregateInput
  }

  export type location_exceptionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<location_exceptionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<location_exceptionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<location_exceptionsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    pick_up_loc_name?: StringNullableWithAggregatesFilter | string | null
    pick_up_postal_code?: StringWithAggregatesFilter | string
    drop_off_loc_name?: StringNullableWithAggregatesFilter | string | null
    drop_off_postal_code?: StringWithAggregatesFilter | string
    price?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type package_serivceWhereInput = {
    AND?: Enumerable<package_serivceWhereInput>
    OR?: Enumerable<package_serivceWhereInput>
    NOT?: Enumerable<package_serivceWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    passenger_capacity?: IntFilter | number
    price?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    car_id?: IntFilter | number
    isActive?: BoolNullableFilter | boolean | null
    pickup_location?: StringNullableFilter | string | null
    pickup_lat?: FloatNullableFilter | number | null
    pickup_lng?: FloatNullableFilter | number | null
    dropoff_location?: StringNullableFilter | string | null
    dropoff_lat?: FloatNullableFilter | number | null
    dropoff_lng?: FloatNullableFilter | number | null
    luggage?: IntNullableFilter | number | null
    cars?: XOR<CarsRelationFilter, carsWhereInput>
  }

  export type package_serivceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    passenger_capacity?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    car_id?: SortOrder
    isActive?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    luggage?: SortOrder
    cars?: carsOrderByWithRelationInput
  }

  export type package_serivceWhereUniqueInput = {
    id?: number
  }

  export type package_serivceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    passenger_capacity?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    car_id?: SortOrder
    isActive?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    luggage?: SortOrder
    _count?: package_serivceCountOrderByAggregateInput
    _avg?: package_serivceAvgOrderByAggregateInput
    _max?: package_serivceMaxOrderByAggregateInput
    _min?: package_serivceMinOrderByAggregateInput
    _sum?: package_serivceSumOrderByAggregateInput
  }

  export type package_serivceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<package_serivceScalarWhereWithAggregatesInput>
    OR?: Enumerable<package_serivceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<package_serivceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    passenger_capacity?: IntWithAggregatesFilter | number
    price?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    car_id?: IntWithAggregatesFilter | number
    isActive?: BoolNullableWithAggregatesFilter | boolean | null
    pickup_location?: StringNullableWithAggregatesFilter | string | null
    pickup_lat?: FloatNullableWithAggregatesFilter | number | null
    pickup_lng?: FloatNullableWithAggregatesFilter | number | null
    dropoff_location?: StringNullableWithAggregatesFilter | string | null
    dropoff_lat?: FloatNullableWithAggregatesFilter | number | null
    dropoff_lng?: FloatNullableWithAggregatesFilter | number | null
    luggage?: IntNullableWithAggregatesFilter | number | null
  }

  export type slabsWhereInput = {
    AND?: Enumerable<slabsWhereInput>
    OR?: Enumerable<slabsWhereInput>
    NOT?: Enumerable<slabsWhereInput>
    id?: IntFilter | number
    car_id?: IntFilter | number
    initial_distance?: FloatFilter | number
    final_distance?: FloatFilter | number
    price?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    cars?: XOR<CarsRelationFilter, carsWhereInput>
  }

  export type slabsOrderByWithRelationInput = {
    id?: SortOrder
    car_id?: SortOrder
    initial_distance?: SortOrder
    final_distance?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cars?: carsOrderByWithRelationInput
  }

  export type slabsWhereUniqueInput = {
    id?: number
  }

  export type slabsOrderByWithAggregationInput = {
    id?: SortOrder
    car_id?: SortOrder
    initial_distance?: SortOrder
    final_distance?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: slabsCountOrderByAggregateInput
    _avg?: slabsAvgOrderByAggregateInput
    _max?: slabsMaxOrderByAggregateInput
    _min?: slabsMinOrderByAggregateInput
    _sum?: slabsSumOrderByAggregateInput
  }

  export type slabsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<slabsScalarWhereWithAggregatesInput>
    OR?: Enumerable<slabsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<slabsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    car_id?: IntWithAggregatesFilter | number
    initial_distance?: FloatWithAggregatesFilter | number
    final_distance?: FloatWithAggregatesFilter | number
    price?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type timeslotsWhereInput = {
    AND?: Enumerable<timeslotsWhereInput>
    OR?: Enumerable<timeslotsWhereInput>
    NOT?: Enumerable<timeslotsWhereInput>
    id?: IntFilter | number
    time?: DateTimeNullableFilter | Date | string | null
    isActive?: BoolNullableFilter | boolean | null
    sub_service_id?: IntNullableFilter | number | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    sub_services?: XOR<Sub_servicesRelationFilter, sub_servicesWhereInput> | null
  }

  export type timeslotsOrderByWithRelationInput = {
    id?: SortOrder
    time?: SortOrder
    isActive?: SortOrder
    sub_service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sub_services?: sub_servicesOrderByWithRelationInput
  }

  export type timeslotsWhereUniqueInput = {
    id?: number
  }

  export type timeslotsOrderByWithAggregationInput = {
    id?: SortOrder
    time?: SortOrder
    isActive?: SortOrder
    sub_service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: timeslotsCountOrderByAggregateInput
    _avg?: timeslotsAvgOrderByAggregateInput
    _max?: timeslotsMaxOrderByAggregateInput
    _min?: timeslotsMinOrderByAggregateInput
    _sum?: timeslotsSumOrderByAggregateInput
  }

  export type timeslotsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<timeslotsScalarWhereWithAggregatesInput>
    OR?: Enumerable<timeslotsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<timeslotsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    time?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isActive?: BoolNullableWithAggregatesFilter | boolean | null
    sub_service_id?: IntNullableWithAggregatesFilter | number | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type vehicle_typesWhereInput = {
    AND?: Enumerable<vehicle_typesWhereInput>
    OR?: Enumerable<vehicle_typesWhereInput>
    NOT?: Enumerable<vehicle_typesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    cars?: CarsListRelationFilter
  }

  export type vehicle_typesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cars?: carsOrderByRelationAggregateInput
  }

  export type vehicle_typesWhereUniqueInput = {
    id?: number
  }

  export type vehicle_typesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: vehicle_typesCountOrderByAggregateInput
    _avg?: vehicle_typesAvgOrderByAggregateInput
    _max?: vehicle_typesMaxOrderByAggregateInput
    _min?: vehicle_typesMinOrderByAggregateInput
    _sum?: vehicle_typesSumOrderByAggregateInput
  }

  export type vehicle_typesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<vehicle_typesScalarWhereWithAggregatesInput>
    OR?: Enumerable<vehicle_typesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<vehicle_typesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type sub_servicesWhereInput = {
    AND?: Enumerable<sub_servicesWhereInput>
    OR?: Enumerable<sub_servicesWhereInput>
    NOT?: Enumerable<sub_servicesWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    pickup_location?: StringNullableFilter | string | null
    pickup_lat?: FloatNullableFilter | number | null
    pickup_lng?: FloatNullableFilter | number | null
    dropoff_location?: StringNullableFilter | string | null
    dropoff_lat?: FloatNullableFilter | number | null
    dropoff_lng?: FloatNullableFilter | number | null
    price_per_passenger?: IntNullableFilter | number | null
    status?: BytesNullableFilter | Buffer | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    isActive?: BoolNullableFilter | boolean | null
    car_id?: IntNullableFilter | number | null
    service_id?: IntFilter | number
    description?: StringNullableFilter | string | null
    luggage?: IntNullableFilter | number | null
    passenger_capacity?: IntNullableFilter | number | null
    reservations?: ReservationsListRelationFilter
    services?: XOR<ServicesRelationFilter, servicesWhereInput>
    cars?: XOR<CarsRelationFilter, carsWhereInput> | null
    timeslots?: TimeslotsListRelationFilter
  }

  export type sub_servicesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    price_per_passenger?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_id?: SortOrder
    service_id?: SortOrder
    description?: SortOrder
    luggage?: SortOrder
    passenger_capacity?: SortOrder
    reservations?: reservationsOrderByRelationAggregateInput
    services?: servicesOrderByWithRelationInput
    cars?: carsOrderByWithRelationInput
    timeslots?: timeslotsOrderByRelationAggregateInput
  }

  export type sub_servicesWhereUniqueInput = {
    id?: number
  }

  export type sub_servicesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    price_per_passenger?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_id?: SortOrder
    service_id?: SortOrder
    description?: SortOrder
    luggage?: SortOrder
    passenger_capacity?: SortOrder
    _count?: sub_servicesCountOrderByAggregateInput
    _avg?: sub_servicesAvgOrderByAggregateInput
    _max?: sub_servicesMaxOrderByAggregateInput
    _min?: sub_servicesMinOrderByAggregateInput
    _sum?: sub_servicesSumOrderByAggregateInput
  }

  export type sub_servicesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sub_servicesScalarWhereWithAggregatesInput>
    OR?: Enumerable<sub_servicesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sub_servicesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    pickup_location?: StringNullableWithAggregatesFilter | string | null
    pickup_lat?: FloatNullableWithAggregatesFilter | number | null
    pickup_lng?: FloatNullableWithAggregatesFilter | number | null
    dropoff_location?: StringNullableWithAggregatesFilter | string | null
    dropoff_lat?: FloatNullableWithAggregatesFilter | number | null
    dropoff_lng?: FloatNullableWithAggregatesFilter | number | null
    price_per_passenger?: IntNullableWithAggregatesFilter | number | null
    status?: BytesNullableWithAggregatesFilter | Buffer | null
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isActive?: BoolNullableWithAggregatesFilter | boolean | null
    car_id?: IntNullableWithAggregatesFilter | number | null
    service_id?: IntWithAggregatesFilter | number
    description?: StringNullableWithAggregatesFilter | string | null
    luggage?: IntNullableWithAggregatesFilter | number | null
    passenger_capacity?: IntNullableWithAggregatesFilter | number | null
  }

  export type activationsCreateInput = {
    user_id: number
    code: string
    completed?: boolean
    completed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type activationsUncheckedCreateInput = {
    id?: number
    user_id: number
    code: string
    completed?: boolean
    completed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type activationsUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activationsCreateManyInput = {
    id?: number
    user_id: number
    code: string
    completed?: boolean
    completed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type activationsUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logCreateInput = {
    log_name?: string | null
    description: string
    subject_id?: number | null
    subject_type?: string | null
    causer_id?: number | null
    causer_type?: string | null
    properties?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type activity_logUncheckedCreateInput = {
    id?: number
    log_name?: string | null
    description: string
    subject_id?: number | null
    subject_type?: string | null
    causer_id?: number | null
    causer_type?: string | null
    properties?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type activity_logUpdateInput = {
    log_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_type?: NullableStringFieldUpdateOperationsInput | string | null
    causer_id?: NullableIntFieldUpdateOperationsInput | number | null
    causer_type?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    log_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_type?: NullableStringFieldUpdateOperationsInput | string | null
    causer_id?: NullableIntFieldUpdateOperationsInput | number | null
    causer_type?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logCreateManyInput = {
    id?: number
    log_name?: string | null
    description: string
    subject_id?: number | null
    subject_type?: string | null
    causer_id?: number | null
    causer_type?: string | null
    properties?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type activity_logUpdateManyMutationInput = {
    log_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_type?: NullableStringFieldUpdateOperationsInput | string | null
    causer_id?: NullableIntFieldUpdateOperationsInput | number | null
    causer_type?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    log_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    subject_type?: NullableStringFieldUpdateOperationsInput | string | null
    causer_id?: NullableIntFieldUpdateOperationsInput | number | null
    causer_type?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type airlinesCreateInput = {
    name?: string | null
    alias?: string | null
    iata?: string | null
    icao?: string | null
    callsign?: string | null
    country?: string | null
    active?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type airlinesUncheckedCreateInput = {
    id?: number
    name?: string | null
    alias?: string | null
    iata?: string | null
    icao?: string | null
    callsign?: string | null
    country?: string | null
    active?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type airlinesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    iata?: NullableStringFieldUpdateOperationsInput | string | null
    icao?: NullableStringFieldUpdateOperationsInput | string | null
    callsign?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type airlinesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    iata?: NullableStringFieldUpdateOperationsInput | string | null
    icao?: NullableStringFieldUpdateOperationsInput | string | null
    callsign?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type airlinesCreateManyInput = {
    id?: number
    name?: string | null
    alias?: string | null
    iata?: string | null
    icao?: string | null
    callsign?: string | null
    country?: string | null
    active?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type airlinesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    iata?: NullableStringFieldUpdateOperationsInput | string | null
    icao?: NullableStringFieldUpdateOperationsInput | string | null
    callsign?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type airlinesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    iata?: NullableStringFieldUpdateOperationsInput | string | null
    icao?: NullableStringFieldUpdateOperationsInput | string | null
    callsign?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type airport_servicesCreateInput = {
    name: string
    description?: string | null
    pickup_dropoff: boolean
    pickup_date_time: Date | string
    num_passengers: number
    pickup_from: string
    dropoff_location: string
    airline?: string | null
    flight_number?: string | null
    status?: boolean
    pick_up_lat: string
    drop_off_lat: string
    pick_up_lon: string
    drop_off_lon: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    services: servicesCreateNestedOneWithoutAirport_servicesInput
  }

  export type airport_servicesUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    pickup_dropoff: boolean
    pickup_date_time: Date | string
    num_passengers: number
    pickup_from: string
    dropoff_location: string
    airline?: string | null
    flight_number?: string | null
    status?: boolean
    pick_up_lat: string
    drop_off_lat: string
    pick_up_lon: string
    drop_off_lon: string
    service_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type airport_servicesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_dropoff?: BoolFieldUpdateOperationsInput | boolean
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    pickup_from?: StringFieldUpdateOperationsInput | string
    dropoff_location?: StringFieldUpdateOperationsInput | string
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    pick_up_lat?: StringFieldUpdateOperationsInput | string
    drop_off_lat?: StringFieldUpdateOperationsInput | string
    pick_up_lon?: StringFieldUpdateOperationsInput | string
    drop_off_lon?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: servicesUpdateOneRequiredWithoutAirport_servicesNestedInput
  }

  export type airport_servicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_dropoff?: BoolFieldUpdateOperationsInput | boolean
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    pickup_from?: StringFieldUpdateOperationsInput | string
    dropoff_location?: StringFieldUpdateOperationsInput | string
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    pick_up_lat?: StringFieldUpdateOperationsInput | string
    drop_off_lat?: StringFieldUpdateOperationsInput | string
    pick_up_lon?: StringFieldUpdateOperationsInput | string
    drop_off_lon?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type airport_servicesCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    pickup_dropoff: boolean
    pickup_date_time: Date | string
    num_passengers: number
    pickup_from: string
    dropoff_location: string
    airline?: string | null
    flight_number?: string | null
    status?: boolean
    pick_up_lat: string
    drop_off_lat: string
    pick_up_lon: string
    drop_off_lon: string
    service_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type airport_servicesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_dropoff?: BoolFieldUpdateOperationsInput | boolean
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    pickup_from?: StringFieldUpdateOperationsInput | string
    dropoff_location?: StringFieldUpdateOperationsInput | string
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    pick_up_lat?: StringFieldUpdateOperationsInput | string
    drop_off_lat?: StringFieldUpdateOperationsInput | string
    pick_up_lon?: StringFieldUpdateOperationsInput | string
    drop_off_lon?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type airport_servicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_dropoff?: BoolFieldUpdateOperationsInput | boolean
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    pickup_from?: StringFieldUpdateOperationsInput | string
    dropoff_location?: StringFieldUpdateOperationsInput | string
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    pick_up_lat?: StringFieldUpdateOperationsInput | string
    drop_off_lat?: StringFieldUpdateOperationsInput | string
    pick_up_lon?: StringFieldUpdateOperationsInput | string
    drop_off_lon?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type airportsCreateInput = {
    name?: string | null
    city?: string | null
    country?: string | null
    iata?: string | null
    icao?: string | null
    latitude?: string | null
    longitude?: string | null
    altitude?: string | null
    timezone?: string | null
    dst?: string | null
    tz_database_time_zone?: string | null
    Type?: string | null
    Source?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type airportsUncheckedCreateInput = {
    id?: number
    name?: string | null
    city?: string | null
    country?: string | null
    iata?: string | null
    icao?: string | null
    latitude?: string | null
    longitude?: string | null
    altitude?: string | null
    timezone?: string | null
    dst?: string | null
    tz_database_time_zone?: string | null
    Type?: string | null
    Source?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type airportsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    iata?: NullableStringFieldUpdateOperationsInput | string | null
    icao?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    altitude?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dst?: NullableStringFieldUpdateOperationsInput | string | null
    tz_database_time_zone?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type airportsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    iata?: NullableStringFieldUpdateOperationsInput | string | null
    icao?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    altitude?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dst?: NullableStringFieldUpdateOperationsInput | string | null
    tz_database_time_zone?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type airportsCreateManyInput = {
    id?: number
    name?: string | null
    city?: string | null
    country?: string | null
    iata?: string | null
    icao?: string | null
    latitude?: string | null
    longitude?: string | null
    altitude?: string | null
    timezone?: string | null
    dst?: string | null
    tz_database_time_zone?: string | null
    Type?: string | null
    Source?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type airportsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    iata?: NullableStringFieldUpdateOperationsInput | string | null
    icao?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    altitude?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dst?: NullableStringFieldUpdateOperationsInput | string | null
    tz_database_time_zone?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type airportsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    iata?: NullableStringFieldUpdateOperationsInput | string | null
    icao?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    altitude?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    dst?: NullableStringFieldUpdateOperationsInput | string | null
    tz_database_time_zone?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blog_categoriesCreateInput = {
    title: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type blog_categoriesUncheckedCreateInput = {
    id?: number
    title: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type blog_categoriesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blog_categoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blog_categoriesCreateManyInput = {
    id?: number
    title: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type blog_categoriesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blog_categoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blog_commentsCreateInput = {
    blog_id: number
    name: string
    email: string
    website?: string | null
    comment: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type blog_commentsUncheckedCreateInput = {
    id?: number
    blog_id: number
    name: string
    email: string
    website?: string | null
    comment: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type blog_commentsUpdateInput = {
    blog_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blog_commentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    blog_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blog_commentsCreateManyInput = {
    id?: number
    blog_id: number
    name: string
    email: string
    website?: string | null
    comment: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type blog_commentsUpdateManyMutationInput = {
    blog_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blog_commentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    blog_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blogsCreateInput = {
    blog_category_id: number
    user_id: number
    title: string
    slug?: string | null
    content: string
    image?: string | null
    views?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type blogsUncheckedCreateInput = {
    id?: number
    blog_category_id: number
    user_id: number
    title: string
    slug?: string | null
    content: string
    image?: string | null
    views?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type blogsUpdateInput = {
    blog_category_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blogsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    blog_category_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blogsCreateManyInput = {
    id?: number
    blog_category_id: number
    user_id: number
    title: string
    slug?: string | null
    content: string
    image?: string | null
    views?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type blogsUpdateManyMutationInput = {
    blog_category_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blogsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    blog_category_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type body_typesCreateInput = {
    body_type?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars?: carsCreateNestedManyWithoutBody_typesInput
  }

  export type body_typesUncheckedCreateInput = {
    id?: number
    body_type?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars?: carsUncheckedCreateNestedManyWithoutBody_typesInput
  }

  export type body_typesUpdateInput = {
    body_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUpdateManyWithoutBody_typesNestedInput
  }

  export type body_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUncheckedUpdateManyWithoutBody_typesNestedInput
  }

  export type body_typesCreateManyInput = {
    id?: number
    body_type?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type body_typesUpdateManyMutationInput = {
    body_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type body_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type car_featuresCreateInput = {
    car_id: number
    feature_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type car_featuresUncheckedCreateInput = {
    id?: number
    car_id: number
    feature_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type car_featuresUpdateInput = {
    car_id?: IntFieldUpdateOperationsInput | number
    feature_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type car_featuresUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    car_id?: IntFieldUpdateOperationsInput | number
    feature_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type car_featuresCreateManyInput = {
    id?: number
    car_id: number
    feature_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type car_featuresUpdateManyMutationInput = {
    car_id?: IntFieldUpdateOperationsInput | number
    feature_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type car_featuresUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    car_id?: IntFieldUpdateOperationsInput | number
    feature_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type car_price_typesCreateInput = {
    name?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    car_prices?: car_pricesCreateNestedManyWithoutCar_price_typesInput
  }

  export type car_price_typesUncheckedCreateInput = {
    id?: number
    name?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    car_prices?: car_pricesUncheckedCreateNestedManyWithoutCar_price_typesInput
  }

  export type car_price_typesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    car_prices?: car_pricesUpdateManyWithoutCar_price_typesNestedInput
  }

  export type car_price_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    car_prices?: car_pricesUncheckedUpdateManyWithoutCar_price_typesNestedInput
  }

  export type car_price_typesCreateManyInput = {
    id?: number
    name?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type car_price_typesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type car_price_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type car_pricesCreateInput = {
    monday?: number | null
    tuesday?: number | null
    wednesday?: number | null
    thursday?: number | null
    friday?: number | null
    saturday?: number | null
    sunday?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars: carsCreateNestedOneWithoutCar_pricesInput
    car_price_types: car_price_typesCreateNestedOneWithoutCar_pricesInput
  }

  export type car_pricesUncheckedCreateInput = {
    id?: number
    car_id: number
    car_price_type_id: number
    monday?: number | null
    tuesday?: number | null
    wednesday?: number | null
    thursday?: number | null
    friday?: number | null
    saturday?: number | null
    sunday?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type car_pricesUpdateInput = {
    monday?: NullableIntFieldUpdateOperationsInput | number | null
    tuesday?: NullableIntFieldUpdateOperationsInput | number | null
    wednesday?: NullableIntFieldUpdateOperationsInput | number | null
    thursday?: NullableIntFieldUpdateOperationsInput | number | null
    friday?: NullableIntFieldUpdateOperationsInput | number | null
    saturday?: NullableIntFieldUpdateOperationsInput | number | null
    sunday?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUpdateOneRequiredWithoutCar_pricesNestedInput
    car_price_types?: car_price_typesUpdateOneRequiredWithoutCar_pricesNestedInput
  }

  export type car_pricesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    car_id?: IntFieldUpdateOperationsInput | number
    car_price_type_id?: IntFieldUpdateOperationsInput | number
    monday?: NullableIntFieldUpdateOperationsInput | number | null
    tuesday?: NullableIntFieldUpdateOperationsInput | number | null
    wednesday?: NullableIntFieldUpdateOperationsInput | number | null
    thursday?: NullableIntFieldUpdateOperationsInput | number | null
    friday?: NullableIntFieldUpdateOperationsInput | number | null
    saturday?: NullableIntFieldUpdateOperationsInput | number | null
    sunday?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type car_pricesCreateManyInput = {
    id?: number
    car_id: number
    car_price_type_id: number
    monday?: number | null
    tuesday?: number | null
    wednesday?: number | null
    thursday?: number | null
    friday?: number | null
    saturday?: number | null
    sunday?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type car_pricesUpdateManyMutationInput = {
    monday?: NullableIntFieldUpdateOperationsInput | number | null
    tuesday?: NullableIntFieldUpdateOperationsInput | number | null
    wednesday?: NullableIntFieldUpdateOperationsInput | number | null
    thursday?: NullableIntFieldUpdateOperationsInput | number | null
    friday?: NullableIntFieldUpdateOperationsInput | number | null
    saturday?: NullableIntFieldUpdateOperationsInput | number | null
    sunday?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type car_pricesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    car_id?: IntFieldUpdateOperationsInput | number
    car_price_type_id?: IntFieldUpdateOperationsInput | number
    monday?: NullableIntFieldUpdateOperationsInput | number | null
    tuesday?: NullableIntFieldUpdateOperationsInput | number | null
    wednesday?: NullableIntFieldUpdateOperationsInput | number | null
    thursday?: NullableIntFieldUpdateOperationsInput | number | null
    friday?: NullableIntFieldUpdateOperationsInput | number | null
    saturday?: NullableIntFieldUpdateOperationsInput | number | null
    sunday?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type carsCreateInput = {
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesCreateNestedManyWithoutCarsInput
    body_types: body_typesCreateNestedOneWithoutCarsInput
    drivers: driversCreateNestedOneWithoutCarsInput
    fuel_types: fuel_typesCreateNestedOneWithoutCarsInput
    manufacturers: manufacturersCreateNestedOneWithoutCarsInput
    transmissions: transmissionsCreateNestedOneWithoutCarsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutCarsInput
    package_serivce?: package_serivceCreateNestedManyWithoutCarsInput
    reservations?: reservationsCreateNestedManyWithoutCarsInput
    slabs?: slabsCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesCreateNestedManyWithoutCarsInput
    tours?: toursCreateNestedManyWithoutCarsInput
  }

  export type carsUncheckedCreateInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesUncheckedCreateNestedManyWithoutCarsInput
    package_serivce?: package_serivceUncheckedCreateNestedManyWithoutCarsInput
    reservations?: reservationsUncheckedCreateNestedManyWithoutCarsInput
    slabs?: slabsUncheckedCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutCarsInput
    tours?: toursUncheckedCreateNestedManyWithoutCarsInput
  }

  export type carsUpdateInput = {
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUpdateManyWithoutCarsNestedInput
    body_types?: body_typesUpdateOneRequiredWithoutCarsNestedInput
    drivers?: driversUpdateOneRequiredWithoutCarsNestedInput
    fuel_types?: fuel_typesUpdateOneRequiredWithoutCarsNestedInput
    manufacturers?: manufacturersUpdateOneRequiredWithoutCarsNestedInput
    transmissions?: transmissionsUpdateOneRequiredWithoutCarsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutCarsNestedInput
    package_serivce?: package_serivceUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUpdateManyWithoutCarsNestedInput
    slabs?: slabsUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUpdateManyWithoutCarsNestedInput
    tours?: toursUpdateManyWithoutCarsNestedInput
  }

  export type carsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type_id?: IntFieldUpdateOperationsInput | number
    transmission_id?: IntFieldUpdateOperationsInput | number
    manufacturer_id?: IntFieldUpdateOperationsInput | number
    driver_id?: IntFieldUpdateOperationsInput | number
    fuel_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUncheckedUpdateManyWithoutCarsNestedInput
    package_serivce?: package_serivceUncheckedUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUncheckedUpdateManyWithoutCarsNestedInput
    slabs?: slabsUncheckedUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutCarsNestedInput
    tours?: toursUncheckedUpdateManyWithoutCarsNestedInput
  }

  export type carsCreateManyInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
  }

  export type carsUpdateManyMutationInput = {
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
  }

  export type carsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type_id?: IntFieldUpdateOperationsInput | number
    transmission_id?: IntFieldUpdateOperationsInput | number
    manufacturer_id?: IntFieldUpdateOperationsInput | number
    driver_id?: IntFieldUpdateOperationsInput | number
    fuel_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
  }

  export type city_toursCreateInput = {
    city_name: string
    pick_up_location: string
    Created_on?: Date | string
  }

  export type city_toursUncheckedCreateInput = {
    id?: number
    city_name: string
    pick_up_location: string
    Created_on?: Date | string
  }

  export type city_toursUpdateInput = {
    city_name?: StringFieldUpdateOperationsInput | string
    pick_up_location?: StringFieldUpdateOperationsInput | string
    Created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type city_toursUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    city_name?: StringFieldUpdateOperationsInput | string
    pick_up_location?: StringFieldUpdateOperationsInput | string
    Created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type city_toursCreateManyInput = {
    id?: number
    city_name: string
    pick_up_location: string
    Created_on?: Date | string
  }

  export type city_toursUpdateManyMutationInput = {
    city_name?: StringFieldUpdateOperationsInput | string
    pick_up_location?: StringFieldUpdateOperationsInput | string
    Created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type city_toursUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    city_name?: StringFieldUpdateOperationsInput | string
    pick_up_location?: StringFieldUpdateOperationsInput | string
    Created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type countriesCreateInput = {
    sortname: string
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type countriesUncheckedCreateInput = {
    id?: number
    sortname: string
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type countriesUpdateInput = {
    sortname?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type countriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sortname?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type countriesCreateManyInput = {
    id?: number
    sortname: string
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type countriesUpdateManyMutationInput = {
    sortname?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type countriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sortname?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type couponsCreateInput = {
    coupon_name?: string | null
    percentage?: number | null
    price?: number | null
    status: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type couponsUncheckedCreateInput = {
    id?: number
    coupon_name?: string | null
    percentage?: number | null
    price?: number | null
    status: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type couponsUpdateInput = {
    coupon_name?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type couponsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    coupon_name?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type couponsCreateManyInput = {
    id?: number
    coupon_name?: string | null
    percentage?: number | null
    price?: number | null
    status: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type couponsUpdateManyMutationInput = {
    coupon_name?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type couponsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    coupon_name?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type datatablesCreateInput = {
    firstname?: string | null
    lastname?: string | null
    email?: string | null
    points?: string | null
    notes?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    age?: number | null
    job?: string | null
    gender?: string | null
    country?: string | null
    sale_date?: string | null
  }

  export type datatablesUncheckedCreateInput = {
    id?: number
    firstname?: string | null
    lastname?: string | null
    email?: string | null
    points?: string | null
    notes?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    age?: number | null
    job?: string | null
    gender?: string | null
    country?: string | null
    sale_date?: string | null
  }

  export type datatablesUpdateInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    job?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    sale_date?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type datatablesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    job?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    sale_date?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type datatablesCreateManyInput = {
    id?: number
    firstname?: string | null
    lastname?: string | null
    email?: string | null
    points?: string | null
    notes?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    age?: number | null
    job?: string | null
    gender?: string | null
    country?: string | null
    sale_date?: string | null
  }

  export type datatablesUpdateManyMutationInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    job?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    sale_date?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type datatablesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    job?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    sale_date?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type driversCreateInput = {
    name?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars?: carsCreateNestedManyWithoutDriversInput
  }

  export type driversUncheckedCreateInput = {
    id?: number
    name?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars?: carsUncheckedCreateNestedManyWithoutDriversInput
  }

  export type driversUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUpdateManyWithoutDriversNestedInput
  }

  export type driversUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type driversCreateManyInput = {
    id?: number
    name?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type driversUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type driversUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type featuresCreateInput = {
    feature?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type featuresUncheckedCreateInput = {
    id?: number
    feature?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type featuresUpdateInput = {
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type featuresUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type featuresCreateManyInput = {
    id?: number
    feature?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type featuresUpdateManyMutationInput = {
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type featuresUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type filesCreateInput = {
    filename: string
    mime: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type filesUncheckedCreateInput = {
    id?: number
    filename: string
    mime: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type filesUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type filesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type filesCreateManyInput = {
    id?: number
    filename: string
    mime: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type filesUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type filesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type fuel_typesCreateInput = {
    fuel_type?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars?: carsCreateNestedManyWithoutFuel_typesInput
  }

  export type fuel_typesUncheckedCreateInput = {
    id?: number
    fuel_type?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars?: carsUncheckedCreateNestedManyWithoutFuel_typesInput
  }

  export type fuel_typesUpdateInput = {
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUpdateManyWithoutFuel_typesNestedInput
  }

  export type fuel_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUncheckedUpdateManyWithoutFuel_typesNestedInput
  }

  export type fuel_typesCreateManyInput = {
    id?: number
    fuel_type?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type fuel_typesUpdateManyMutationInput = {
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type fuel_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gratuitiesCreateInput = {
    percentage?: number | null
    status?: boolean | null
    name?: string | null
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    services: servicesCreateNestedOneWithoutGratuitiesInput
  }

  export type gratuitiesUncheckedCreateInput = {
    id?: number
    percentage?: number | null
    status?: boolean | null
    name?: string | null
    price: number
    service_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type gratuitiesUpdateInput = {
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: servicesUpdateOneRequiredWithoutGratuitiesNestedInput
  }

  export type gratuitiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gratuitiesCreateManyInput = {
    id?: number
    percentage?: number | null
    status?: boolean | null
    name?: string | null
    price: number
    service_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type gratuitiesUpdateManyMutationInput = {
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gratuitiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hourly_servicesCreateInput = {
    name: string
    description?: string | null
    pickup_location: string
    pickup_date_time: Date | string
    num_passengers: number
    num_service_hours: number
    dropoff_location: string
    add_another_stop?: boolean
    additional_comments?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    services: servicesCreateNestedOneWithoutHourly_servicesInput
  }

  export type hourly_servicesUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    pickup_location: string
    pickup_date_time: Date | string
    num_passengers: number
    num_service_hours: number
    dropoff_location: string
    add_another_stop?: boolean
    additional_comments?: string | null
    status?: boolean
    service_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type hourly_servicesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: StringFieldUpdateOperationsInput | string
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    num_service_hours?: IntFieldUpdateOperationsInput | number
    dropoff_location?: StringFieldUpdateOperationsInput | string
    add_another_stop?: BoolFieldUpdateOperationsInput | boolean
    additional_comments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: servicesUpdateOneRequiredWithoutHourly_servicesNestedInput
  }

  export type hourly_servicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: StringFieldUpdateOperationsInput | string
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    num_service_hours?: IntFieldUpdateOperationsInput | number
    dropoff_location?: StringFieldUpdateOperationsInput | string
    add_another_stop?: BoolFieldUpdateOperationsInput | boolean
    additional_comments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hourly_servicesCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    pickup_location: string
    pickup_date_time: Date | string
    num_passengers: number
    num_service_hours: number
    dropoff_location: string
    add_another_stop?: boolean
    additional_comments?: string | null
    status?: boolean
    service_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type hourly_servicesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: StringFieldUpdateOperationsInput | string
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    num_service_hours?: IntFieldUpdateOperationsInput | number
    dropoff_location?: StringFieldUpdateOperationsInput | string
    add_another_stop?: BoolFieldUpdateOperationsInput | boolean
    additional_comments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hourly_servicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: StringFieldUpdateOperationsInput | string
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    num_service_hours?: IntFieldUpdateOperationsInput | number
    dropoff_location?: StringFieldUpdateOperationsInput | string
    add_another_stop?: BoolFieldUpdateOperationsInput | boolean
    additional_comments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type locationsCreateInput = {
    title?: string | null
    pickup_location?: string | null
    pickup_lat?: string | null
    pickup_lng?: string | null
    dropoff_location?: string | null
    dropoff_lat?: string | null
    dropoff_lng?: string | null
    fee?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type locationsUncheckedCreateInput = {
    id?: number
    title?: string | null
    pickup_location?: string | null
    pickup_lat?: string | null
    pickup_lng?: string | null
    dropoff_location?: string | null
    dropoff_lat?: string | null
    dropoff_lng?: string | null
    fee?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type locationsUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lng?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lng?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type locationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lng?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lng?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type locationsCreateManyInput = {
    id?: number
    title?: string | null
    pickup_location?: string | null
    pickup_lat?: string | null
    pickup_lng?: string | null
    dropoff_location?: string | null
    dropoff_lat?: string | null
    dropoff_lng?: string | null
    fee?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type locationsUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lng?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lng?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type locationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lng?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lng?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type manufacturersCreateInput = {
    Manufacturer?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars?: carsCreateNestedManyWithoutManufacturersInput
  }

  export type manufacturersUncheckedCreateInput = {
    id?: number
    Manufacturer?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars?: carsUncheckedCreateNestedManyWithoutManufacturersInput
  }

  export type manufacturersUpdateInput = {
    Manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUpdateManyWithoutManufacturersNestedInput
  }

  export type manufacturersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUncheckedUpdateManyWithoutManufacturersNestedInput
  }

  export type manufacturersCreateManyInput = {
    id?: number
    Manufacturer?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type manufacturersUpdateManyMutationInput = {
    Manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type manufacturersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type migrationsCreateInput = {
    migration: string
    batch: number
  }

  export type migrationsUncheckedCreateInput = {
    id?: number
    migration: string
    batch: number
  }

  export type migrationsUpdateInput = {
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsCreateManyInput = {
    id?: number
    migration: string
    batch: number
  }

  export type migrationsUpdateManyMutationInput = {
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type package_typesCreateInput = {
    name: string
    password: string
    Created_on?: Date | string
  }

  export type package_typesUncheckedCreateInput = {
    id?: number
    name: string
    password: string
    Created_on?: Date | string
  }

  export type package_typesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    Created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type package_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    Created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type package_typesCreateManyInput = {
    id?: number
    name: string
    password: string
    Created_on?: Date | string
  }

  export type package_typesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    Created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type package_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    Created_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type persistencesCreateInput = {
    user_id: number
    code: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type persistencesUncheckedCreateInput = {
    id?: number
    user_id: number
    code: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type persistencesUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type persistencesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type persistencesCreateManyInput = {
    id?: number
    user_id: number
    code: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type persistencesUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type persistencesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type point_to_point_servicesCreateInput = {
    name: string
    description?: string | null
    pickup_location: string
    pickup_date_time: Date | string
    num_passengers: number
    dropoff_location: string
    add_another_stop?: boolean
    additional_comments?: string | null
    status?: boolean
    pick_up_lat: string
    pick_up_lon: string
    drop_off_lat: string
    drop_off_lon: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    services: servicesCreateNestedOneWithoutPoint_to_point_servicesInput
  }

  export type point_to_point_servicesUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    pickup_location: string
    pickup_date_time: Date | string
    num_passengers: number
    dropoff_location: string
    add_another_stop?: boolean
    additional_comments?: string | null
    status?: boolean
    pick_up_lat: string
    pick_up_lon: string
    drop_off_lat: string
    drop_off_lon: string
    service_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type point_to_point_servicesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: StringFieldUpdateOperationsInput | string
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    dropoff_location?: StringFieldUpdateOperationsInput | string
    add_another_stop?: BoolFieldUpdateOperationsInput | boolean
    additional_comments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    pick_up_lat?: StringFieldUpdateOperationsInput | string
    pick_up_lon?: StringFieldUpdateOperationsInput | string
    drop_off_lat?: StringFieldUpdateOperationsInput | string
    drop_off_lon?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: servicesUpdateOneRequiredWithoutPoint_to_point_servicesNestedInput
  }

  export type point_to_point_servicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: StringFieldUpdateOperationsInput | string
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    dropoff_location?: StringFieldUpdateOperationsInput | string
    add_another_stop?: BoolFieldUpdateOperationsInput | boolean
    additional_comments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    pick_up_lat?: StringFieldUpdateOperationsInput | string
    pick_up_lon?: StringFieldUpdateOperationsInput | string
    drop_off_lat?: StringFieldUpdateOperationsInput | string
    drop_off_lon?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type point_to_point_servicesCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    pickup_location: string
    pickup_date_time: Date | string
    num_passengers: number
    dropoff_location: string
    add_another_stop?: boolean
    additional_comments?: string | null
    status?: boolean
    pick_up_lat: string
    pick_up_lon: string
    drop_off_lat: string
    drop_off_lon: string
    service_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type point_to_point_servicesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: StringFieldUpdateOperationsInput | string
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    dropoff_location?: StringFieldUpdateOperationsInput | string
    add_another_stop?: BoolFieldUpdateOperationsInput | boolean
    additional_comments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    pick_up_lat?: StringFieldUpdateOperationsInput | string
    pick_up_lon?: StringFieldUpdateOperationsInput | string
    drop_off_lat?: StringFieldUpdateOperationsInput | string
    drop_off_lon?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type point_to_point_servicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: StringFieldUpdateOperationsInput | string
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    dropoff_location?: StringFieldUpdateOperationsInput | string
    add_another_stop?: BoolFieldUpdateOperationsInput | boolean
    additional_comments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    pick_up_lat?: StringFieldUpdateOperationsInput | string
    pick_up_lon?: StringFieldUpdateOperationsInput | string
    drop_off_lat?: StringFieldUpdateOperationsInput | string
    drop_off_lon?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type remindersCreateInput = {
    user_id: number
    code: string
    completed?: boolean
    completed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type remindersUncheckedCreateInput = {
    id?: number
    user_id: number
    code: string
    completed?: boolean
    completed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type remindersUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type remindersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type remindersCreateManyInput = {
    id?: number
    user_id: number
    code: string
    completed?: boolean
    completed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type remindersUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type remindersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reservationsCreateInput = {
    order_number?: string | null
    pick_up_postal_code?: string | null
    pick_up_lat?: number | null
    pick_up_lon?: number | null
    pick_up_loc_name?: string | null
    drop_off_postal_code?: string | null
    drop_off_lat?: number | null
    drop_off_lon?: number | null
    drop_off_loc_name?: string | null
    pick_up_date?: Date | string | null
    price?: number | null
    tax?: number | null
    airline?: string | null
    flight_no?: string | null
    no_of_hours?: number | null
    maximum_passenger?: number | null
    maximum_luggage?: number | null
    customer_first_name?: string | null
    customer_last_name?: string | null
    customer_cnic?: string | null
    customer_email?: string | null
    customer_phone?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    uuid?: string
    payment_method?: string | null
    isPaid?: number | null
    special_instruction?: string | null
    cars: carsCreateNestedOneWithoutReservationsInput
    sub_services: sub_servicesCreateNestedOneWithoutReservationsInput
  }

  export type reservationsUncheckedCreateInput = {
    id?: number
    order_number?: string | null
    service_id: number
    car_id: number
    pick_up_postal_code?: string | null
    pick_up_lat?: number | null
    pick_up_lon?: number | null
    pick_up_loc_name?: string | null
    drop_off_postal_code?: string | null
    drop_off_lat?: number | null
    drop_off_lon?: number | null
    drop_off_loc_name?: string | null
    pick_up_date?: Date | string | null
    price?: number | null
    tax?: number | null
    airline?: string | null
    flight_no?: string | null
    no_of_hours?: number | null
    maximum_passenger?: number | null
    maximum_luggage?: number | null
    customer_first_name?: string | null
    customer_last_name?: string | null
    customer_cnic?: string | null
    customer_email?: string | null
    customer_phone?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    uuid?: string
    payment_method?: string | null
    isPaid?: number | null
    special_instruction?: string | null
  }

  export type reservationsUpdateInput = {
    order_number?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_no?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_hours?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    customer_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_cnic?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: NullableIntFieldUpdateOperationsInput | number | null
    special_instruction?: NullableStringFieldUpdateOperationsInput | string | null
    cars?: carsUpdateOneRequiredWithoutReservationsNestedInput
    sub_services?: sub_servicesUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type reservationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_number?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: IntFieldUpdateOperationsInput | number
    car_id?: IntFieldUpdateOperationsInput | number
    pick_up_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_no?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_hours?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    customer_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_cnic?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: NullableIntFieldUpdateOperationsInput | number | null
    special_instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reservationsCreateManyInput = {
    id?: number
    order_number?: string | null
    service_id: number
    car_id: number
    pick_up_postal_code?: string | null
    pick_up_lat?: number | null
    pick_up_lon?: number | null
    pick_up_loc_name?: string | null
    drop_off_postal_code?: string | null
    drop_off_lat?: number | null
    drop_off_lon?: number | null
    drop_off_loc_name?: string | null
    pick_up_date?: Date | string | null
    price?: number | null
    tax?: number | null
    airline?: string | null
    flight_no?: string | null
    no_of_hours?: number | null
    maximum_passenger?: number | null
    maximum_luggage?: number | null
    customer_first_name?: string | null
    customer_last_name?: string | null
    customer_cnic?: string | null
    customer_email?: string | null
    customer_phone?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    uuid?: string
    payment_method?: string | null
    isPaid?: number | null
    special_instruction?: string | null
  }

  export type reservationsUpdateManyMutationInput = {
    order_number?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_no?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_hours?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    customer_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_cnic?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: NullableIntFieldUpdateOperationsInput | number | null
    special_instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reservationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_number?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: IntFieldUpdateOperationsInput | number
    car_id?: IntFieldUpdateOperationsInput | number
    pick_up_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_no?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_hours?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    customer_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_cnic?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: NullableIntFieldUpdateOperationsInput | number | null
    special_instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type role_usersCreateInput = {
    created_at?: Date | string | null
    updated_at?: Date | string | null
    roles: rolesCreateNestedOneWithoutRole_usersInput
    users: usersCreateNestedOneWithoutRole_usersInput
  }

  export type role_usersUncheckedCreateInput = {
    user_id: number
    role_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type role_usersUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles?: rolesUpdateOneRequiredWithoutRole_usersNestedInput
    users?: usersUpdateOneRequiredWithoutRole_usersNestedInput
  }

  export type role_usersUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type role_usersCreateManyInput = {
    user_id: number
    role_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type role_usersUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type role_usersUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesCreateInput = {
    slug: string
    name: string
    permissions?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    role_users?: role_usersCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    id?: number
    slug: string
    name: string
    permissions?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    role_users?: role_usersUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_users?: role_usersUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_users?: role_usersUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    id?: number
    slug: string
    name: string
    permissions?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type rolesUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type servicesCreateInput = {
    Name?: string | null
    Status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    airport_services?: airport_servicesCreateNestedManyWithoutServicesInput
    gratuities?: gratuitiesCreateNestedManyWithoutServicesInput
    hourly_services?: hourly_servicesCreateNestedManyWithoutServicesInput
    point_to_point_services?: point_to_point_servicesCreateNestedManyWithoutServicesInput
    sub_services?: sub_servicesCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateInput = {
    id?: number
    Name?: string | null
    Status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    airport_services?: airport_servicesUncheckedCreateNestedManyWithoutServicesInput
    gratuities?: gratuitiesUncheckedCreateNestedManyWithoutServicesInput
    hourly_services?: hourly_servicesUncheckedCreateNestedManyWithoutServicesInput
    point_to_point_services?: point_to_point_servicesUncheckedCreateNestedManyWithoutServicesInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesUpdateInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    airport_services?: airport_servicesUpdateManyWithoutServicesNestedInput
    gratuities?: gratuitiesUpdateManyWithoutServicesNestedInput
    hourly_services?: hourly_servicesUpdateManyWithoutServicesNestedInput
    point_to_point_services?: point_to_point_servicesUpdateManyWithoutServicesNestedInput
    sub_services?: sub_servicesUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    airport_services?: airport_servicesUncheckedUpdateManyWithoutServicesNestedInput
    gratuities?: gratuitiesUncheckedUpdateManyWithoutServicesNestedInput
    hourly_services?: hourly_servicesUncheckedUpdateManyWithoutServicesNestedInput
    point_to_point_services?: point_to_point_servicesUncheckedUpdateManyWithoutServicesNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type servicesCreateManyInput = {
    id?: number
    Name?: string | null
    Status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type servicesUpdateManyMutationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type servicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sys_settingsCreateInput = {
    sys_name: string
    sys_details: string
    Created_on?: Date | string
    setting_key: string
  }

  export type sys_settingsUncheckedCreateInput = {
    id?: number
    sys_name: string
    sys_details: string
    Created_on?: Date | string
    setting_key: string
  }

  export type sys_settingsUpdateInput = {
    sys_name?: StringFieldUpdateOperationsInput | string
    sys_details?: StringFieldUpdateOperationsInput | string
    Created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_key?: StringFieldUpdateOperationsInput | string
  }

  export type sys_settingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sys_name?: StringFieldUpdateOperationsInput | string
    sys_details?: StringFieldUpdateOperationsInput | string
    Created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_key?: StringFieldUpdateOperationsInput | string
  }

  export type sys_settingsCreateManyInput = {
    id?: number
    sys_name: string
    sys_details: string
    Created_on?: Date | string
    setting_key: string
  }

  export type sys_settingsUpdateManyMutationInput = {
    sys_name?: StringFieldUpdateOperationsInput | string
    sys_details?: StringFieldUpdateOperationsInput | string
    Created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_key?: StringFieldUpdateOperationsInput | string
  }

  export type sys_settingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sys_name?: StringFieldUpdateOperationsInput | string
    sys_details?: StringFieldUpdateOperationsInput | string
    Created_on?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_key?: StringFieldUpdateOperationsInput | string
  }

  export type taggable_tagsCreateInput = {
    name: string
    normalized: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type taggable_tagsUncheckedCreateInput = {
    tag_id?: number
    name: string
    normalized: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type taggable_tagsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    normalized?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type taggable_tagsUncheckedUpdateInput = {
    tag_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    normalized?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type taggable_tagsCreateManyInput = {
    tag_id?: number
    name: string
    normalized: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type taggable_tagsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    normalized?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type taggable_tagsUncheckedUpdateManyInput = {
    tag_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    normalized?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tasksCreateInput = {
    user_id: number
    finished?: number
    task_description: string
    task_deadline: Date | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type tasksUncheckedCreateInput = {
    id?: number
    user_id: number
    finished?: number
    task_description: string
    task_deadline: Date | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type tasksUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    finished?: IntFieldUpdateOperationsInput | number
    task_description?: StringFieldUpdateOperationsInput | string
    task_deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tasksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    finished?: IntFieldUpdateOperationsInput | number
    task_description?: StringFieldUpdateOperationsInput | string
    task_deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tasksCreateManyInput = {
    id?: number
    user_id: number
    finished?: number
    task_description: string
    task_deadline: Date | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type tasksUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    finished?: IntFieldUpdateOperationsInput | number
    task_description?: StringFieldUpdateOperationsInput | string
    task_deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tasksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    finished?: IntFieldUpdateOperationsInput | number
    task_description?: StringFieldUpdateOperationsInput | string
    task_deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type throttleCreateInput = {
    user_id?: number | null
    type: string
    ip?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type throttleUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    type: string
    ip?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type throttleUpdateInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type throttleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type throttleCreateManyInput = {
    id?: number
    user_id?: number | null
    type: string
    ip?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type throttleUpdateManyMutationInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type throttleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type toursCreateInput = {
    title?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    description?: string | null
    luggage?: number | null
    cars?: carsCreateNestedOneWithoutToursInput
  }

  export type toursUncheckedCreateInput = {
    id?: number
    title?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_id?: number | null
    description?: string | null
    luggage?: number | null
  }

  export type toursUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    cars?: carsUpdateOneWithoutToursNestedInput
  }

  export type toursUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type toursCreateManyInput = {
    id?: number
    title?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_id?: number | null
    description?: string | null
    luggage?: number | null
  }

  export type toursUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type toursUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type transmissionsCreateInput = {
    transmission?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars?: carsCreateNestedManyWithoutTransmissionsInput
  }

  export type transmissionsUncheckedCreateInput = {
    id?: number
    transmission?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars?: carsUncheckedCreateNestedManyWithoutTransmissionsInput
  }

  export type transmissionsUpdateInput = {
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUpdateManyWithoutTransmissionsNestedInput
  }

  export type transmissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUncheckedUpdateManyWithoutTransmissionsNestedInput
  }

  export type transmissionsCreateManyInput = {
    id?: number
    transmission?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type transmissionsUpdateManyMutationInput = {
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transmissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    email: string
    password: string
    permissions?: string | null
    last_login?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    bio?: string | null
    gender?: string | null
    dob?: Date | string | null
    pic?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    address?: string | null
    postal?: string | null
    status?: boolean | null
    reset_token?: string | null
    token_expired_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    role_users?: role_usersCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    permissions?: string | null
    last_login?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    bio?: string | null
    gender?: string | null
    dob?: Date | string | null
    pic?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    address?: string | null
    postal?: string | null
    status?: boolean | null
    reset_token?: string | null
    token_expired_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    role_users?: role_usersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pic?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    token_expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_users?: role_usersUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pic?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    token_expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_users?: role_usersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    email: string
    password: string
    permissions?: string | null
    last_login?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    bio?: string | null
    gender?: string | null
    dob?: Date | string | null
    pic?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    address?: string | null
    postal?: string | null
    status?: boolean | null
    reset_token?: string | null
    token_expired_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pic?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    token_expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pic?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    token_expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type location_exceptionsCreateInput = {
    pick_up_loc_name?: string | null
    pick_up_postal_code: string
    drop_off_loc_name?: string | null
    drop_off_postal_code: string
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type location_exceptionsUncheckedCreateInput = {
    id?: number
    pick_up_loc_name?: string | null
    pick_up_postal_code: string
    drop_off_loc_name?: string | null
    drop_off_postal_code: string
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type location_exceptionsUpdateInput = {
    pick_up_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_postal_code?: StringFieldUpdateOperationsInput | string
    drop_off_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_postal_code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type location_exceptionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pick_up_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_postal_code?: StringFieldUpdateOperationsInput | string
    drop_off_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_postal_code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type location_exceptionsCreateManyInput = {
    id?: number
    pick_up_loc_name?: string | null
    pick_up_postal_code: string
    drop_off_loc_name?: string | null
    drop_off_postal_code: string
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type location_exceptionsUpdateManyMutationInput = {
    pick_up_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_postal_code?: StringFieldUpdateOperationsInput | string
    drop_off_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_postal_code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type location_exceptionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pick_up_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_postal_code?: StringFieldUpdateOperationsInput | string
    drop_off_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_postal_code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type package_serivceCreateInput = {
    name?: string | null
    description?: string | null
    passenger_capacity: number
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    luggage?: number | null
    cars: carsCreateNestedOneWithoutPackage_serivceInput
  }

  export type package_serivceUncheckedCreateInput = {
    id?: number
    name?: string | null
    description?: string | null
    passenger_capacity: number
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    car_id: number
    isActive?: boolean | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    luggage?: number | null
  }

  export type package_serivceUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_capacity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    cars?: carsUpdateOneRequiredWithoutPackage_serivceNestedInput
  }

  export type package_serivceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_capacity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    car_id?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type package_serivceCreateManyInput = {
    id?: number
    name?: string | null
    description?: string | null
    passenger_capacity: number
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    car_id: number
    isActive?: boolean | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    luggage?: number | null
  }

  export type package_serivceUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_capacity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type package_serivceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_capacity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    car_id?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type slabsCreateInput = {
    initial_distance: number
    final_distance: number
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars: carsCreateNestedOneWithoutSlabsInput
  }

  export type slabsUncheckedCreateInput = {
    id?: number
    car_id: number
    initial_distance: number
    final_distance: number
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type slabsUpdateInput = {
    initial_distance?: FloatFieldUpdateOperationsInput | number
    final_distance?: FloatFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUpdateOneRequiredWithoutSlabsNestedInput
  }

  export type slabsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    car_id?: IntFieldUpdateOperationsInput | number
    initial_distance?: FloatFieldUpdateOperationsInput | number
    final_distance?: FloatFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type slabsCreateManyInput = {
    id?: number
    car_id: number
    initial_distance: number
    final_distance: number
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type slabsUpdateManyMutationInput = {
    initial_distance?: FloatFieldUpdateOperationsInput | number
    final_distance?: FloatFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type slabsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    car_id?: IntFieldUpdateOperationsInput | number
    initial_distance?: FloatFieldUpdateOperationsInput | number
    final_distance?: FloatFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type timeslotsCreateInput = {
    time?: Date | string | null
    isActive?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    sub_services?: sub_servicesCreateNestedOneWithoutTimeslotsInput
  }

  export type timeslotsUncheckedCreateInput = {
    id?: number
    time?: Date | string | null
    isActive?: boolean | null
    sub_service_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type timeslotsUpdateInput = {
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_services?: sub_servicesUpdateOneWithoutTimeslotsNestedInput
  }

  export type timeslotsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sub_service_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type timeslotsCreateManyInput = {
    id?: number
    time?: Date | string | null
    isActive?: boolean | null
    sub_service_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type timeslotsUpdateManyMutationInput = {
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type timeslotsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sub_service_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_typesCreateInput = {
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars?: carsCreateNestedManyWithoutVehicle_typesInput
  }

  export type vehicle_typesUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars?: carsUncheckedCreateNestedManyWithoutVehicle_typesInput
  }

  export type vehicle_typesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUpdateManyWithoutVehicle_typesNestedInput
  }

  export type vehicle_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUncheckedUpdateManyWithoutVehicle_typesNestedInput
  }

  export type vehicle_typesCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type vehicle_typesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sub_servicesCreateInput = {
    name?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    description?: string | null
    luggage?: number | null
    passenger_capacity?: number | null
    reservations?: reservationsCreateNestedManyWithoutSub_servicesInput
    services: servicesCreateNestedOneWithoutSub_servicesInput
    cars?: carsCreateNestedOneWithoutSub_servicesInput
    timeslots?: timeslotsCreateNestedManyWithoutSub_servicesInput
  }

  export type sub_servicesUncheckedCreateInput = {
    id?: number
    name?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_id?: number | null
    service_id: number
    description?: string | null
    luggage?: number | null
    passenger_capacity?: number | null
    reservations?: reservationsUncheckedCreateNestedManyWithoutSub_servicesInput
    timeslots?: timeslotsUncheckedCreateNestedManyWithoutSub_servicesInput
  }

  export type sub_servicesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    passenger_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    reservations?: reservationsUpdateManyWithoutSub_servicesNestedInput
    services?: servicesUpdateOneRequiredWithoutSub_servicesNestedInput
    cars?: carsUpdateOneWithoutSub_servicesNestedInput
    timeslots?: timeslotsUpdateManyWithoutSub_servicesNestedInput
  }

  export type sub_servicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    passenger_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    reservations?: reservationsUncheckedUpdateManyWithoutSub_servicesNestedInput
    timeslots?: timeslotsUncheckedUpdateManyWithoutSub_servicesNestedInput
  }

  export type sub_servicesCreateManyInput = {
    id?: number
    name?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_id?: number | null
    service_id: number
    description?: string | null
    luggage?: number | null
    passenger_capacity?: number | null
  }

  export type sub_servicesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    passenger_capacity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type sub_servicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    passenger_capacity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type activationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type activationsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type activationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type activationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type activationsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type activity_logCountOrderByAggregateInput = {
    id?: SortOrder
    log_name?: SortOrder
    description?: SortOrder
    subject_id?: SortOrder
    subject_type?: SortOrder
    causer_id?: SortOrder
    causer_type?: SortOrder
    properties?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type activity_logAvgOrderByAggregateInput = {
    id?: SortOrder
    subject_id?: SortOrder
    causer_id?: SortOrder
  }

  export type activity_logMaxOrderByAggregateInput = {
    id?: SortOrder
    log_name?: SortOrder
    description?: SortOrder
    subject_id?: SortOrder
    subject_type?: SortOrder
    causer_id?: SortOrder
    causer_type?: SortOrder
    properties?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type activity_logMinOrderByAggregateInput = {
    id?: SortOrder
    log_name?: SortOrder
    description?: SortOrder
    subject_id?: SortOrder
    subject_type?: SortOrder
    causer_id?: SortOrder
    causer_type?: SortOrder
    properties?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type activity_logSumOrderByAggregateInput = {
    id?: SortOrder
    subject_id?: SortOrder
    causer_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type airlinesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    alias?: SortOrder
    iata?: SortOrder
    icao?: SortOrder
    callsign?: SortOrder
    country?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type airlinesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type airlinesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    alias?: SortOrder
    iata?: SortOrder
    icao?: SortOrder
    callsign?: SortOrder
    country?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type airlinesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    alias?: SortOrder
    iata?: SortOrder
    icao?: SortOrder
    callsign?: SortOrder
    country?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type airlinesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ServicesRelationFilter = {
    is?: servicesWhereInput
    isNot?: servicesWhereInput
  }

  export type airport_servicesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_dropoff?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    pickup_from?: SortOrder
    dropoff_location?: SortOrder
    airline?: SortOrder
    flight_number?: SortOrder
    status?: SortOrder
    pick_up_lat?: SortOrder
    drop_off_lat?: SortOrder
    pick_up_lon?: SortOrder
    drop_off_lon?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type airport_servicesAvgOrderByAggregateInput = {
    id?: SortOrder
    num_passengers?: SortOrder
    service_id?: SortOrder
  }

  export type airport_servicesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_dropoff?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    pickup_from?: SortOrder
    dropoff_location?: SortOrder
    airline?: SortOrder
    flight_number?: SortOrder
    status?: SortOrder
    pick_up_lat?: SortOrder
    drop_off_lat?: SortOrder
    pick_up_lon?: SortOrder
    drop_off_lon?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type airport_servicesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_dropoff?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    pickup_from?: SortOrder
    dropoff_location?: SortOrder
    airline?: SortOrder
    flight_number?: SortOrder
    status?: SortOrder
    pick_up_lat?: SortOrder
    drop_off_lat?: SortOrder
    pick_up_lon?: SortOrder
    drop_off_lon?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type airport_servicesSumOrderByAggregateInput = {
    id?: SortOrder
    num_passengers?: SortOrder
    service_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type airportsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    country?: SortOrder
    iata?: SortOrder
    icao?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    altitude?: SortOrder
    timezone?: SortOrder
    dst?: SortOrder
    tz_database_time_zone?: SortOrder
    Type?: SortOrder
    Source?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type airportsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type airportsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    country?: SortOrder
    iata?: SortOrder
    icao?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    altitude?: SortOrder
    timezone?: SortOrder
    dst?: SortOrder
    tz_database_time_zone?: SortOrder
    Type?: SortOrder
    Source?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type airportsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    country?: SortOrder
    iata?: SortOrder
    icao?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    altitude?: SortOrder
    timezone?: SortOrder
    dst?: SortOrder
    tz_database_time_zone?: SortOrder
    Type?: SortOrder
    Source?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type airportsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type blog_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blog_categoriesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type blog_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blog_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blog_categoriesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type blog_commentsCountOrderByAggregateInput = {
    id?: SortOrder
    blog_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    website?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blog_commentsAvgOrderByAggregateInput = {
    id?: SortOrder
    blog_id?: SortOrder
  }

  export type blog_commentsMaxOrderByAggregateInput = {
    id?: SortOrder
    blog_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    website?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blog_commentsMinOrderByAggregateInput = {
    id?: SortOrder
    blog_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    website?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blog_commentsSumOrderByAggregateInput = {
    id?: SortOrder
    blog_id?: SortOrder
  }

  export type blogsCountOrderByAggregateInput = {
    id?: SortOrder
    blog_category_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    image?: SortOrder
    views?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blogsAvgOrderByAggregateInput = {
    id?: SortOrder
    blog_category_id?: SortOrder
    user_id?: SortOrder
    views?: SortOrder
  }

  export type blogsMaxOrderByAggregateInput = {
    id?: SortOrder
    blog_category_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    image?: SortOrder
    views?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blogsMinOrderByAggregateInput = {
    id?: SortOrder
    blog_category_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    image?: SortOrder
    views?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blogsSumOrderByAggregateInput = {
    id?: SortOrder
    blog_category_id?: SortOrder
    user_id?: SortOrder
    views?: SortOrder
  }

  export type CarsListRelationFilter = {
    every?: carsWhereInput
    some?: carsWhereInput
    none?: carsWhereInput
  }

  export type carsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type body_typesCountOrderByAggregateInput = {
    id?: SortOrder
    body_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type body_typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type body_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    body_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type body_typesMinOrderByAggregateInput = {
    id?: SortOrder
    body_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type body_typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type car_featuresCountOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    feature_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type car_featuresAvgOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    feature_id?: SortOrder
  }

  export type car_featuresMaxOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    feature_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type car_featuresMinOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    feature_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type car_featuresSumOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    feature_id?: SortOrder
  }

  export type Car_pricesListRelationFilter = {
    every?: car_pricesWhereInput
    some?: car_pricesWhereInput
    none?: car_pricesWhereInput
  }

  export type car_pricesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type car_price_typesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type car_price_typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type car_price_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type car_price_typesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type car_price_typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CarsRelationFilter = {
    is?: carsWhereInput
    isNot?: carsWhereInput
  }

  export type Car_price_typesRelationFilter = {
    is?: car_price_typesWhereInput
    isNot?: car_price_typesWhereInput
  }

  export type car_pricesCountOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    car_price_type_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type car_pricesAvgOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    car_price_type_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
  }

  export type car_pricesMaxOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    car_price_type_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type car_pricesMinOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    car_price_type_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type car_pricesSumOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    car_price_type_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type Enumcars_car_typeNullableFilter = {
    equals?: cars_car_type | null
    in?: Enumerable<cars_car_type> | null
    notIn?: Enumerable<cars_car_type> | null
    not?: NestedEnumcars_car_typeNullableFilter | cars_car_type | null
  }

  export type Body_typesRelationFilter = {
    is?: body_typesWhereInput
    isNot?: body_typesWhereInput
  }

  export type DriversRelationFilter = {
    is?: driversWhereInput
    isNot?: driversWhereInput
  }

  export type Fuel_typesRelationFilter = {
    is?: fuel_typesWhereInput
    isNot?: fuel_typesWhereInput
  }

  export type ManufacturersRelationFilter = {
    is?: manufacturersWhereInput
    isNot?: manufacturersWhereInput
  }

  export type TransmissionsRelationFilter = {
    is?: transmissionsWhereInput
    isNot?: transmissionsWhereInput
  }

  export type Vehicle_typesRelationFilter = {
    is?: vehicle_typesWhereInput
    isNot?: vehicle_typesWhereInput
  }

  export type Package_serivceListRelationFilter = {
    every?: package_serivceWhereInput
    some?: package_serivceWhereInput
    none?: package_serivceWhereInput
  }

  export type ReservationsListRelationFilter = {
    every?: reservationsWhereInput
    some?: reservationsWhereInput
    none?: reservationsWhereInput
  }

  export type SlabsListRelationFilter = {
    every?: slabsWhereInput
    some?: slabsWhereInput
    none?: slabsWhereInput
  }

  export type Sub_servicesListRelationFilter = {
    every?: sub_servicesWhereInput
    some?: sub_servicesWhereInput
    none?: sub_servicesWhereInput
  }

  export type ToursListRelationFilter = {
    every?: toursWhereInput
    some?: toursWhereInput
    none?: toursWhereInput
  }

  export type package_serivceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reservationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type slabsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sub_servicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type toursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type carsCountOrderByAggregateInput = {
    id?: SortOrder
    body_type_id?: SortOrder
    transmission_id?: SortOrder
    manufacturer_id?: SortOrder
    driver_id?: SortOrder
    fuel_id?: SortOrder
    vehicle_type_id?: SortOrder
    car_model?: SortOrder
    name?: SortOrder
    qty?: SortOrder
    passenger_seats?: SortOrder
    maximum_luggage?: SortOrder
    total_doors?: SortOrder
    child_seat?: SortOrder
    image?: SortOrder
    status?: SortOrder
    per_mile_rate?: SortOrder
    hourly_rate?: SortOrder
    minimum_fare?: SortOrder
    minimum_hours?: SortOrder
    fixed_price?: SortOrder
    is_slab_enabled?: SortOrder
    is_loc_enabled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_type?: SortOrder
  }

  export type carsAvgOrderByAggregateInput = {
    id?: SortOrder
    body_type_id?: SortOrder
    transmission_id?: SortOrder
    manufacturer_id?: SortOrder
    driver_id?: SortOrder
    fuel_id?: SortOrder
    vehicle_type_id?: SortOrder
    passenger_seats?: SortOrder
    maximum_luggage?: SortOrder
    total_doors?: SortOrder
    child_seat?: SortOrder
    per_mile_rate?: SortOrder
    hourly_rate?: SortOrder
    minimum_fare?: SortOrder
    minimum_hours?: SortOrder
    fixed_price?: SortOrder
  }

  export type carsMaxOrderByAggregateInput = {
    id?: SortOrder
    body_type_id?: SortOrder
    transmission_id?: SortOrder
    manufacturer_id?: SortOrder
    driver_id?: SortOrder
    fuel_id?: SortOrder
    vehicle_type_id?: SortOrder
    car_model?: SortOrder
    name?: SortOrder
    qty?: SortOrder
    passenger_seats?: SortOrder
    maximum_luggage?: SortOrder
    total_doors?: SortOrder
    child_seat?: SortOrder
    image?: SortOrder
    status?: SortOrder
    per_mile_rate?: SortOrder
    hourly_rate?: SortOrder
    minimum_fare?: SortOrder
    minimum_hours?: SortOrder
    fixed_price?: SortOrder
    is_slab_enabled?: SortOrder
    is_loc_enabled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_type?: SortOrder
  }

  export type carsMinOrderByAggregateInput = {
    id?: SortOrder
    body_type_id?: SortOrder
    transmission_id?: SortOrder
    manufacturer_id?: SortOrder
    driver_id?: SortOrder
    fuel_id?: SortOrder
    vehicle_type_id?: SortOrder
    car_model?: SortOrder
    name?: SortOrder
    qty?: SortOrder
    passenger_seats?: SortOrder
    maximum_luggage?: SortOrder
    total_doors?: SortOrder
    child_seat?: SortOrder
    image?: SortOrder
    status?: SortOrder
    per_mile_rate?: SortOrder
    hourly_rate?: SortOrder
    minimum_fare?: SortOrder
    minimum_hours?: SortOrder
    fixed_price?: SortOrder
    is_slab_enabled?: SortOrder
    is_loc_enabled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_type?: SortOrder
  }

  export type carsSumOrderByAggregateInput = {
    id?: SortOrder
    body_type_id?: SortOrder
    transmission_id?: SortOrder
    manufacturer_id?: SortOrder
    driver_id?: SortOrder
    fuel_id?: SortOrder
    vehicle_type_id?: SortOrder
    passenger_seats?: SortOrder
    maximum_luggage?: SortOrder
    total_doors?: SortOrder
    child_seat?: SortOrder
    per_mile_rate?: SortOrder
    hourly_rate?: SortOrder
    minimum_fare?: SortOrder
    minimum_hours?: SortOrder
    fixed_price?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type Enumcars_car_typeNullableWithAggregatesFilter = {
    equals?: cars_car_type | null
    in?: Enumerable<cars_car_type> | null
    notIn?: Enumerable<cars_car_type> | null
    not?: NestedEnumcars_car_typeNullableWithAggregatesFilter | cars_car_type | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumcars_car_typeNullableFilter
    _max?: NestedEnumcars_car_typeNullableFilter
  }

  export type city_toursCountOrderByAggregateInput = {
    id?: SortOrder
    city_name?: SortOrder
    pick_up_location?: SortOrder
    Created_on?: SortOrder
  }

  export type city_toursAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type city_toursMaxOrderByAggregateInput = {
    id?: SortOrder
    city_name?: SortOrder
    pick_up_location?: SortOrder
    Created_on?: SortOrder
  }

  export type city_toursMinOrderByAggregateInput = {
    id?: SortOrder
    city_name?: SortOrder
    pick_up_location?: SortOrder
    Created_on?: SortOrder
  }

  export type city_toursSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type countriesCountOrderByAggregateInput = {
    id?: SortOrder
    sortname?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type countriesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type countriesMaxOrderByAggregateInput = {
    id?: SortOrder
    sortname?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type countriesMinOrderByAggregateInput = {
    id?: SortOrder
    sortname?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type countriesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type couponsCountOrderByAggregateInput = {
    id?: SortOrder
    coupon_name?: SortOrder
    percentage?: SortOrder
    price?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type couponsAvgOrderByAggregateInput = {
    id?: SortOrder
    percentage?: SortOrder
    price?: SortOrder
  }

  export type couponsMaxOrderByAggregateInput = {
    id?: SortOrder
    coupon_name?: SortOrder
    percentage?: SortOrder
    price?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type couponsMinOrderByAggregateInput = {
    id?: SortOrder
    coupon_name?: SortOrder
    percentage?: SortOrder
    price?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type couponsSumOrderByAggregateInput = {
    id?: SortOrder
    percentage?: SortOrder
    price?: SortOrder
  }

  export type datatablesCountOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    points?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    age?: SortOrder
    job?: SortOrder
    gender?: SortOrder
    country?: SortOrder
    sale_date?: SortOrder
  }

  export type datatablesAvgOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type datatablesMaxOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    points?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    age?: SortOrder
    job?: SortOrder
    gender?: SortOrder
    country?: SortOrder
    sale_date?: SortOrder
  }

  export type datatablesMinOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    points?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    age?: SortOrder
    job?: SortOrder
    gender?: SortOrder
    country?: SortOrder
    sale_date?: SortOrder
  }

  export type datatablesSumOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type driversCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type driversAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type driversMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type driversMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type driversSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type featuresCountOrderByAggregateInput = {
    id?: SortOrder
    feature?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type featuresAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type featuresMaxOrderByAggregateInput = {
    id?: SortOrder
    feature?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type featuresMinOrderByAggregateInput = {
    id?: SortOrder
    feature?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type featuresSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type filesCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    mime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type filesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type filesMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    mime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type filesMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    mime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type filesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fuel_typesCountOrderByAggregateInput = {
    id?: SortOrder
    fuel_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type fuel_typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fuel_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    fuel_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type fuel_typesMinOrderByAggregateInput = {
    id?: SortOrder
    fuel_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type fuel_typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type gratuitiesCountOrderByAggregateInput = {
    id?: SortOrder
    percentage?: SortOrder
    status?: SortOrder
    name?: SortOrder
    price?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type gratuitiesAvgOrderByAggregateInput = {
    id?: SortOrder
    percentage?: SortOrder
    price?: SortOrder
    service_id?: SortOrder
  }

  export type gratuitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    percentage?: SortOrder
    status?: SortOrder
    name?: SortOrder
    price?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type gratuitiesMinOrderByAggregateInput = {
    id?: SortOrder
    percentage?: SortOrder
    status?: SortOrder
    name?: SortOrder
    price?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type gratuitiesSumOrderByAggregateInput = {
    id?: SortOrder
    percentage?: SortOrder
    price?: SortOrder
    service_id?: SortOrder
  }

  export type hourly_servicesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_location?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    num_service_hours?: SortOrder
    dropoff_location?: SortOrder
    add_another_stop?: SortOrder
    additional_comments?: SortOrder
    status?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type hourly_servicesAvgOrderByAggregateInput = {
    id?: SortOrder
    num_passengers?: SortOrder
    num_service_hours?: SortOrder
    service_id?: SortOrder
  }

  export type hourly_servicesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_location?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    num_service_hours?: SortOrder
    dropoff_location?: SortOrder
    add_another_stop?: SortOrder
    additional_comments?: SortOrder
    status?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type hourly_servicesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_location?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    num_service_hours?: SortOrder
    dropoff_location?: SortOrder
    add_another_stop?: SortOrder
    additional_comments?: SortOrder
    status?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type hourly_servicesSumOrderByAggregateInput = {
    id?: SortOrder
    num_passengers?: SortOrder
    num_service_hours?: SortOrder
    service_id?: SortOrder
  }

  export type locationsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    fee?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type locationsAvgOrderByAggregateInput = {
    id?: SortOrder
    fee?: SortOrder
  }

  export type locationsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    fee?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type locationsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    fee?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type locationsSumOrderByAggregateInput = {
    id?: SortOrder
    fee?: SortOrder
  }

  export type manufacturersCountOrderByAggregateInput = {
    id?: SortOrder
    Manufacturer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type manufacturersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type manufacturersMaxOrderByAggregateInput = {
    id?: SortOrder
    Manufacturer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type manufacturersMinOrderByAggregateInput = {
    id?: SortOrder
    Manufacturer?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type manufacturersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type migrationsCountOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsAvgOrderByAggregateInput = {
    id?: SortOrder
    batch?: SortOrder
  }

  export type migrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsMinOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsSumOrderByAggregateInput = {
    id?: SortOrder
    batch?: SortOrder
  }

  export type package_typesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    Created_on?: SortOrder
  }

  export type package_typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type package_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    Created_on?: SortOrder
  }

  export type package_typesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    Created_on?: SortOrder
  }

  export type package_typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type persistencesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type persistencesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type persistencesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type persistencesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type persistencesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type point_to_point_servicesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_location?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    dropoff_location?: SortOrder
    add_another_stop?: SortOrder
    additional_comments?: SortOrder
    status?: SortOrder
    pick_up_lat?: SortOrder
    pick_up_lon?: SortOrder
    drop_off_lat?: SortOrder
    drop_off_lon?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type point_to_point_servicesAvgOrderByAggregateInput = {
    id?: SortOrder
    num_passengers?: SortOrder
    service_id?: SortOrder
  }

  export type point_to_point_servicesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_location?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    dropoff_location?: SortOrder
    add_another_stop?: SortOrder
    additional_comments?: SortOrder
    status?: SortOrder
    pick_up_lat?: SortOrder
    pick_up_lon?: SortOrder
    drop_off_lat?: SortOrder
    drop_off_lon?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type point_to_point_servicesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pickup_location?: SortOrder
    pickup_date_time?: SortOrder
    num_passengers?: SortOrder
    dropoff_location?: SortOrder
    add_another_stop?: SortOrder
    additional_comments?: SortOrder
    status?: SortOrder
    pick_up_lat?: SortOrder
    pick_up_lon?: SortOrder
    drop_off_lat?: SortOrder
    drop_off_lon?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type point_to_point_servicesSumOrderByAggregateInput = {
    id?: SortOrder
    num_passengers?: SortOrder
    service_id?: SortOrder
  }

  export type remindersCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type remindersAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type remindersMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type remindersMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    code?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type remindersSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type Sub_servicesRelationFilter = {
    is?: sub_servicesWhereInput | null
    isNot?: sub_servicesWhereInput | null
  }

  export type reservationsCountOrderByAggregateInput = {
    id?: SortOrder
    order_number?: SortOrder
    service_id?: SortOrder
    car_id?: SortOrder
    pick_up_postal_code?: SortOrder
    pick_up_lat?: SortOrder
    pick_up_lon?: SortOrder
    pick_up_loc_name?: SortOrder
    drop_off_postal_code?: SortOrder
    drop_off_lat?: SortOrder
    drop_off_lon?: SortOrder
    drop_off_loc_name?: SortOrder
    pick_up_date?: SortOrder
    price?: SortOrder
    tax?: SortOrder
    airline?: SortOrder
    flight_no?: SortOrder
    no_of_hours?: SortOrder
    maximum_passenger?: SortOrder
    maximum_luggage?: SortOrder
    customer_first_name?: SortOrder
    customer_last_name?: SortOrder
    customer_cnic?: SortOrder
    customer_email?: SortOrder
    customer_phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    uuid?: SortOrder
    payment_method?: SortOrder
    isPaid?: SortOrder
    special_instruction?: SortOrder
  }

  export type reservationsAvgOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    car_id?: SortOrder
    pick_up_lat?: SortOrder
    pick_up_lon?: SortOrder
    drop_off_lat?: SortOrder
    drop_off_lon?: SortOrder
    price?: SortOrder
    tax?: SortOrder
    no_of_hours?: SortOrder
    maximum_passenger?: SortOrder
    maximum_luggage?: SortOrder
    isPaid?: SortOrder
  }

  export type reservationsMaxOrderByAggregateInput = {
    id?: SortOrder
    order_number?: SortOrder
    service_id?: SortOrder
    car_id?: SortOrder
    pick_up_postal_code?: SortOrder
    pick_up_lat?: SortOrder
    pick_up_lon?: SortOrder
    pick_up_loc_name?: SortOrder
    drop_off_postal_code?: SortOrder
    drop_off_lat?: SortOrder
    drop_off_lon?: SortOrder
    drop_off_loc_name?: SortOrder
    pick_up_date?: SortOrder
    price?: SortOrder
    tax?: SortOrder
    airline?: SortOrder
    flight_no?: SortOrder
    no_of_hours?: SortOrder
    maximum_passenger?: SortOrder
    maximum_luggage?: SortOrder
    customer_first_name?: SortOrder
    customer_last_name?: SortOrder
    customer_cnic?: SortOrder
    customer_email?: SortOrder
    customer_phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    uuid?: SortOrder
    payment_method?: SortOrder
    isPaid?: SortOrder
    special_instruction?: SortOrder
  }

  export type reservationsMinOrderByAggregateInput = {
    id?: SortOrder
    order_number?: SortOrder
    service_id?: SortOrder
    car_id?: SortOrder
    pick_up_postal_code?: SortOrder
    pick_up_lat?: SortOrder
    pick_up_lon?: SortOrder
    pick_up_loc_name?: SortOrder
    drop_off_postal_code?: SortOrder
    drop_off_lat?: SortOrder
    drop_off_lon?: SortOrder
    drop_off_loc_name?: SortOrder
    pick_up_date?: SortOrder
    price?: SortOrder
    tax?: SortOrder
    airline?: SortOrder
    flight_no?: SortOrder
    no_of_hours?: SortOrder
    maximum_passenger?: SortOrder
    maximum_luggage?: SortOrder
    customer_first_name?: SortOrder
    customer_last_name?: SortOrder
    customer_cnic?: SortOrder
    customer_email?: SortOrder
    customer_phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    uuid?: SortOrder
    payment_method?: SortOrder
    isPaid?: SortOrder
    special_instruction?: SortOrder
  }

  export type reservationsSumOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    car_id?: SortOrder
    pick_up_lat?: SortOrder
    pick_up_lon?: SortOrder
    drop_off_lat?: SortOrder
    drop_off_lon?: SortOrder
    price?: SortOrder
    tax?: SortOrder
    no_of_hours?: SortOrder
    maximum_passenger?: SortOrder
    maximum_luggage?: SortOrder
    isPaid?: SortOrder
  }

  export type RolesRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type role_usersUser_idRole_idCompoundUniqueInput = {
    user_id: number
    role_id: number
  }

  export type role_usersCountOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type role_usersAvgOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type role_usersMaxOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type role_usersMinOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type role_usersSumOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type Role_usersListRelationFilter = {
    every?: role_usersWhereInput
    some?: role_usersWhereInput
    none?: role_usersWhereInput
  }

  export type role_usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Airport_servicesListRelationFilter = {
    every?: airport_servicesWhereInput
    some?: airport_servicesWhereInput
    none?: airport_servicesWhereInput
  }

  export type GratuitiesListRelationFilter = {
    every?: gratuitiesWhereInput
    some?: gratuitiesWhereInput
    none?: gratuitiesWhereInput
  }

  export type Hourly_servicesListRelationFilter = {
    every?: hourly_servicesWhereInput
    some?: hourly_servicesWhereInput
    none?: hourly_servicesWhereInput
  }

  export type Point_to_point_servicesListRelationFilter = {
    every?: point_to_point_servicesWhereInput
    some?: point_to_point_servicesWhereInput
    none?: point_to_point_servicesWhereInput
  }

  export type airport_servicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gratuitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type hourly_servicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type point_to_point_servicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type servicesCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type servicesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type servicesMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type servicesMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type servicesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sys_settingsCountOrderByAggregateInput = {
    id?: SortOrder
    sys_name?: SortOrder
    sys_details?: SortOrder
    Created_on?: SortOrder
    setting_key?: SortOrder
  }

  export type sys_settingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sys_settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    sys_name?: SortOrder
    sys_details?: SortOrder
    Created_on?: SortOrder
    setting_key?: SortOrder
  }

  export type sys_settingsMinOrderByAggregateInput = {
    id?: SortOrder
    sys_name?: SortOrder
    sys_details?: SortOrder
    Created_on?: SortOrder
    setting_key?: SortOrder
  }

  export type sys_settingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type taggable_tagsCountOrderByAggregateInput = {
    tag_id?: SortOrder
    name?: SortOrder
    normalized?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type taggable_tagsAvgOrderByAggregateInput = {
    tag_id?: SortOrder
  }

  export type taggable_tagsMaxOrderByAggregateInput = {
    tag_id?: SortOrder
    name?: SortOrder
    normalized?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type taggable_tagsMinOrderByAggregateInput = {
    tag_id?: SortOrder
    name?: SortOrder
    normalized?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type taggable_tagsSumOrderByAggregateInput = {
    tag_id?: SortOrder
  }

  export type tasksCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    finished?: SortOrder
    task_description?: SortOrder
    task_deadline?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tasksAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    finished?: SortOrder
  }

  export type tasksMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    finished?: SortOrder
    task_description?: SortOrder
    task_deadline?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tasksMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    finished?: SortOrder
    task_description?: SortOrder
    task_deadline?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tasksSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    finished?: SortOrder
  }

  export type throttleCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    ip?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type throttleAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type throttleMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    ip?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type throttleMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    ip?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type throttleSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type BytesNullableFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type toursCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    price_per_passenger?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_id?: SortOrder
    description?: SortOrder
    luggage?: SortOrder
  }

  export type toursAvgOrderByAggregateInput = {
    id?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    price_per_passenger?: SortOrder
    car_id?: SortOrder
    luggage?: SortOrder
  }

  export type toursMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    price_per_passenger?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_id?: SortOrder
    description?: SortOrder
    luggage?: SortOrder
  }

  export type toursMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    price_per_passenger?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_id?: SortOrder
    description?: SortOrder
    luggage?: SortOrder
  }

  export type toursSumOrderByAggregateInput = {
    id?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    price_per_passenger?: SortOrder
    car_id?: SortOrder
    luggage?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
  }

  export type transmissionsCountOrderByAggregateInput = {
    id?: SortOrder
    transmission?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type transmissionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type transmissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    transmission?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type transmissionsMinOrderByAggregateInput = {
    id?: SortOrder
    transmission?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type transmissionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    permissions?: SortOrder
    last_login?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    bio?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    pic?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    address?: SortOrder
    postal?: SortOrder
    status?: SortOrder
    reset_token?: SortOrder
    token_expired_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    permissions?: SortOrder
    last_login?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    bio?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    pic?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    address?: SortOrder
    postal?: SortOrder
    status?: SortOrder
    reset_token?: SortOrder
    token_expired_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    permissions?: SortOrder
    last_login?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    bio?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    pic?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    address?: SortOrder
    postal?: SortOrder
    status?: SortOrder
    reset_token?: SortOrder
    token_expired_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type location_exceptionsCountOrderByAggregateInput = {
    id?: SortOrder
    pick_up_loc_name?: SortOrder
    pick_up_postal_code?: SortOrder
    drop_off_loc_name?: SortOrder
    drop_off_postal_code?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type location_exceptionsAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type location_exceptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    pick_up_loc_name?: SortOrder
    pick_up_postal_code?: SortOrder
    drop_off_loc_name?: SortOrder
    drop_off_postal_code?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type location_exceptionsMinOrderByAggregateInput = {
    id?: SortOrder
    pick_up_loc_name?: SortOrder
    pick_up_postal_code?: SortOrder
    drop_off_loc_name?: SortOrder
    drop_off_postal_code?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type location_exceptionsSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type package_serivceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    passenger_capacity?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    car_id?: SortOrder
    isActive?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    luggage?: SortOrder
  }

  export type package_serivceAvgOrderByAggregateInput = {
    id?: SortOrder
    passenger_capacity?: SortOrder
    price?: SortOrder
    car_id?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    luggage?: SortOrder
  }

  export type package_serivceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    passenger_capacity?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    car_id?: SortOrder
    isActive?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    luggage?: SortOrder
  }

  export type package_serivceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    passenger_capacity?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    car_id?: SortOrder
    isActive?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    luggage?: SortOrder
  }

  export type package_serivceSumOrderByAggregateInput = {
    id?: SortOrder
    passenger_capacity?: SortOrder
    price?: SortOrder
    car_id?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    luggage?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type slabsCountOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    initial_distance?: SortOrder
    final_distance?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type slabsAvgOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    initial_distance?: SortOrder
    final_distance?: SortOrder
    price?: SortOrder
  }

  export type slabsMaxOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    initial_distance?: SortOrder
    final_distance?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type slabsMinOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    initial_distance?: SortOrder
    final_distance?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type slabsSumOrderByAggregateInput = {
    id?: SortOrder
    car_id?: SortOrder
    initial_distance?: SortOrder
    final_distance?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type timeslotsCountOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    isActive?: SortOrder
    sub_service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type timeslotsAvgOrderByAggregateInput = {
    id?: SortOrder
    sub_service_id?: SortOrder
  }

  export type timeslotsMaxOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    isActive?: SortOrder
    sub_service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type timeslotsMinOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    isActive?: SortOrder
    sub_service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type timeslotsSumOrderByAggregateInput = {
    id?: SortOrder
    sub_service_id?: SortOrder
  }

  export type vehicle_typesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type vehicle_typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type vehicle_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type vehicle_typesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type vehicle_typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TimeslotsListRelationFilter = {
    every?: timeslotsWhereInput
    some?: timeslotsWhereInput
    none?: timeslotsWhereInput
  }

  export type timeslotsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sub_servicesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    price_per_passenger?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_id?: SortOrder
    service_id?: SortOrder
    description?: SortOrder
    luggage?: SortOrder
    passenger_capacity?: SortOrder
  }

  export type sub_servicesAvgOrderByAggregateInput = {
    id?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    price_per_passenger?: SortOrder
    car_id?: SortOrder
    service_id?: SortOrder
    luggage?: SortOrder
    passenger_capacity?: SortOrder
  }

  export type sub_servicesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    price_per_passenger?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_id?: SortOrder
    service_id?: SortOrder
    description?: SortOrder
    luggage?: SortOrder
    passenger_capacity?: SortOrder
  }

  export type sub_servicesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pickup_location?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_location?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    price_per_passenger?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    isActive?: SortOrder
    car_id?: SortOrder
    service_id?: SortOrder
    description?: SortOrder
    luggage?: SortOrder
    passenger_capacity?: SortOrder
  }

  export type sub_servicesSumOrderByAggregateInput = {
    id?: SortOrder
    pickup_lat?: SortOrder
    pickup_lng?: SortOrder
    dropoff_lat?: SortOrder
    dropoff_lng?: SortOrder
    price_per_passenger?: SortOrder
    car_id?: SortOrder
    service_id?: SortOrder
    luggage?: SortOrder
    passenger_capacity?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type servicesCreateNestedOneWithoutAirport_servicesInput = {
    create?: XOR<servicesCreateWithoutAirport_servicesInput, servicesUncheckedCreateWithoutAirport_servicesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutAirport_servicesInput
    connect?: servicesWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type servicesUpdateOneRequiredWithoutAirport_servicesNestedInput = {
    create?: XOR<servicesCreateWithoutAirport_servicesInput, servicesUncheckedCreateWithoutAirport_servicesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutAirport_servicesInput
    upsert?: servicesUpsertWithoutAirport_servicesInput
    connect?: servicesWhereUniqueInput
    update?: XOR<servicesUpdateWithoutAirport_servicesInput, servicesUncheckedUpdateWithoutAirport_servicesInput>
  }

  export type carsCreateNestedManyWithoutBody_typesInput = {
    create?: XOR<Enumerable<carsCreateWithoutBody_typesInput>, Enumerable<carsUncheckedCreateWithoutBody_typesInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutBody_typesInput>
    createMany?: carsCreateManyBody_typesInputEnvelope
    connect?: Enumerable<carsWhereUniqueInput>
  }

  export type carsUncheckedCreateNestedManyWithoutBody_typesInput = {
    create?: XOR<Enumerable<carsCreateWithoutBody_typesInput>, Enumerable<carsUncheckedCreateWithoutBody_typesInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutBody_typesInput>
    createMany?: carsCreateManyBody_typesInputEnvelope
    connect?: Enumerable<carsWhereUniqueInput>
  }

  export type carsUpdateManyWithoutBody_typesNestedInput = {
    create?: XOR<Enumerable<carsCreateWithoutBody_typesInput>, Enumerable<carsUncheckedCreateWithoutBody_typesInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutBody_typesInput>
    upsert?: Enumerable<carsUpsertWithWhereUniqueWithoutBody_typesInput>
    createMany?: carsCreateManyBody_typesInputEnvelope
    set?: Enumerable<carsWhereUniqueInput>
    disconnect?: Enumerable<carsWhereUniqueInput>
    delete?: Enumerable<carsWhereUniqueInput>
    connect?: Enumerable<carsWhereUniqueInput>
    update?: Enumerable<carsUpdateWithWhereUniqueWithoutBody_typesInput>
    updateMany?: Enumerable<carsUpdateManyWithWhereWithoutBody_typesInput>
    deleteMany?: Enumerable<carsScalarWhereInput>
  }

  export type carsUncheckedUpdateManyWithoutBody_typesNestedInput = {
    create?: XOR<Enumerable<carsCreateWithoutBody_typesInput>, Enumerable<carsUncheckedCreateWithoutBody_typesInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutBody_typesInput>
    upsert?: Enumerable<carsUpsertWithWhereUniqueWithoutBody_typesInput>
    createMany?: carsCreateManyBody_typesInputEnvelope
    set?: Enumerable<carsWhereUniqueInput>
    disconnect?: Enumerable<carsWhereUniqueInput>
    delete?: Enumerable<carsWhereUniqueInput>
    connect?: Enumerable<carsWhereUniqueInput>
    update?: Enumerable<carsUpdateWithWhereUniqueWithoutBody_typesInput>
    updateMany?: Enumerable<carsUpdateManyWithWhereWithoutBody_typesInput>
    deleteMany?: Enumerable<carsScalarWhereInput>
  }

  export type car_pricesCreateNestedManyWithoutCar_price_typesInput = {
    create?: XOR<Enumerable<car_pricesCreateWithoutCar_price_typesInput>, Enumerable<car_pricesUncheckedCreateWithoutCar_price_typesInput>>
    connectOrCreate?: Enumerable<car_pricesCreateOrConnectWithoutCar_price_typesInput>
    createMany?: car_pricesCreateManyCar_price_typesInputEnvelope
    connect?: Enumerable<car_pricesWhereUniqueInput>
  }

  export type car_pricesUncheckedCreateNestedManyWithoutCar_price_typesInput = {
    create?: XOR<Enumerable<car_pricesCreateWithoutCar_price_typesInput>, Enumerable<car_pricesUncheckedCreateWithoutCar_price_typesInput>>
    connectOrCreate?: Enumerable<car_pricesCreateOrConnectWithoutCar_price_typesInput>
    createMany?: car_pricesCreateManyCar_price_typesInputEnvelope
    connect?: Enumerable<car_pricesWhereUniqueInput>
  }

  export type car_pricesUpdateManyWithoutCar_price_typesNestedInput = {
    create?: XOR<Enumerable<car_pricesCreateWithoutCar_price_typesInput>, Enumerable<car_pricesUncheckedCreateWithoutCar_price_typesInput>>
    connectOrCreate?: Enumerable<car_pricesCreateOrConnectWithoutCar_price_typesInput>
    upsert?: Enumerable<car_pricesUpsertWithWhereUniqueWithoutCar_price_typesInput>
    createMany?: car_pricesCreateManyCar_price_typesInputEnvelope
    set?: Enumerable<car_pricesWhereUniqueInput>
    disconnect?: Enumerable<car_pricesWhereUniqueInput>
    delete?: Enumerable<car_pricesWhereUniqueInput>
    connect?: Enumerable<car_pricesWhereUniqueInput>
    update?: Enumerable<car_pricesUpdateWithWhereUniqueWithoutCar_price_typesInput>
    updateMany?: Enumerable<car_pricesUpdateManyWithWhereWithoutCar_price_typesInput>
    deleteMany?: Enumerable<car_pricesScalarWhereInput>
  }

  export type car_pricesUncheckedUpdateManyWithoutCar_price_typesNestedInput = {
    create?: XOR<Enumerable<car_pricesCreateWithoutCar_price_typesInput>, Enumerable<car_pricesUncheckedCreateWithoutCar_price_typesInput>>
    connectOrCreate?: Enumerable<car_pricesCreateOrConnectWithoutCar_price_typesInput>
    upsert?: Enumerable<car_pricesUpsertWithWhereUniqueWithoutCar_price_typesInput>
    createMany?: car_pricesCreateManyCar_price_typesInputEnvelope
    set?: Enumerable<car_pricesWhereUniqueInput>
    disconnect?: Enumerable<car_pricesWhereUniqueInput>
    delete?: Enumerable<car_pricesWhereUniqueInput>
    connect?: Enumerable<car_pricesWhereUniqueInput>
    update?: Enumerable<car_pricesUpdateWithWhereUniqueWithoutCar_price_typesInput>
    updateMany?: Enumerable<car_pricesUpdateManyWithWhereWithoutCar_price_typesInput>
    deleteMany?: Enumerable<car_pricesScalarWhereInput>
  }

  export type carsCreateNestedOneWithoutCar_pricesInput = {
    create?: XOR<carsCreateWithoutCar_pricesInput, carsUncheckedCreateWithoutCar_pricesInput>
    connectOrCreate?: carsCreateOrConnectWithoutCar_pricesInput
    connect?: carsWhereUniqueInput
  }

  export type car_price_typesCreateNestedOneWithoutCar_pricesInput = {
    create?: XOR<car_price_typesCreateWithoutCar_pricesInput, car_price_typesUncheckedCreateWithoutCar_pricesInput>
    connectOrCreate?: car_price_typesCreateOrConnectWithoutCar_pricesInput
    connect?: car_price_typesWhereUniqueInput
  }

  export type carsUpdateOneRequiredWithoutCar_pricesNestedInput = {
    create?: XOR<carsCreateWithoutCar_pricesInput, carsUncheckedCreateWithoutCar_pricesInput>
    connectOrCreate?: carsCreateOrConnectWithoutCar_pricesInput
    upsert?: carsUpsertWithoutCar_pricesInput
    connect?: carsWhereUniqueInput
    update?: XOR<carsUpdateWithoutCar_pricesInput, carsUncheckedUpdateWithoutCar_pricesInput>
  }

  export type car_price_typesUpdateOneRequiredWithoutCar_pricesNestedInput = {
    create?: XOR<car_price_typesCreateWithoutCar_pricesInput, car_price_typesUncheckedCreateWithoutCar_pricesInput>
    connectOrCreate?: car_price_typesCreateOrConnectWithoutCar_pricesInput
    upsert?: car_price_typesUpsertWithoutCar_pricesInput
    connect?: car_price_typesWhereUniqueInput
    update?: XOR<car_price_typesUpdateWithoutCar_pricesInput, car_price_typesUncheckedUpdateWithoutCar_pricesInput>
  }

  export type car_pricesCreateNestedManyWithoutCarsInput = {
    create?: XOR<Enumerable<car_pricesCreateWithoutCarsInput>, Enumerable<car_pricesUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<car_pricesCreateOrConnectWithoutCarsInput>
    createMany?: car_pricesCreateManyCarsInputEnvelope
    connect?: Enumerable<car_pricesWhereUniqueInput>
  }

  export type body_typesCreateNestedOneWithoutCarsInput = {
    create?: XOR<body_typesCreateWithoutCarsInput, body_typesUncheckedCreateWithoutCarsInput>
    connectOrCreate?: body_typesCreateOrConnectWithoutCarsInput
    connect?: body_typesWhereUniqueInput
  }

  export type driversCreateNestedOneWithoutCarsInput = {
    create?: XOR<driversCreateWithoutCarsInput, driversUncheckedCreateWithoutCarsInput>
    connectOrCreate?: driversCreateOrConnectWithoutCarsInput
    connect?: driversWhereUniqueInput
  }

  export type fuel_typesCreateNestedOneWithoutCarsInput = {
    create?: XOR<fuel_typesCreateWithoutCarsInput, fuel_typesUncheckedCreateWithoutCarsInput>
    connectOrCreate?: fuel_typesCreateOrConnectWithoutCarsInput
    connect?: fuel_typesWhereUniqueInput
  }

  export type manufacturersCreateNestedOneWithoutCarsInput = {
    create?: XOR<manufacturersCreateWithoutCarsInput, manufacturersUncheckedCreateWithoutCarsInput>
    connectOrCreate?: manufacturersCreateOrConnectWithoutCarsInput
    connect?: manufacturersWhereUniqueInput
  }

  export type transmissionsCreateNestedOneWithoutCarsInput = {
    create?: XOR<transmissionsCreateWithoutCarsInput, transmissionsUncheckedCreateWithoutCarsInput>
    connectOrCreate?: transmissionsCreateOrConnectWithoutCarsInput
    connect?: transmissionsWhereUniqueInput
  }

  export type vehicle_typesCreateNestedOneWithoutCarsInput = {
    create?: XOR<vehicle_typesCreateWithoutCarsInput, vehicle_typesUncheckedCreateWithoutCarsInput>
    connectOrCreate?: vehicle_typesCreateOrConnectWithoutCarsInput
    connect?: vehicle_typesWhereUniqueInput
  }

  export type package_serivceCreateNestedManyWithoutCarsInput = {
    create?: XOR<Enumerable<package_serivceCreateWithoutCarsInput>, Enumerable<package_serivceUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<package_serivceCreateOrConnectWithoutCarsInput>
    createMany?: package_serivceCreateManyCarsInputEnvelope
    connect?: Enumerable<package_serivceWhereUniqueInput>
  }

  export type reservationsCreateNestedManyWithoutCarsInput = {
    create?: XOR<Enumerable<reservationsCreateWithoutCarsInput>, Enumerable<reservationsUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<reservationsCreateOrConnectWithoutCarsInput>
    createMany?: reservationsCreateManyCarsInputEnvelope
    connect?: Enumerable<reservationsWhereUniqueInput>
  }

  export type slabsCreateNestedManyWithoutCarsInput = {
    create?: XOR<Enumerable<slabsCreateWithoutCarsInput>, Enumerable<slabsUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<slabsCreateOrConnectWithoutCarsInput>
    createMany?: slabsCreateManyCarsInputEnvelope
    connect?: Enumerable<slabsWhereUniqueInput>
  }

  export type sub_servicesCreateNestedManyWithoutCarsInput = {
    create?: XOR<Enumerable<sub_servicesCreateWithoutCarsInput>, Enumerable<sub_servicesUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<sub_servicesCreateOrConnectWithoutCarsInput>
    createMany?: sub_servicesCreateManyCarsInputEnvelope
    connect?: Enumerable<sub_servicesWhereUniqueInput>
  }

  export type toursCreateNestedManyWithoutCarsInput = {
    create?: XOR<Enumerable<toursCreateWithoutCarsInput>, Enumerable<toursUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<toursCreateOrConnectWithoutCarsInput>
    createMany?: toursCreateManyCarsInputEnvelope
    connect?: Enumerable<toursWhereUniqueInput>
  }

  export type car_pricesUncheckedCreateNestedManyWithoutCarsInput = {
    create?: XOR<Enumerable<car_pricesCreateWithoutCarsInput>, Enumerable<car_pricesUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<car_pricesCreateOrConnectWithoutCarsInput>
    createMany?: car_pricesCreateManyCarsInputEnvelope
    connect?: Enumerable<car_pricesWhereUniqueInput>
  }

  export type package_serivceUncheckedCreateNestedManyWithoutCarsInput = {
    create?: XOR<Enumerable<package_serivceCreateWithoutCarsInput>, Enumerable<package_serivceUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<package_serivceCreateOrConnectWithoutCarsInput>
    createMany?: package_serivceCreateManyCarsInputEnvelope
    connect?: Enumerable<package_serivceWhereUniqueInput>
  }

  export type reservationsUncheckedCreateNestedManyWithoutCarsInput = {
    create?: XOR<Enumerable<reservationsCreateWithoutCarsInput>, Enumerable<reservationsUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<reservationsCreateOrConnectWithoutCarsInput>
    createMany?: reservationsCreateManyCarsInputEnvelope
    connect?: Enumerable<reservationsWhereUniqueInput>
  }

  export type slabsUncheckedCreateNestedManyWithoutCarsInput = {
    create?: XOR<Enumerable<slabsCreateWithoutCarsInput>, Enumerable<slabsUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<slabsCreateOrConnectWithoutCarsInput>
    createMany?: slabsCreateManyCarsInputEnvelope
    connect?: Enumerable<slabsWhereUniqueInput>
  }

  export type sub_servicesUncheckedCreateNestedManyWithoutCarsInput = {
    create?: XOR<Enumerable<sub_servicesCreateWithoutCarsInput>, Enumerable<sub_servicesUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<sub_servicesCreateOrConnectWithoutCarsInput>
    createMany?: sub_servicesCreateManyCarsInputEnvelope
    connect?: Enumerable<sub_servicesWhereUniqueInput>
  }

  export type toursUncheckedCreateNestedManyWithoutCarsInput = {
    create?: XOR<Enumerable<toursCreateWithoutCarsInput>, Enumerable<toursUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<toursCreateOrConnectWithoutCarsInput>
    createMany?: toursCreateManyCarsInputEnvelope
    connect?: Enumerable<toursWhereUniqueInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumcars_car_typeFieldUpdateOperationsInput = {
    set?: cars_car_type | null
  }

  export type car_pricesUpdateManyWithoutCarsNestedInput = {
    create?: XOR<Enumerable<car_pricesCreateWithoutCarsInput>, Enumerable<car_pricesUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<car_pricesCreateOrConnectWithoutCarsInput>
    upsert?: Enumerable<car_pricesUpsertWithWhereUniqueWithoutCarsInput>
    createMany?: car_pricesCreateManyCarsInputEnvelope
    set?: Enumerable<car_pricesWhereUniqueInput>
    disconnect?: Enumerable<car_pricesWhereUniqueInput>
    delete?: Enumerable<car_pricesWhereUniqueInput>
    connect?: Enumerable<car_pricesWhereUniqueInput>
    update?: Enumerable<car_pricesUpdateWithWhereUniqueWithoutCarsInput>
    updateMany?: Enumerable<car_pricesUpdateManyWithWhereWithoutCarsInput>
    deleteMany?: Enumerable<car_pricesScalarWhereInput>
  }

  export type body_typesUpdateOneRequiredWithoutCarsNestedInput = {
    create?: XOR<body_typesCreateWithoutCarsInput, body_typesUncheckedCreateWithoutCarsInput>
    connectOrCreate?: body_typesCreateOrConnectWithoutCarsInput
    upsert?: body_typesUpsertWithoutCarsInput
    connect?: body_typesWhereUniqueInput
    update?: XOR<body_typesUpdateWithoutCarsInput, body_typesUncheckedUpdateWithoutCarsInput>
  }

  export type driversUpdateOneRequiredWithoutCarsNestedInput = {
    create?: XOR<driversCreateWithoutCarsInput, driversUncheckedCreateWithoutCarsInput>
    connectOrCreate?: driversCreateOrConnectWithoutCarsInput
    upsert?: driversUpsertWithoutCarsInput
    connect?: driversWhereUniqueInput
    update?: XOR<driversUpdateWithoutCarsInput, driversUncheckedUpdateWithoutCarsInput>
  }

  export type fuel_typesUpdateOneRequiredWithoutCarsNestedInput = {
    create?: XOR<fuel_typesCreateWithoutCarsInput, fuel_typesUncheckedCreateWithoutCarsInput>
    connectOrCreate?: fuel_typesCreateOrConnectWithoutCarsInput
    upsert?: fuel_typesUpsertWithoutCarsInput
    connect?: fuel_typesWhereUniqueInput
    update?: XOR<fuel_typesUpdateWithoutCarsInput, fuel_typesUncheckedUpdateWithoutCarsInput>
  }

  export type manufacturersUpdateOneRequiredWithoutCarsNestedInput = {
    create?: XOR<manufacturersCreateWithoutCarsInput, manufacturersUncheckedCreateWithoutCarsInput>
    connectOrCreate?: manufacturersCreateOrConnectWithoutCarsInput
    upsert?: manufacturersUpsertWithoutCarsInput
    connect?: manufacturersWhereUniqueInput
    update?: XOR<manufacturersUpdateWithoutCarsInput, manufacturersUncheckedUpdateWithoutCarsInput>
  }

  export type transmissionsUpdateOneRequiredWithoutCarsNestedInput = {
    create?: XOR<transmissionsCreateWithoutCarsInput, transmissionsUncheckedCreateWithoutCarsInput>
    connectOrCreate?: transmissionsCreateOrConnectWithoutCarsInput
    upsert?: transmissionsUpsertWithoutCarsInput
    connect?: transmissionsWhereUniqueInput
    update?: XOR<transmissionsUpdateWithoutCarsInput, transmissionsUncheckedUpdateWithoutCarsInput>
  }

  export type vehicle_typesUpdateOneRequiredWithoutCarsNestedInput = {
    create?: XOR<vehicle_typesCreateWithoutCarsInput, vehicle_typesUncheckedCreateWithoutCarsInput>
    connectOrCreate?: vehicle_typesCreateOrConnectWithoutCarsInput
    upsert?: vehicle_typesUpsertWithoutCarsInput
    connect?: vehicle_typesWhereUniqueInput
    update?: XOR<vehicle_typesUpdateWithoutCarsInput, vehicle_typesUncheckedUpdateWithoutCarsInput>
  }

  export type package_serivceUpdateManyWithoutCarsNestedInput = {
    create?: XOR<Enumerable<package_serivceCreateWithoutCarsInput>, Enumerable<package_serivceUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<package_serivceCreateOrConnectWithoutCarsInput>
    upsert?: Enumerable<package_serivceUpsertWithWhereUniqueWithoutCarsInput>
    createMany?: package_serivceCreateManyCarsInputEnvelope
    set?: Enumerable<package_serivceWhereUniqueInput>
    disconnect?: Enumerable<package_serivceWhereUniqueInput>
    delete?: Enumerable<package_serivceWhereUniqueInput>
    connect?: Enumerable<package_serivceWhereUniqueInput>
    update?: Enumerable<package_serivceUpdateWithWhereUniqueWithoutCarsInput>
    updateMany?: Enumerable<package_serivceUpdateManyWithWhereWithoutCarsInput>
    deleteMany?: Enumerable<package_serivceScalarWhereInput>
  }

  export type reservationsUpdateManyWithoutCarsNestedInput = {
    create?: XOR<Enumerable<reservationsCreateWithoutCarsInput>, Enumerable<reservationsUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<reservationsCreateOrConnectWithoutCarsInput>
    upsert?: Enumerable<reservationsUpsertWithWhereUniqueWithoutCarsInput>
    createMany?: reservationsCreateManyCarsInputEnvelope
    set?: Enumerable<reservationsWhereUniqueInput>
    disconnect?: Enumerable<reservationsWhereUniqueInput>
    delete?: Enumerable<reservationsWhereUniqueInput>
    connect?: Enumerable<reservationsWhereUniqueInput>
    update?: Enumerable<reservationsUpdateWithWhereUniqueWithoutCarsInput>
    updateMany?: Enumerable<reservationsUpdateManyWithWhereWithoutCarsInput>
    deleteMany?: Enumerable<reservationsScalarWhereInput>
  }

  export type slabsUpdateManyWithoutCarsNestedInput = {
    create?: XOR<Enumerable<slabsCreateWithoutCarsInput>, Enumerable<slabsUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<slabsCreateOrConnectWithoutCarsInput>
    upsert?: Enumerable<slabsUpsertWithWhereUniqueWithoutCarsInput>
    createMany?: slabsCreateManyCarsInputEnvelope
    set?: Enumerable<slabsWhereUniqueInput>
    disconnect?: Enumerable<slabsWhereUniqueInput>
    delete?: Enumerable<slabsWhereUniqueInput>
    connect?: Enumerable<slabsWhereUniqueInput>
    update?: Enumerable<slabsUpdateWithWhereUniqueWithoutCarsInput>
    updateMany?: Enumerable<slabsUpdateManyWithWhereWithoutCarsInput>
    deleteMany?: Enumerable<slabsScalarWhereInput>
  }

  export type sub_servicesUpdateManyWithoutCarsNestedInput = {
    create?: XOR<Enumerable<sub_servicesCreateWithoutCarsInput>, Enumerable<sub_servicesUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<sub_servicesCreateOrConnectWithoutCarsInput>
    upsert?: Enumerable<sub_servicesUpsertWithWhereUniqueWithoutCarsInput>
    createMany?: sub_servicesCreateManyCarsInputEnvelope
    set?: Enumerable<sub_servicesWhereUniqueInput>
    disconnect?: Enumerable<sub_servicesWhereUniqueInput>
    delete?: Enumerable<sub_servicesWhereUniqueInput>
    connect?: Enumerable<sub_servicesWhereUniqueInput>
    update?: Enumerable<sub_servicesUpdateWithWhereUniqueWithoutCarsInput>
    updateMany?: Enumerable<sub_servicesUpdateManyWithWhereWithoutCarsInput>
    deleteMany?: Enumerable<sub_servicesScalarWhereInput>
  }

  export type toursUpdateManyWithoutCarsNestedInput = {
    create?: XOR<Enumerable<toursCreateWithoutCarsInput>, Enumerable<toursUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<toursCreateOrConnectWithoutCarsInput>
    upsert?: Enumerable<toursUpsertWithWhereUniqueWithoutCarsInput>
    createMany?: toursCreateManyCarsInputEnvelope
    set?: Enumerable<toursWhereUniqueInput>
    disconnect?: Enumerable<toursWhereUniqueInput>
    delete?: Enumerable<toursWhereUniqueInput>
    connect?: Enumerable<toursWhereUniqueInput>
    update?: Enumerable<toursUpdateWithWhereUniqueWithoutCarsInput>
    updateMany?: Enumerable<toursUpdateManyWithWhereWithoutCarsInput>
    deleteMany?: Enumerable<toursScalarWhereInput>
  }

  export type car_pricesUncheckedUpdateManyWithoutCarsNestedInput = {
    create?: XOR<Enumerable<car_pricesCreateWithoutCarsInput>, Enumerable<car_pricesUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<car_pricesCreateOrConnectWithoutCarsInput>
    upsert?: Enumerable<car_pricesUpsertWithWhereUniqueWithoutCarsInput>
    createMany?: car_pricesCreateManyCarsInputEnvelope
    set?: Enumerable<car_pricesWhereUniqueInput>
    disconnect?: Enumerable<car_pricesWhereUniqueInput>
    delete?: Enumerable<car_pricesWhereUniqueInput>
    connect?: Enumerable<car_pricesWhereUniqueInput>
    update?: Enumerable<car_pricesUpdateWithWhereUniqueWithoutCarsInput>
    updateMany?: Enumerable<car_pricesUpdateManyWithWhereWithoutCarsInput>
    deleteMany?: Enumerable<car_pricesScalarWhereInput>
  }

  export type package_serivceUncheckedUpdateManyWithoutCarsNestedInput = {
    create?: XOR<Enumerable<package_serivceCreateWithoutCarsInput>, Enumerable<package_serivceUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<package_serivceCreateOrConnectWithoutCarsInput>
    upsert?: Enumerable<package_serivceUpsertWithWhereUniqueWithoutCarsInput>
    createMany?: package_serivceCreateManyCarsInputEnvelope
    set?: Enumerable<package_serivceWhereUniqueInput>
    disconnect?: Enumerable<package_serivceWhereUniqueInput>
    delete?: Enumerable<package_serivceWhereUniqueInput>
    connect?: Enumerable<package_serivceWhereUniqueInput>
    update?: Enumerable<package_serivceUpdateWithWhereUniqueWithoutCarsInput>
    updateMany?: Enumerable<package_serivceUpdateManyWithWhereWithoutCarsInput>
    deleteMany?: Enumerable<package_serivceScalarWhereInput>
  }

  export type reservationsUncheckedUpdateManyWithoutCarsNestedInput = {
    create?: XOR<Enumerable<reservationsCreateWithoutCarsInput>, Enumerable<reservationsUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<reservationsCreateOrConnectWithoutCarsInput>
    upsert?: Enumerable<reservationsUpsertWithWhereUniqueWithoutCarsInput>
    createMany?: reservationsCreateManyCarsInputEnvelope
    set?: Enumerable<reservationsWhereUniqueInput>
    disconnect?: Enumerable<reservationsWhereUniqueInput>
    delete?: Enumerable<reservationsWhereUniqueInput>
    connect?: Enumerable<reservationsWhereUniqueInput>
    update?: Enumerable<reservationsUpdateWithWhereUniqueWithoutCarsInput>
    updateMany?: Enumerable<reservationsUpdateManyWithWhereWithoutCarsInput>
    deleteMany?: Enumerable<reservationsScalarWhereInput>
  }

  export type slabsUncheckedUpdateManyWithoutCarsNestedInput = {
    create?: XOR<Enumerable<slabsCreateWithoutCarsInput>, Enumerable<slabsUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<slabsCreateOrConnectWithoutCarsInput>
    upsert?: Enumerable<slabsUpsertWithWhereUniqueWithoutCarsInput>
    createMany?: slabsCreateManyCarsInputEnvelope
    set?: Enumerable<slabsWhereUniqueInput>
    disconnect?: Enumerable<slabsWhereUniqueInput>
    delete?: Enumerable<slabsWhereUniqueInput>
    connect?: Enumerable<slabsWhereUniqueInput>
    update?: Enumerable<slabsUpdateWithWhereUniqueWithoutCarsInput>
    updateMany?: Enumerable<slabsUpdateManyWithWhereWithoutCarsInput>
    deleteMany?: Enumerable<slabsScalarWhereInput>
  }

  export type sub_servicesUncheckedUpdateManyWithoutCarsNestedInput = {
    create?: XOR<Enumerable<sub_servicesCreateWithoutCarsInput>, Enumerable<sub_servicesUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<sub_servicesCreateOrConnectWithoutCarsInput>
    upsert?: Enumerable<sub_servicesUpsertWithWhereUniqueWithoutCarsInput>
    createMany?: sub_servicesCreateManyCarsInputEnvelope
    set?: Enumerable<sub_servicesWhereUniqueInput>
    disconnect?: Enumerable<sub_servicesWhereUniqueInput>
    delete?: Enumerable<sub_servicesWhereUniqueInput>
    connect?: Enumerable<sub_servicesWhereUniqueInput>
    update?: Enumerable<sub_servicesUpdateWithWhereUniqueWithoutCarsInput>
    updateMany?: Enumerable<sub_servicesUpdateManyWithWhereWithoutCarsInput>
    deleteMany?: Enumerable<sub_servicesScalarWhereInput>
  }

  export type toursUncheckedUpdateManyWithoutCarsNestedInput = {
    create?: XOR<Enumerable<toursCreateWithoutCarsInput>, Enumerable<toursUncheckedCreateWithoutCarsInput>>
    connectOrCreate?: Enumerable<toursCreateOrConnectWithoutCarsInput>
    upsert?: Enumerable<toursUpsertWithWhereUniqueWithoutCarsInput>
    createMany?: toursCreateManyCarsInputEnvelope
    set?: Enumerable<toursWhereUniqueInput>
    disconnect?: Enumerable<toursWhereUniqueInput>
    delete?: Enumerable<toursWhereUniqueInput>
    connect?: Enumerable<toursWhereUniqueInput>
    update?: Enumerable<toursUpdateWithWhereUniqueWithoutCarsInput>
    updateMany?: Enumerable<toursUpdateManyWithWhereWithoutCarsInput>
    deleteMany?: Enumerable<toursScalarWhereInput>
  }

  export type carsCreateNestedManyWithoutDriversInput = {
    create?: XOR<Enumerable<carsCreateWithoutDriversInput>, Enumerable<carsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutDriversInput>
    createMany?: carsCreateManyDriversInputEnvelope
    connect?: Enumerable<carsWhereUniqueInput>
  }

  export type carsUncheckedCreateNestedManyWithoutDriversInput = {
    create?: XOR<Enumerable<carsCreateWithoutDriversInput>, Enumerable<carsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutDriversInput>
    createMany?: carsCreateManyDriversInputEnvelope
    connect?: Enumerable<carsWhereUniqueInput>
  }

  export type carsUpdateManyWithoutDriversNestedInput = {
    create?: XOR<Enumerable<carsCreateWithoutDriversInput>, Enumerable<carsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutDriversInput>
    upsert?: Enumerable<carsUpsertWithWhereUniqueWithoutDriversInput>
    createMany?: carsCreateManyDriversInputEnvelope
    set?: Enumerable<carsWhereUniqueInput>
    disconnect?: Enumerable<carsWhereUniqueInput>
    delete?: Enumerable<carsWhereUniqueInput>
    connect?: Enumerable<carsWhereUniqueInput>
    update?: Enumerable<carsUpdateWithWhereUniqueWithoutDriversInput>
    updateMany?: Enumerable<carsUpdateManyWithWhereWithoutDriversInput>
    deleteMany?: Enumerable<carsScalarWhereInput>
  }

  export type carsUncheckedUpdateManyWithoutDriversNestedInput = {
    create?: XOR<Enumerable<carsCreateWithoutDriversInput>, Enumerable<carsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutDriversInput>
    upsert?: Enumerable<carsUpsertWithWhereUniqueWithoutDriversInput>
    createMany?: carsCreateManyDriversInputEnvelope
    set?: Enumerable<carsWhereUniqueInput>
    disconnect?: Enumerable<carsWhereUniqueInput>
    delete?: Enumerable<carsWhereUniqueInput>
    connect?: Enumerable<carsWhereUniqueInput>
    update?: Enumerable<carsUpdateWithWhereUniqueWithoutDriversInput>
    updateMany?: Enumerable<carsUpdateManyWithWhereWithoutDriversInput>
    deleteMany?: Enumerable<carsScalarWhereInput>
  }

  export type carsCreateNestedManyWithoutFuel_typesInput = {
    create?: XOR<Enumerable<carsCreateWithoutFuel_typesInput>, Enumerable<carsUncheckedCreateWithoutFuel_typesInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutFuel_typesInput>
    createMany?: carsCreateManyFuel_typesInputEnvelope
    connect?: Enumerable<carsWhereUniqueInput>
  }

  export type carsUncheckedCreateNestedManyWithoutFuel_typesInput = {
    create?: XOR<Enumerable<carsCreateWithoutFuel_typesInput>, Enumerable<carsUncheckedCreateWithoutFuel_typesInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutFuel_typesInput>
    createMany?: carsCreateManyFuel_typesInputEnvelope
    connect?: Enumerable<carsWhereUniqueInput>
  }

  export type carsUpdateManyWithoutFuel_typesNestedInput = {
    create?: XOR<Enumerable<carsCreateWithoutFuel_typesInput>, Enumerable<carsUncheckedCreateWithoutFuel_typesInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutFuel_typesInput>
    upsert?: Enumerable<carsUpsertWithWhereUniqueWithoutFuel_typesInput>
    createMany?: carsCreateManyFuel_typesInputEnvelope
    set?: Enumerable<carsWhereUniqueInput>
    disconnect?: Enumerable<carsWhereUniqueInput>
    delete?: Enumerable<carsWhereUniqueInput>
    connect?: Enumerable<carsWhereUniqueInput>
    update?: Enumerable<carsUpdateWithWhereUniqueWithoutFuel_typesInput>
    updateMany?: Enumerable<carsUpdateManyWithWhereWithoutFuel_typesInput>
    deleteMany?: Enumerable<carsScalarWhereInput>
  }

  export type carsUncheckedUpdateManyWithoutFuel_typesNestedInput = {
    create?: XOR<Enumerable<carsCreateWithoutFuel_typesInput>, Enumerable<carsUncheckedCreateWithoutFuel_typesInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutFuel_typesInput>
    upsert?: Enumerable<carsUpsertWithWhereUniqueWithoutFuel_typesInput>
    createMany?: carsCreateManyFuel_typesInputEnvelope
    set?: Enumerable<carsWhereUniqueInput>
    disconnect?: Enumerable<carsWhereUniqueInput>
    delete?: Enumerable<carsWhereUniqueInput>
    connect?: Enumerable<carsWhereUniqueInput>
    update?: Enumerable<carsUpdateWithWhereUniqueWithoutFuel_typesInput>
    updateMany?: Enumerable<carsUpdateManyWithWhereWithoutFuel_typesInput>
    deleteMany?: Enumerable<carsScalarWhereInput>
  }

  export type servicesCreateNestedOneWithoutGratuitiesInput = {
    create?: XOR<servicesCreateWithoutGratuitiesInput, servicesUncheckedCreateWithoutGratuitiesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutGratuitiesInput
    connect?: servicesWhereUniqueInput
  }

  export type servicesUpdateOneRequiredWithoutGratuitiesNestedInput = {
    create?: XOR<servicesCreateWithoutGratuitiesInput, servicesUncheckedCreateWithoutGratuitiesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutGratuitiesInput
    upsert?: servicesUpsertWithoutGratuitiesInput
    connect?: servicesWhereUniqueInput
    update?: XOR<servicesUpdateWithoutGratuitiesInput, servicesUncheckedUpdateWithoutGratuitiesInput>
  }

  export type servicesCreateNestedOneWithoutHourly_servicesInput = {
    create?: XOR<servicesCreateWithoutHourly_servicesInput, servicesUncheckedCreateWithoutHourly_servicesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutHourly_servicesInput
    connect?: servicesWhereUniqueInput
  }

  export type servicesUpdateOneRequiredWithoutHourly_servicesNestedInput = {
    create?: XOR<servicesCreateWithoutHourly_servicesInput, servicesUncheckedCreateWithoutHourly_servicesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutHourly_servicesInput
    upsert?: servicesUpsertWithoutHourly_servicesInput
    connect?: servicesWhereUniqueInput
    update?: XOR<servicesUpdateWithoutHourly_servicesInput, servicesUncheckedUpdateWithoutHourly_servicesInput>
  }

  export type carsCreateNestedManyWithoutManufacturersInput = {
    create?: XOR<Enumerable<carsCreateWithoutManufacturersInput>, Enumerable<carsUncheckedCreateWithoutManufacturersInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutManufacturersInput>
    createMany?: carsCreateManyManufacturersInputEnvelope
    connect?: Enumerable<carsWhereUniqueInput>
  }

  export type carsUncheckedCreateNestedManyWithoutManufacturersInput = {
    create?: XOR<Enumerable<carsCreateWithoutManufacturersInput>, Enumerable<carsUncheckedCreateWithoutManufacturersInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutManufacturersInput>
    createMany?: carsCreateManyManufacturersInputEnvelope
    connect?: Enumerable<carsWhereUniqueInput>
  }

  export type carsUpdateManyWithoutManufacturersNestedInput = {
    create?: XOR<Enumerable<carsCreateWithoutManufacturersInput>, Enumerable<carsUncheckedCreateWithoutManufacturersInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutManufacturersInput>
    upsert?: Enumerable<carsUpsertWithWhereUniqueWithoutManufacturersInput>
    createMany?: carsCreateManyManufacturersInputEnvelope
    set?: Enumerable<carsWhereUniqueInput>
    disconnect?: Enumerable<carsWhereUniqueInput>
    delete?: Enumerable<carsWhereUniqueInput>
    connect?: Enumerable<carsWhereUniqueInput>
    update?: Enumerable<carsUpdateWithWhereUniqueWithoutManufacturersInput>
    updateMany?: Enumerable<carsUpdateManyWithWhereWithoutManufacturersInput>
    deleteMany?: Enumerable<carsScalarWhereInput>
  }

  export type carsUncheckedUpdateManyWithoutManufacturersNestedInput = {
    create?: XOR<Enumerable<carsCreateWithoutManufacturersInput>, Enumerable<carsUncheckedCreateWithoutManufacturersInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutManufacturersInput>
    upsert?: Enumerable<carsUpsertWithWhereUniqueWithoutManufacturersInput>
    createMany?: carsCreateManyManufacturersInputEnvelope
    set?: Enumerable<carsWhereUniqueInput>
    disconnect?: Enumerable<carsWhereUniqueInput>
    delete?: Enumerable<carsWhereUniqueInput>
    connect?: Enumerable<carsWhereUniqueInput>
    update?: Enumerable<carsUpdateWithWhereUniqueWithoutManufacturersInput>
    updateMany?: Enumerable<carsUpdateManyWithWhereWithoutManufacturersInput>
    deleteMany?: Enumerable<carsScalarWhereInput>
  }

  export type servicesCreateNestedOneWithoutPoint_to_point_servicesInput = {
    create?: XOR<servicesCreateWithoutPoint_to_point_servicesInput, servicesUncheckedCreateWithoutPoint_to_point_servicesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutPoint_to_point_servicesInput
    connect?: servicesWhereUniqueInput
  }

  export type servicesUpdateOneRequiredWithoutPoint_to_point_servicesNestedInput = {
    create?: XOR<servicesCreateWithoutPoint_to_point_servicesInput, servicesUncheckedCreateWithoutPoint_to_point_servicesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutPoint_to_point_servicesInput
    upsert?: servicesUpsertWithoutPoint_to_point_servicesInput
    connect?: servicesWhereUniqueInput
    update?: XOR<servicesUpdateWithoutPoint_to_point_servicesInput, servicesUncheckedUpdateWithoutPoint_to_point_servicesInput>
  }

  export type carsCreateNestedOneWithoutReservationsInput = {
    create?: XOR<carsCreateWithoutReservationsInput, carsUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: carsCreateOrConnectWithoutReservationsInput
    connect?: carsWhereUniqueInput
  }

  export type sub_servicesCreateNestedOneWithoutReservationsInput = {
    create?: XOR<sub_servicesCreateWithoutReservationsInput, sub_servicesUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: sub_servicesCreateOrConnectWithoutReservationsInput
    connect?: sub_servicesWhereUniqueInput
  }

  export type carsUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<carsCreateWithoutReservationsInput, carsUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: carsCreateOrConnectWithoutReservationsInput
    upsert?: carsUpsertWithoutReservationsInput
    connect?: carsWhereUniqueInput
    update?: XOR<carsUpdateWithoutReservationsInput, carsUncheckedUpdateWithoutReservationsInput>
  }

  export type sub_servicesUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<sub_servicesCreateWithoutReservationsInput, sub_servicesUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: sub_servicesCreateOrConnectWithoutReservationsInput
    upsert?: sub_servicesUpsertWithoutReservationsInput
    connect?: sub_servicesWhereUniqueInput
    update?: XOR<sub_servicesUpdateWithoutReservationsInput, sub_servicesUncheckedUpdateWithoutReservationsInput>
  }

  export type rolesCreateNestedOneWithoutRole_usersInput = {
    create?: XOR<rolesCreateWithoutRole_usersInput, rolesUncheckedCreateWithoutRole_usersInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRole_usersInput
    connect?: rolesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutRole_usersInput = {
    create?: XOR<usersCreateWithoutRole_usersInput, usersUncheckedCreateWithoutRole_usersInput>
    connectOrCreate?: usersCreateOrConnectWithoutRole_usersInput
    connect?: usersWhereUniqueInput
  }

  export type rolesUpdateOneRequiredWithoutRole_usersNestedInput = {
    create?: XOR<rolesCreateWithoutRole_usersInput, rolesUncheckedCreateWithoutRole_usersInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRole_usersInput
    upsert?: rolesUpsertWithoutRole_usersInput
    connect?: rolesWhereUniqueInput
    update?: XOR<rolesUpdateWithoutRole_usersInput, rolesUncheckedUpdateWithoutRole_usersInput>
  }

  export type usersUpdateOneRequiredWithoutRole_usersNestedInput = {
    create?: XOR<usersCreateWithoutRole_usersInput, usersUncheckedCreateWithoutRole_usersInput>
    connectOrCreate?: usersCreateOrConnectWithoutRole_usersInput
    upsert?: usersUpsertWithoutRole_usersInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutRole_usersInput, usersUncheckedUpdateWithoutRole_usersInput>
  }

  export type role_usersCreateNestedManyWithoutRolesInput = {
    create?: XOR<Enumerable<role_usersCreateWithoutRolesInput>, Enumerable<role_usersUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<role_usersCreateOrConnectWithoutRolesInput>
    createMany?: role_usersCreateManyRolesInputEnvelope
    connect?: Enumerable<role_usersWhereUniqueInput>
  }

  export type role_usersUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<Enumerable<role_usersCreateWithoutRolesInput>, Enumerable<role_usersUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<role_usersCreateOrConnectWithoutRolesInput>
    createMany?: role_usersCreateManyRolesInputEnvelope
    connect?: Enumerable<role_usersWhereUniqueInput>
  }

  export type role_usersUpdateManyWithoutRolesNestedInput = {
    create?: XOR<Enumerable<role_usersCreateWithoutRolesInput>, Enumerable<role_usersUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<role_usersCreateOrConnectWithoutRolesInput>
    upsert?: Enumerable<role_usersUpsertWithWhereUniqueWithoutRolesInput>
    createMany?: role_usersCreateManyRolesInputEnvelope
    set?: Enumerable<role_usersWhereUniqueInput>
    disconnect?: Enumerable<role_usersWhereUniqueInput>
    delete?: Enumerable<role_usersWhereUniqueInput>
    connect?: Enumerable<role_usersWhereUniqueInput>
    update?: Enumerable<role_usersUpdateWithWhereUniqueWithoutRolesInput>
    updateMany?: Enumerable<role_usersUpdateManyWithWhereWithoutRolesInput>
    deleteMany?: Enumerable<role_usersScalarWhereInput>
  }

  export type role_usersUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<Enumerable<role_usersCreateWithoutRolesInput>, Enumerable<role_usersUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<role_usersCreateOrConnectWithoutRolesInput>
    upsert?: Enumerable<role_usersUpsertWithWhereUniqueWithoutRolesInput>
    createMany?: role_usersCreateManyRolesInputEnvelope
    set?: Enumerable<role_usersWhereUniqueInput>
    disconnect?: Enumerable<role_usersWhereUniqueInput>
    delete?: Enumerable<role_usersWhereUniqueInput>
    connect?: Enumerable<role_usersWhereUniqueInput>
    update?: Enumerable<role_usersUpdateWithWhereUniqueWithoutRolesInput>
    updateMany?: Enumerable<role_usersUpdateManyWithWhereWithoutRolesInput>
    deleteMany?: Enumerable<role_usersScalarWhereInput>
  }

  export type airport_servicesCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<airport_servicesCreateWithoutServicesInput>, Enumerable<airport_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<airport_servicesCreateOrConnectWithoutServicesInput>
    createMany?: airport_servicesCreateManyServicesInputEnvelope
    connect?: Enumerable<airport_servicesWhereUniqueInput>
  }

  export type gratuitiesCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<gratuitiesCreateWithoutServicesInput>, Enumerable<gratuitiesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<gratuitiesCreateOrConnectWithoutServicesInput>
    createMany?: gratuitiesCreateManyServicesInputEnvelope
    connect?: Enumerable<gratuitiesWhereUniqueInput>
  }

  export type hourly_servicesCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<hourly_servicesCreateWithoutServicesInput>, Enumerable<hourly_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<hourly_servicesCreateOrConnectWithoutServicesInput>
    createMany?: hourly_servicesCreateManyServicesInputEnvelope
    connect?: Enumerable<hourly_servicesWhereUniqueInput>
  }

  export type point_to_point_servicesCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<point_to_point_servicesCreateWithoutServicesInput>, Enumerable<point_to_point_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<point_to_point_servicesCreateOrConnectWithoutServicesInput>
    createMany?: point_to_point_servicesCreateManyServicesInputEnvelope
    connect?: Enumerable<point_to_point_servicesWhereUniqueInput>
  }

  export type sub_servicesCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<sub_servicesCreateWithoutServicesInput>, Enumerable<sub_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<sub_servicesCreateOrConnectWithoutServicesInput>
    createMany?: sub_servicesCreateManyServicesInputEnvelope
    connect?: Enumerable<sub_servicesWhereUniqueInput>
  }

  export type airport_servicesUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<airport_servicesCreateWithoutServicesInput>, Enumerable<airport_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<airport_servicesCreateOrConnectWithoutServicesInput>
    createMany?: airport_servicesCreateManyServicesInputEnvelope
    connect?: Enumerable<airport_servicesWhereUniqueInput>
  }

  export type gratuitiesUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<gratuitiesCreateWithoutServicesInput>, Enumerable<gratuitiesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<gratuitiesCreateOrConnectWithoutServicesInput>
    createMany?: gratuitiesCreateManyServicesInputEnvelope
    connect?: Enumerable<gratuitiesWhereUniqueInput>
  }

  export type hourly_servicesUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<hourly_servicesCreateWithoutServicesInput>, Enumerable<hourly_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<hourly_servicesCreateOrConnectWithoutServicesInput>
    createMany?: hourly_servicesCreateManyServicesInputEnvelope
    connect?: Enumerable<hourly_servicesWhereUniqueInput>
  }

  export type point_to_point_servicesUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<point_to_point_servicesCreateWithoutServicesInput>, Enumerable<point_to_point_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<point_to_point_servicesCreateOrConnectWithoutServicesInput>
    createMany?: point_to_point_servicesCreateManyServicesInputEnvelope
    connect?: Enumerable<point_to_point_servicesWhereUniqueInput>
  }

  export type sub_servicesUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<sub_servicesCreateWithoutServicesInput>, Enumerable<sub_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<sub_servicesCreateOrConnectWithoutServicesInput>
    createMany?: sub_servicesCreateManyServicesInputEnvelope
    connect?: Enumerable<sub_servicesWhereUniqueInput>
  }

  export type airport_servicesUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<airport_servicesCreateWithoutServicesInput>, Enumerable<airport_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<airport_servicesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<airport_servicesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: airport_servicesCreateManyServicesInputEnvelope
    set?: Enumerable<airport_servicesWhereUniqueInput>
    disconnect?: Enumerable<airport_servicesWhereUniqueInput>
    delete?: Enumerable<airport_servicesWhereUniqueInput>
    connect?: Enumerable<airport_servicesWhereUniqueInput>
    update?: Enumerable<airport_servicesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<airport_servicesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<airport_servicesScalarWhereInput>
  }

  export type gratuitiesUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<gratuitiesCreateWithoutServicesInput>, Enumerable<gratuitiesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<gratuitiesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<gratuitiesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: gratuitiesCreateManyServicesInputEnvelope
    set?: Enumerable<gratuitiesWhereUniqueInput>
    disconnect?: Enumerable<gratuitiesWhereUniqueInput>
    delete?: Enumerable<gratuitiesWhereUniqueInput>
    connect?: Enumerable<gratuitiesWhereUniqueInput>
    update?: Enumerable<gratuitiesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<gratuitiesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<gratuitiesScalarWhereInput>
  }

  export type hourly_servicesUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<hourly_servicesCreateWithoutServicesInput>, Enumerable<hourly_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<hourly_servicesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<hourly_servicesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: hourly_servicesCreateManyServicesInputEnvelope
    set?: Enumerable<hourly_servicesWhereUniqueInput>
    disconnect?: Enumerable<hourly_servicesWhereUniqueInput>
    delete?: Enumerable<hourly_servicesWhereUniqueInput>
    connect?: Enumerable<hourly_servicesWhereUniqueInput>
    update?: Enumerable<hourly_servicesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<hourly_servicesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<hourly_servicesScalarWhereInput>
  }

  export type point_to_point_servicesUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<point_to_point_servicesCreateWithoutServicesInput>, Enumerable<point_to_point_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<point_to_point_servicesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<point_to_point_servicesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: point_to_point_servicesCreateManyServicesInputEnvelope
    set?: Enumerable<point_to_point_servicesWhereUniqueInput>
    disconnect?: Enumerable<point_to_point_servicesWhereUniqueInput>
    delete?: Enumerable<point_to_point_servicesWhereUniqueInput>
    connect?: Enumerable<point_to_point_servicesWhereUniqueInput>
    update?: Enumerable<point_to_point_servicesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<point_to_point_servicesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<point_to_point_servicesScalarWhereInput>
  }

  export type sub_servicesUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<sub_servicesCreateWithoutServicesInput>, Enumerable<sub_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<sub_servicesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<sub_servicesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: sub_servicesCreateManyServicesInputEnvelope
    set?: Enumerable<sub_servicesWhereUniqueInput>
    disconnect?: Enumerable<sub_servicesWhereUniqueInput>
    delete?: Enumerable<sub_servicesWhereUniqueInput>
    connect?: Enumerable<sub_servicesWhereUniqueInput>
    update?: Enumerable<sub_servicesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<sub_servicesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<sub_servicesScalarWhereInput>
  }

  export type airport_servicesUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<airport_servicesCreateWithoutServicesInput>, Enumerable<airport_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<airport_servicesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<airport_servicesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: airport_servicesCreateManyServicesInputEnvelope
    set?: Enumerable<airport_servicesWhereUniqueInput>
    disconnect?: Enumerable<airport_servicesWhereUniqueInput>
    delete?: Enumerable<airport_servicesWhereUniqueInput>
    connect?: Enumerable<airport_servicesWhereUniqueInput>
    update?: Enumerable<airport_servicesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<airport_servicesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<airport_servicesScalarWhereInput>
  }

  export type gratuitiesUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<gratuitiesCreateWithoutServicesInput>, Enumerable<gratuitiesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<gratuitiesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<gratuitiesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: gratuitiesCreateManyServicesInputEnvelope
    set?: Enumerable<gratuitiesWhereUniqueInput>
    disconnect?: Enumerable<gratuitiesWhereUniqueInput>
    delete?: Enumerable<gratuitiesWhereUniqueInput>
    connect?: Enumerable<gratuitiesWhereUniqueInput>
    update?: Enumerable<gratuitiesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<gratuitiesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<gratuitiesScalarWhereInput>
  }

  export type hourly_servicesUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<hourly_servicesCreateWithoutServicesInput>, Enumerable<hourly_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<hourly_servicesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<hourly_servicesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: hourly_servicesCreateManyServicesInputEnvelope
    set?: Enumerable<hourly_servicesWhereUniqueInput>
    disconnect?: Enumerable<hourly_servicesWhereUniqueInput>
    delete?: Enumerable<hourly_servicesWhereUniqueInput>
    connect?: Enumerable<hourly_servicesWhereUniqueInput>
    update?: Enumerable<hourly_servicesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<hourly_servicesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<hourly_servicesScalarWhereInput>
  }

  export type point_to_point_servicesUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<point_to_point_servicesCreateWithoutServicesInput>, Enumerable<point_to_point_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<point_to_point_servicesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<point_to_point_servicesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: point_to_point_servicesCreateManyServicesInputEnvelope
    set?: Enumerable<point_to_point_servicesWhereUniqueInput>
    disconnect?: Enumerable<point_to_point_servicesWhereUniqueInput>
    delete?: Enumerable<point_to_point_servicesWhereUniqueInput>
    connect?: Enumerable<point_to_point_servicesWhereUniqueInput>
    update?: Enumerable<point_to_point_servicesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<point_to_point_servicesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<point_to_point_servicesScalarWhereInput>
  }

  export type sub_servicesUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<sub_servicesCreateWithoutServicesInput>, Enumerable<sub_servicesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<sub_servicesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<sub_servicesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: sub_servicesCreateManyServicesInputEnvelope
    set?: Enumerable<sub_servicesWhereUniqueInput>
    disconnect?: Enumerable<sub_servicesWhereUniqueInput>
    delete?: Enumerable<sub_servicesWhereUniqueInput>
    connect?: Enumerable<sub_servicesWhereUniqueInput>
    update?: Enumerable<sub_servicesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<sub_servicesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<sub_servicesScalarWhereInput>
  }

  export type carsCreateNestedOneWithoutToursInput = {
    create?: XOR<carsCreateWithoutToursInput, carsUncheckedCreateWithoutToursInput>
    connectOrCreate?: carsCreateOrConnectWithoutToursInput
    connect?: carsWhereUniqueInput
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type carsUpdateOneWithoutToursNestedInput = {
    create?: XOR<carsCreateWithoutToursInput, carsUncheckedCreateWithoutToursInput>
    connectOrCreate?: carsCreateOrConnectWithoutToursInput
    upsert?: carsUpsertWithoutToursInput
    disconnect?: boolean
    delete?: boolean
    connect?: carsWhereUniqueInput
    update?: XOR<carsUpdateWithoutToursInput, carsUncheckedUpdateWithoutToursInput>
  }

  export type carsCreateNestedManyWithoutTransmissionsInput = {
    create?: XOR<Enumerable<carsCreateWithoutTransmissionsInput>, Enumerable<carsUncheckedCreateWithoutTransmissionsInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutTransmissionsInput>
    createMany?: carsCreateManyTransmissionsInputEnvelope
    connect?: Enumerable<carsWhereUniqueInput>
  }

  export type carsUncheckedCreateNestedManyWithoutTransmissionsInput = {
    create?: XOR<Enumerable<carsCreateWithoutTransmissionsInput>, Enumerable<carsUncheckedCreateWithoutTransmissionsInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutTransmissionsInput>
    createMany?: carsCreateManyTransmissionsInputEnvelope
    connect?: Enumerable<carsWhereUniqueInput>
  }

  export type carsUpdateManyWithoutTransmissionsNestedInput = {
    create?: XOR<Enumerable<carsCreateWithoutTransmissionsInput>, Enumerable<carsUncheckedCreateWithoutTransmissionsInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutTransmissionsInput>
    upsert?: Enumerable<carsUpsertWithWhereUniqueWithoutTransmissionsInput>
    createMany?: carsCreateManyTransmissionsInputEnvelope
    set?: Enumerable<carsWhereUniqueInput>
    disconnect?: Enumerable<carsWhereUniqueInput>
    delete?: Enumerable<carsWhereUniqueInput>
    connect?: Enumerable<carsWhereUniqueInput>
    update?: Enumerable<carsUpdateWithWhereUniqueWithoutTransmissionsInput>
    updateMany?: Enumerable<carsUpdateManyWithWhereWithoutTransmissionsInput>
    deleteMany?: Enumerable<carsScalarWhereInput>
  }

  export type carsUncheckedUpdateManyWithoutTransmissionsNestedInput = {
    create?: XOR<Enumerable<carsCreateWithoutTransmissionsInput>, Enumerable<carsUncheckedCreateWithoutTransmissionsInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutTransmissionsInput>
    upsert?: Enumerable<carsUpsertWithWhereUniqueWithoutTransmissionsInput>
    createMany?: carsCreateManyTransmissionsInputEnvelope
    set?: Enumerable<carsWhereUniqueInput>
    disconnect?: Enumerable<carsWhereUniqueInput>
    delete?: Enumerable<carsWhereUniqueInput>
    connect?: Enumerable<carsWhereUniqueInput>
    update?: Enumerable<carsUpdateWithWhereUniqueWithoutTransmissionsInput>
    updateMany?: Enumerable<carsUpdateManyWithWhereWithoutTransmissionsInput>
    deleteMany?: Enumerable<carsScalarWhereInput>
  }

  export type role_usersCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<role_usersCreateWithoutUsersInput>, Enumerable<role_usersUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<role_usersCreateOrConnectWithoutUsersInput>
    createMany?: role_usersCreateManyUsersInputEnvelope
    connect?: Enumerable<role_usersWhereUniqueInput>
  }

  export type role_usersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<role_usersCreateWithoutUsersInput>, Enumerable<role_usersUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<role_usersCreateOrConnectWithoutUsersInput>
    createMany?: role_usersCreateManyUsersInputEnvelope
    connect?: Enumerable<role_usersWhereUniqueInput>
  }

  export type role_usersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<role_usersCreateWithoutUsersInput>, Enumerable<role_usersUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<role_usersCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<role_usersUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: role_usersCreateManyUsersInputEnvelope
    set?: Enumerable<role_usersWhereUniqueInput>
    disconnect?: Enumerable<role_usersWhereUniqueInput>
    delete?: Enumerable<role_usersWhereUniqueInput>
    connect?: Enumerable<role_usersWhereUniqueInput>
    update?: Enumerable<role_usersUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<role_usersUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<role_usersScalarWhereInput>
  }

  export type role_usersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<role_usersCreateWithoutUsersInput>, Enumerable<role_usersUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<role_usersCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<role_usersUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: role_usersCreateManyUsersInputEnvelope
    set?: Enumerable<role_usersWhereUniqueInput>
    disconnect?: Enumerable<role_usersWhereUniqueInput>
    delete?: Enumerable<role_usersWhereUniqueInput>
    connect?: Enumerable<role_usersWhereUniqueInput>
    update?: Enumerable<role_usersUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<role_usersUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<role_usersScalarWhereInput>
  }

  export type carsCreateNestedOneWithoutPackage_serivceInput = {
    create?: XOR<carsCreateWithoutPackage_serivceInput, carsUncheckedCreateWithoutPackage_serivceInput>
    connectOrCreate?: carsCreateOrConnectWithoutPackage_serivceInput
    connect?: carsWhereUniqueInput
  }

  export type carsUpdateOneRequiredWithoutPackage_serivceNestedInput = {
    create?: XOR<carsCreateWithoutPackage_serivceInput, carsUncheckedCreateWithoutPackage_serivceInput>
    connectOrCreate?: carsCreateOrConnectWithoutPackage_serivceInput
    upsert?: carsUpsertWithoutPackage_serivceInput
    connect?: carsWhereUniqueInput
    update?: XOR<carsUpdateWithoutPackage_serivceInput, carsUncheckedUpdateWithoutPackage_serivceInput>
  }

  export type carsCreateNestedOneWithoutSlabsInput = {
    create?: XOR<carsCreateWithoutSlabsInput, carsUncheckedCreateWithoutSlabsInput>
    connectOrCreate?: carsCreateOrConnectWithoutSlabsInput
    connect?: carsWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type carsUpdateOneRequiredWithoutSlabsNestedInput = {
    create?: XOR<carsCreateWithoutSlabsInput, carsUncheckedCreateWithoutSlabsInput>
    connectOrCreate?: carsCreateOrConnectWithoutSlabsInput
    upsert?: carsUpsertWithoutSlabsInput
    connect?: carsWhereUniqueInput
    update?: XOR<carsUpdateWithoutSlabsInput, carsUncheckedUpdateWithoutSlabsInput>
  }

  export type sub_servicesCreateNestedOneWithoutTimeslotsInput = {
    create?: XOR<sub_servicesCreateWithoutTimeslotsInput, sub_servicesUncheckedCreateWithoutTimeslotsInput>
    connectOrCreate?: sub_servicesCreateOrConnectWithoutTimeslotsInput
    connect?: sub_servicesWhereUniqueInput
  }

  export type sub_servicesUpdateOneWithoutTimeslotsNestedInput = {
    create?: XOR<sub_servicesCreateWithoutTimeslotsInput, sub_servicesUncheckedCreateWithoutTimeslotsInput>
    connectOrCreate?: sub_servicesCreateOrConnectWithoutTimeslotsInput
    upsert?: sub_servicesUpsertWithoutTimeslotsInput
    disconnect?: boolean
    delete?: boolean
    connect?: sub_servicesWhereUniqueInput
    update?: XOR<sub_servicesUpdateWithoutTimeslotsInput, sub_servicesUncheckedUpdateWithoutTimeslotsInput>
  }

  export type carsCreateNestedManyWithoutVehicle_typesInput = {
    create?: XOR<Enumerable<carsCreateWithoutVehicle_typesInput>, Enumerable<carsUncheckedCreateWithoutVehicle_typesInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutVehicle_typesInput>
    createMany?: carsCreateManyVehicle_typesInputEnvelope
    connect?: Enumerable<carsWhereUniqueInput>
  }

  export type carsUncheckedCreateNestedManyWithoutVehicle_typesInput = {
    create?: XOR<Enumerable<carsCreateWithoutVehicle_typesInput>, Enumerable<carsUncheckedCreateWithoutVehicle_typesInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutVehicle_typesInput>
    createMany?: carsCreateManyVehicle_typesInputEnvelope
    connect?: Enumerable<carsWhereUniqueInput>
  }

  export type carsUpdateManyWithoutVehicle_typesNestedInput = {
    create?: XOR<Enumerable<carsCreateWithoutVehicle_typesInput>, Enumerable<carsUncheckedCreateWithoutVehicle_typesInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutVehicle_typesInput>
    upsert?: Enumerable<carsUpsertWithWhereUniqueWithoutVehicle_typesInput>
    createMany?: carsCreateManyVehicle_typesInputEnvelope
    set?: Enumerable<carsWhereUniqueInput>
    disconnect?: Enumerable<carsWhereUniqueInput>
    delete?: Enumerable<carsWhereUniqueInput>
    connect?: Enumerable<carsWhereUniqueInput>
    update?: Enumerable<carsUpdateWithWhereUniqueWithoutVehicle_typesInput>
    updateMany?: Enumerable<carsUpdateManyWithWhereWithoutVehicle_typesInput>
    deleteMany?: Enumerable<carsScalarWhereInput>
  }

  export type carsUncheckedUpdateManyWithoutVehicle_typesNestedInput = {
    create?: XOR<Enumerable<carsCreateWithoutVehicle_typesInput>, Enumerable<carsUncheckedCreateWithoutVehicle_typesInput>>
    connectOrCreate?: Enumerable<carsCreateOrConnectWithoutVehicle_typesInput>
    upsert?: Enumerable<carsUpsertWithWhereUniqueWithoutVehicle_typesInput>
    createMany?: carsCreateManyVehicle_typesInputEnvelope
    set?: Enumerable<carsWhereUniqueInput>
    disconnect?: Enumerable<carsWhereUniqueInput>
    delete?: Enumerable<carsWhereUniqueInput>
    connect?: Enumerable<carsWhereUniqueInput>
    update?: Enumerable<carsUpdateWithWhereUniqueWithoutVehicle_typesInput>
    updateMany?: Enumerable<carsUpdateManyWithWhereWithoutVehicle_typesInput>
    deleteMany?: Enumerable<carsScalarWhereInput>
  }

  export type reservationsCreateNestedManyWithoutSub_servicesInput = {
    create?: XOR<Enumerable<reservationsCreateWithoutSub_servicesInput>, Enumerable<reservationsUncheckedCreateWithoutSub_servicesInput>>
    connectOrCreate?: Enumerable<reservationsCreateOrConnectWithoutSub_servicesInput>
    createMany?: reservationsCreateManySub_servicesInputEnvelope
    connect?: Enumerable<reservationsWhereUniqueInput>
  }

  export type servicesCreateNestedOneWithoutSub_servicesInput = {
    create?: XOR<servicesCreateWithoutSub_servicesInput, servicesUncheckedCreateWithoutSub_servicesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutSub_servicesInput
    connect?: servicesWhereUniqueInput
  }

  export type carsCreateNestedOneWithoutSub_servicesInput = {
    create?: XOR<carsCreateWithoutSub_servicesInput, carsUncheckedCreateWithoutSub_servicesInput>
    connectOrCreate?: carsCreateOrConnectWithoutSub_servicesInput
    connect?: carsWhereUniqueInput
  }

  export type timeslotsCreateNestedManyWithoutSub_servicesInput = {
    create?: XOR<Enumerable<timeslotsCreateWithoutSub_servicesInput>, Enumerable<timeslotsUncheckedCreateWithoutSub_servicesInput>>
    connectOrCreate?: Enumerable<timeslotsCreateOrConnectWithoutSub_servicesInput>
    createMany?: timeslotsCreateManySub_servicesInputEnvelope
    connect?: Enumerable<timeslotsWhereUniqueInput>
  }

  export type reservationsUncheckedCreateNestedManyWithoutSub_servicesInput = {
    create?: XOR<Enumerable<reservationsCreateWithoutSub_servicesInput>, Enumerable<reservationsUncheckedCreateWithoutSub_servicesInput>>
    connectOrCreate?: Enumerable<reservationsCreateOrConnectWithoutSub_servicesInput>
    createMany?: reservationsCreateManySub_servicesInputEnvelope
    connect?: Enumerable<reservationsWhereUniqueInput>
  }

  export type timeslotsUncheckedCreateNestedManyWithoutSub_servicesInput = {
    create?: XOR<Enumerable<timeslotsCreateWithoutSub_servicesInput>, Enumerable<timeslotsUncheckedCreateWithoutSub_servicesInput>>
    connectOrCreate?: Enumerable<timeslotsCreateOrConnectWithoutSub_servicesInput>
    createMany?: timeslotsCreateManySub_servicesInputEnvelope
    connect?: Enumerable<timeslotsWhereUniqueInput>
  }

  export type reservationsUpdateManyWithoutSub_servicesNestedInput = {
    create?: XOR<Enumerable<reservationsCreateWithoutSub_servicesInput>, Enumerable<reservationsUncheckedCreateWithoutSub_servicesInput>>
    connectOrCreate?: Enumerable<reservationsCreateOrConnectWithoutSub_servicesInput>
    upsert?: Enumerable<reservationsUpsertWithWhereUniqueWithoutSub_servicesInput>
    createMany?: reservationsCreateManySub_servicesInputEnvelope
    set?: Enumerable<reservationsWhereUniqueInput>
    disconnect?: Enumerable<reservationsWhereUniqueInput>
    delete?: Enumerable<reservationsWhereUniqueInput>
    connect?: Enumerable<reservationsWhereUniqueInput>
    update?: Enumerable<reservationsUpdateWithWhereUniqueWithoutSub_servicesInput>
    updateMany?: Enumerable<reservationsUpdateManyWithWhereWithoutSub_servicesInput>
    deleteMany?: Enumerable<reservationsScalarWhereInput>
  }

  export type servicesUpdateOneRequiredWithoutSub_servicesNestedInput = {
    create?: XOR<servicesCreateWithoutSub_servicesInput, servicesUncheckedCreateWithoutSub_servicesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutSub_servicesInput
    upsert?: servicesUpsertWithoutSub_servicesInput
    connect?: servicesWhereUniqueInput
    update?: XOR<servicesUpdateWithoutSub_servicesInput, servicesUncheckedUpdateWithoutSub_servicesInput>
  }

  export type carsUpdateOneWithoutSub_servicesNestedInput = {
    create?: XOR<carsCreateWithoutSub_servicesInput, carsUncheckedCreateWithoutSub_servicesInput>
    connectOrCreate?: carsCreateOrConnectWithoutSub_servicesInput
    upsert?: carsUpsertWithoutSub_servicesInput
    disconnect?: boolean
    delete?: boolean
    connect?: carsWhereUniqueInput
    update?: XOR<carsUpdateWithoutSub_servicesInput, carsUncheckedUpdateWithoutSub_servicesInput>
  }

  export type timeslotsUpdateManyWithoutSub_servicesNestedInput = {
    create?: XOR<Enumerable<timeslotsCreateWithoutSub_servicesInput>, Enumerable<timeslotsUncheckedCreateWithoutSub_servicesInput>>
    connectOrCreate?: Enumerable<timeslotsCreateOrConnectWithoutSub_servicesInput>
    upsert?: Enumerable<timeslotsUpsertWithWhereUniqueWithoutSub_servicesInput>
    createMany?: timeslotsCreateManySub_servicesInputEnvelope
    set?: Enumerable<timeslotsWhereUniqueInput>
    disconnect?: Enumerable<timeslotsWhereUniqueInput>
    delete?: Enumerable<timeslotsWhereUniqueInput>
    connect?: Enumerable<timeslotsWhereUniqueInput>
    update?: Enumerable<timeslotsUpdateWithWhereUniqueWithoutSub_servicesInput>
    updateMany?: Enumerable<timeslotsUpdateManyWithWhereWithoutSub_servicesInput>
    deleteMany?: Enumerable<timeslotsScalarWhereInput>
  }

  export type reservationsUncheckedUpdateManyWithoutSub_servicesNestedInput = {
    create?: XOR<Enumerable<reservationsCreateWithoutSub_servicesInput>, Enumerable<reservationsUncheckedCreateWithoutSub_servicesInput>>
    connectOrCreate?: Enumerable<reservationsCreateOrConnectWithoutSub_servicesInput>
    upsert?: Enumerable<reservationsUpsertWithWhereUniqueWithoutSub_servicesInput>
    createMany?: reservationsCreateManySub_servicesInputEnvelope
    set?: Enumerable<reservationsWhereUniqueInput>
    disconnect?: Enumerable<reservationsWhereUniqueInput>
    delete?: Enumerable<reservationsWhereUniqueInput>
    connect?: Enumerable<reservationsWhereUniqueInput>
    update?: Enumerable<reservationsUpdateWithWhereUniqueWithoutSub_servicesInput>
    updateMany?: Enumerable<reservationsUpdateManyWithWhereWithoutSub_servicesInput>
    deleteMany?: Enumerable<reservationsScalarWhereInput>
  }

  export type timeslotsUncheckedUpdateManyWithoutSub_servicesNestedInput = {
    create?: XOR<Enumerable<timeslotsCreateWithoutSub_servicesInput>, Enumerable<timeslotsUncheckedCreateWithoutSub_servicesInput>>
    connectOrCreate?: Enumerable<timeslotsCreateOrConnectWithoutSub_servicesInput>
    upsert?: Enumerable<timeslotsUpsertWithWhereUniqueWithoutSub_servicesInput>
    createMany?: timeslotsCreateManySub_servicesInputEnvelope
    set?: Enumerable<timeslotsWhereUniqueInput>
    disconnect?: Enumerable<timeslotsWhereUniqueInput>
    delete?: Enumerable<timeslotsWhereUniqueInput>
    connect?: Enumerable<timeslotsWhereUniqueInput>
    update?: Enumerable<timeslotsUpdateWithWhereUniqueWithoutSub_servicesInput>
    updateMany?: Enumerable<timeslotsUpdateManyWithWhereWithoutSub_servicesInput>
    deleteMany?: Enumerable<timeslotsScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedEnumcars_car_typeNullableFilter = {
    equals?: cars_car_type | null
    in?: Enumerable<cars_car_type> | null
    notIn?: Enumerable<cars_car_type> | null
    not?: NestedEnumcars_car_typeNullableFilter | cars_car_type | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedEnumcars_car_typeNullableWithAggregatesFilter = {
    equals?: cars_car_type | null
    in?: Enumerable<cars_car_type> | null
    notIn?: Enumerable<cars_car_type> | null
    not?: NestedEnumcars_car_typeNullableWithAggregatesFilter | cars_car_type | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumcars_car_typeNullableFilter
    _max?: NestedEnumcars_car_typeNullableFilter
  }

  export type NestedBytesNullableFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type NestedBytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type servicesCreateWithoutAirport_servicesInput = {
    Name?: string | null
    Status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    gratuities?: gratuitiesCreateNestedManyWithoutServicesInput
    hourly_services?: hourly_servicesCreateNestedManyWithoutServicesInput
    point_to_point_services?: point_to_point_servicesCreateNestedManyWithoutServicesInput
    sub_services?: sub_servicesCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutAirport_servicesInput = {
    id?: number
    Name?: string | null
    Status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    gratuities?: gratuitiesUncheckedCreateNestedManyWithoutServicesInput
    hourly_services?: hourly_servicesUncheckedCreateNestedManyWithoutServicesInput
    point_to_point_services?: point_to_point_servicesUncheckedCreateNestedManyWithoutServicesInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesCreateOrConnectWithoutAirport_servicesInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutAirport_servicesInput, servicesUncheckedCreateWithoutAirport_servicesInput>
  }

  export type servicesUpsertWithoutAirport_servicesInput = {
    update: XOR<servicesUpdateWithoutAirport_servicesInput, servicesUncheckedUpdateWithoutAirport_servicesInput>
    create: XOR<servicesCreateWithoutAirport_servicesInput, servicesUncheckedCreateWithoutAirport_servicesInput>
  }

  export type servicesUpdateWithoutAirport_servicesInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gratuities?: gratuitiesUpdateManyWithoutServicesNestedInput
    hourly_services?: hourly_servicesUpdateManyWithoutServicesNestedInput
    point_to_point_services?: point_to_point_servicesUpdateManyWithoutServicesNestedInput
    sub_services?: sub_servicesUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutAirport_servicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gratuities?: gratuitiesUncheckedUpdateManyWithoutServicesNestedInput
    hourly_services?: hourly_servicesUncheckedUpdateManyWithoutServicesNestedInput
    point_to_point_services?: point_to_point_servicesUncheckedUpdateManyWithoutServicesNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type carsCreateWithoutBody_typesInput = {
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesCreateNestedManyWithoutCarsInput
    drivers: driversCreateNestedOneWithoutCarsInput
    fuel_types: fuel_typesCreateNestedOneWithoutCarsInput
    manufacturers: manufacturersCreateNestedOneWithoutCarsInput
    transmissions: transmissionsCreateNestedOneWithoutCarsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutCarsInput
    package_serivce?: package_serivceCreateNestedManyWithoutCarsInput
    reservations?: reservationsCreateNestedManyWithoutCarsInput
    slabs?: slabsCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesCreateNestedManyWithoutCarsInput
    tours?: toursCreateNestedManyWithoutCarsInput
  }

  export type carsUncheckedCreateWithoutBody_typesInput = {
    id?: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesUncheckedCreateNestedManyWithoutCarsInput
    package_serivce?: package_serivceUncheckedCreateNestedManyWithoutCarsInput
    reservations?: reservationsUncheckedCreateNestedManyWithoutCarsInput
    slabs?: slabsUncheckedCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutCarsInput
    tours?: toursUncheckedCreateNestedManyWithoutCarsInput
  }

  export type carsCreateOrConnectWithoutBody_typesInput = {
    where: carsWhereUniqueInput
    create: XOR<carsCreateWithoutBody_typesInput, carsUncheckedCreateWithoutBody_typesInput>
  }

  export type carsCreateManyBody_typesInputEnvelope = {
    data: Enumerable<carsCreateManyBody_typesInput>
    skipDuplicates?: boolean
  }

  export type carsUpsertWithWhereUniqueWithoutBody_typesInput = {
    where: carsWhereUniqueInput
    update: XOR<carsUpdateWithoutBody_typesInput, carsUncheckedUpdateWithoutBody_typesInput>
    create: XOR<carsCreateWithoutBody_typesInput, carsUncheckedCreateWithoutBody_typesInput>
  }

  export type carsUpdateWithWhereUniqueWithoutBody_typesInput = {
    where: carsWhereUniqueInput
    data: XOR<carsUpdateWithoutBody_typesInput, carsUncheckedUpdateWithoutBody_typesInput>
  }

  export type carsUpdateManyWithWhereWithoutBody_typesInput = {
    where: carsScalarWhereInput
    data: XOR<carsUpdateManyMutationInput, carsUncheckedUpdateManyWithoutCarsInput>
  }

  export type carsScalarWhereInput = {
    AND?: Enumerable<carsScalarWhereInput>
    OR?: Enumerable<carsScalarWhereInput>
    NOT?: Enumerable<carsScalarWhereInput>
    id?: IntFilter | number
    body_type_id?: IntFilter | number
    transmission_id?: IntFilter | number
    manufacturer_id?: IntFilter | number
    driver_id?: IntFilter | number
    fuel_id?: IntFilter | number
    vehicle_type_id?: IntFilter | number
    car_model?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    qty?: StringNullableFilter | string | null
    passenger_seats?: IntNullableFilter | number | null
    maximum_luggage?: IntNullableFilter | number | null
    total_doors?: IntNullableFilter | number | null
    child_seat?: IntNullableFilter | number | null
    image?: StringNullableFilter | string | null
    status?: BoolNullableFilter | boolean | null
    per_mile_rate?: FloatNullableFilter | number | null
    hourly_rate?: FloatNullableFilter | number | null
    minimum_fare?: FloatNullableFilter | number | null
    minimum_hours?: IntNullableFilter | number | null
    fixed_price?: FloatNullableFilter | number | null
    is_slab_enabled?: BoolNullableFilter | boolean | null
    is_loc_enabled?: BoolNullableFilter | boolean | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    isActive?: BoolNullableFilter | boolean | null
    car_type?: Enumcars_car_typeNullableFilter | cars_car_type | null
  }

  export type car_pricesCreateWithoutCar_price_typesInput = {
    monday?: number | null
    tuesday?: number | null
    wednesday?: number | null
    thursday?: number | null
    friday?: number | null
    saturday?: number | null
    sunday?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    cars: carsCreateNestedOneWithoutCar_pricesInput
  }

  export type car_pricesUncheckedCreateWithoutCar_price_typesInput = {
    id?: number
    car_id: number
    monday?: number | null
    tuesday?: number | null
    wednesday?: number | null
    thursday?: number | null
    friday?: number | null
    saturday?: number | null
    sunday?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type car_pricesCreateOrConnectWithoutCar_price_typesInput = {
    where: car_pricesWhereUniqueInput
    create: XOR<car_pricesCreateWithoutCar_price_typesInput, car_pricesUncheckedCreateWithoutCar_price_typesInput>
  }

  export type car_pricesCreateManyCar_price_typesInputEnvelope = {
    data: Enumerable<car_pricesCreateManyCar_price_typesInput>
    skipDuplicates?: boolean
  }

  export type car_pricesUpsertWithWhereUniqueWithoutCar_price_typesInput = {
    where: car_pricesWhereUniqueInput
    update: XOR<car_pricesUpdateWithoutCar_price_typesInput, car_pricesUncheckedUpdateWithoutCar_price_typesInput>
    create: XOR<car_pricesCreateWithoutCar_price_typesInput, car_pricesUncheckedCreateWithoutCar_price_typesInput>
  }

  export type car_pricesUpdateWithWhereUniqueWithoutCar_price_typesInput = {
    where: car_pricesWhereUniqueInput
    data: XOR<car_pricesUpdateWithoutCar_price_typesInput, car_pricesUncheckedUpdateWithoutCar_price_typesInput>
  }

  export type car_pricesUpdateManyWithWhereWithoutCar_price_typesInput = {
    where: car_pricesScalarWhereInput
    data: XOR<car_pricesUpdateManyMutationInput, car_pricesUncheckedUpdateManyWithoutCar_pricesInput>
  }

  export type car_pricesScalarWhereInput = {
    AND?: Enumerable<car_pricesScalarWhereInput>
    OR?: Enumerable<car_pricesScalarWhereInput>
    NOT?: Enumerable<car_pricesScalarWhereInput>
    id?: IntFilter | number
    car_id?: IntFilter | number
    car_price_type_id?: IntFilter | number
    monday?: IntNullableFilter | number | null
    tuesday?: IntNullableFilter | number | null
    wednesday?: IntNullableFilter | number | null
    thursday?: IntNullableFilter | number | null
    friday?: IntNullableFilter | number | null
    saturday?: IntNullableFilter | number | null
    sunday?: IntNullableFilter | number | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type carsCreateWithoutCar_pricesInput = {
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    body_types: body_typesCreateNestedOneWithoutCarsInput
    drivers: driversCreateNestedOneWithoutCarsInput
    fuel_types: fuel_typesCreateNestedOneWithoutCarsInput
    manufacturers: manufacturersCreateNestedOneWithoutCarsInput
    transmissions: transmissionsCreateNestedOneWithoutCarsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutCarsInput
    package_serivce?: package_serivceCreateNestedManyWithoutCarsInput
    reservations?: reservationsCreateNestedManyWithoutCarsInput
    slabs?: slabsCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesCreateNestedManyWithoutCarsInput
    tours?: toursCreateNestedManyWithoutCarsInput
  }

  export type carsUncheckedCreateWithoutCar_pricesInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    package_serivce?: package_serivceUncheckedCreateNestedManyWithoutCarsInput
    reservations?: reservationsUncheckedCreateNestedManyWithoutCarsInput
    slabs?: slabsUncheckedCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutCarsInput
    tours?: toursUncheckedCreateNestedManyWithoutCarsInput
  }

  export type carsCreateOrConnectWithoutCar_pricesInput = {
    where: carsWhereUniqueInput
    create: XOR<carsCreateWithoutCar_pricesInput, carsUncheckedCreateWithoutCar_pricesInput>
  }

  export type car_price_typesCreateWithoutCar_pricesInput = {
    name?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type car_price_typesUncheckedCreateWithoutCar_pricesInput = {
    id?: number
    name?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type car_price_typesCreateOrConnectWithoutCar_pricesInput = {
    where: car_price_typesWhereUniqueInput
    create: XOR<car_price_typesCreateWithoutCar_pricesInput, car_price_typesUncheckedCreateWithoutCar_pricesInput>
  }

  export type carsUpsertWithoutCar_pricesInput = {
    update: XOR<carsUpdateWithoutCar_pricesInput, carsUncheckedUpdateWithoutCar_pricesInput>
    create: XOR<carsCreateWithoutCar_pricesInput, carsUncheckedCreateWithoutCar_pricesInput>
  }

  export type carsUpdateWithoutCar_pricesInput = {
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    body_types?: body_typesUpdateOneRequiredWithoutCarsNestedInput
    drivers?: driversUpdateOneRequiredWithoutCarsNestedInput
    fuel_types?: fuel_typesUpdateOneRequiredWithoutCarsNestedInput
    manufacturers?: manufacturersUpdateOneRequiredWithoutCarsNestedInput
    transmissions?: transmissionsUpdateOneRequiredWithoutCarsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutCarsNestedInput
    package_serivce?: package_serivceUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUpdateManyWithoutCarsNestedInput
    slabs?: slabsUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUpdateManyWithoutCarsNestedInput
    tours?: toursUpdateManyWithoutCarsNestedInput
  }

  export type carsUncheckedUpdateWithoutCar_pricesInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type_id?: IntFieldUpdateOperationsInput | number
    transmission_id?: IntFieldUpdateOperationsInput | number
    manufacturer_id?: IntFieldUpdateOperationsInput | number
    driver_id?: IntFieldUpdateOperationsInput | number
    fuel_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    package_serivce?: package_serivceUncheckedUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUncheckedUpdateManyWithoutCarsNestedInput
    slabs?: slabsUncheckedUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutCarsNestedInput
    tours?: toursUncheckedUpdateManyWithoutCarsNestedInput
  }

  export type car_price_typesUpsertWithoutCar_pricesInput = {
    update: XOR<car_price_typesUpdateWithoutCar_pricesInput, car_price_typesUncheckedUpdateWithoutCar_pricesInput>
    create: XOR<car_price_typesCreateWithoutCar_pricesInput, car_price_typesUncheckedCreateWithoutCar_pricesInput>
  }

  export type car_price_typesUpdateWithoutCar_pricesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type car_price_typesUncheckedUpdateWithoutCar_pricesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type car_pricesCreateWithoutCarsInput = {
    monday?: number | null
    tuesday?: number | null
    wednesday?: number | null
    thursday?: number | null
    friday?: number | null
    saturday?: number | null
    sunday?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    car_price_types: car_price_typesCreateNestedOneWithoutCar_pricesInput
  }

  export type car_pricesUncheckedCreateWithoutCarsInput = {
    id?: number
    car_price_type_id: number
    monday?: number | null
    tuesday?: number | null
    wednesday?: number | null
    thursday?: number | null
    friday?: number | null
    saturday?: number | null
    sunday?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type car_pricesCreateOrConnectWithoutCarsInput = {
    where: car_pricesWhereUniqueInput
    create: XOR<car_pricesCreateWithoutCarsInput, car_pricesUncheckedCreateWithoutCarsInput>
  }

  export type car_pricesCreateManyCarsInputEnvelope = {
    data: Enumerable<car_pricesCreateManyCarsInput>
    skipDuplicates?: boolean
  }

  export type body_typesCreateWithoutCarsInput = {
    body_type?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type body_typesUncheckedCreateWithoutCarsInput = {
    id?: number
    body_type?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type body_typesCreateOrConnectWithoutCarsInput = {
    where: body_typesWhereUniqueInput
    create: XOR<body_typesCreateWithoutCarsInput, body_typesUncheckedCreateWithoutCarsInput>
  }

  export type driversCreateWithoutCarsInput = {
    name?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type driversUncheckedCreateWithoutCarsInput = {
    id?: number
    name?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type driversCreateOrConnectWithoutCarsInput = {
    where: driversWhereUniqueInput
    create: XOR<driversCreateWithoutCarsInput, driversUncheckedCreateWithoutCarsInput>
  }

  export type fuel_typesCreateWithoutCarsInput = {
    fuel_type?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type fuel_typesUncheckedCreateWithoutCarsInput = {
    id?: number
    fuel_type?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type fuel_typesCreateOrConnectWithoutCarsInput = {
    where: fuel_typesWhereUniqueInput
    create: XOR<fuel_typesCreateWithoutCarsInput, fuel_typesUncheckedCreateWithoutCarsInput>
  }

  export type manufacturersCreateWithoutCarsInput = {
    Manufacturer?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type manufacturersUncheckedCreateWithoutCarsInput = {
    id?: number
    Manufacturer?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type manufacturersCreateOrConnectWithoutCarsInput = {
    where: manufacturersWhereUniqueInput
    create: XOR<manufacturersCreateWithoutCarsInput, manufacturersUncheckedCreateWithoutCarsInput>
  }

  export type transmissionsCreateWithoutCarsInput = {
    transmission?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type transmissionsUncheckedCreateWithoutCarsInput = {
    id?: number
    transmission?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type transmissionsCreateOrConnectWithoutCarsInput = {
    where: transmissionsWhereUniqueInput
    create: XOR<transmissionsCreateWithoutCarsInput, transmissionsUncheckedCreateWithoutCarsInput>
  }

  export type vehicle_typesCreateWithoutCarsInput = {
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type vehicle_typesUncheckedCreateWithoutCarsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type vehicle_typesCreateOrConnectWithoutCarsInput = {
    where: vehicle_typesWhereUniqueInput
    create: XOR<vehicle_typesCreateWithoutCarsInput, vehicle_typesUncheckedCreateWithoutCarsInput>
  }

  export type package_serivceCreateWithoutCarsInput = {
    name?: string | null
    description?: string | null
    passenger_capacity: number
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    luggage?: number | null
  }

  export type package_serivceUncheckedCreateWithoutCarsInput = {
    id?: number
    name?: string | null
    description?: string | null
    passenger_capacity: number
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    luggage?: number | null
  }

  export type package_serivceCreateOrConnectWithoutCarsInput = {
    where: package_serivceWhereUniqueInput
    create: XOR<package_serivceCreateWithoutCarsInput, package_serivceUncheckedCreateWithoutCarsInput>
  }

  export type package_serivceCreateManyCarsInputEnvelope = {
    data: Enumerable<package_serivceCreateManyCarsInput>
    skipDuplicates?: boolean
  }

  export type reservationsCreateWithoutCarsInput = {
    order_number?: string | null
    pick_up_postal_code?: string | null
    pick_up_lat?: number | null
    pick_up_lon?: number | null
    pick_up_loc_name?: string | null
    drop_off_postal_code?: string | null
    drop_off_lat?: number | null
    drop_off_lon?: number | null
    drop_off_loc_name?: string | null
    pick_up_date?: Date | string | null
    price?: number | null
    tax?: number | null
    airline?: string | null
    flight_no?: string | null
    no_of_hours?: number | null
    maximum_passenger?: number | null
    maximum_luggage?: number | null
    customer_first_name?: string | null
    customer_last_name?: string | null
    customer_cnic?: string | null
    customer_email?: string | null
    customer_phone?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    uuid?: string
    payment_method?: string | null
    isPaid?: number | null
    special_instruction?: string | null
    sub_services: sub_servicesCreateNestedOneWithoutReservationsInput
  }

  export type reservationsUncheckedCreateWithoutCarsInput = {
    id?: number
    order_number?: string | null
    service_id: number
    pick_up_postal_code?: string | null
    pick_up_lat?: number | null
    pick_up_lon?: number | null
    pick_up_loc_name?: string | null
    drop_off_postal_code?: string | null
    drop_off_lat?: number | null
    drop_off_lon?: number | null
    drop_off_loc_name?: string | null
    pick_up_date?: Date | string | null
    price?: number | null
    tax?: number | null
    airline?: string | null
    flight_no?: string | null
    no_of_hours?: number | null
    maximum_passenger?: number | null
    maximum_luggage?: number | null
    customer_first_name?: string | null
    customer_last_name?: string | null
    customer_cnic?: string | null
    customer_email?: string | null
    customer_phone?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    uuid?: string
    payment_method?: string | null
    isPaid?: number | null
    special_instruction?: string | null
  }

  export type reservationsCreateOrConnectWithoutCarsInput = {
    where: reservationsWhereUniqueInput
    create: XOR<reservationsCreateWithoutCarsInput, reservationsUncheckedCreateWithoutCarsInput>
  }

  export type reservationsCreateManyCarsInputEnvelope = {
    data: Enumerable<reservationsCreateManyCarsInput>
    skipDuplicates?: boolean
  }

  export type slabsCreateWithoutCarsInput = {
    initial_distance: number
    final_distance: number
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type slabsUncheckedCreateWithoutCarsInput = {
    id?: number
    initial_distance: number
    final_distance: number
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type slabsCreateOrConnectWithoutCarsInput = {
    where: slabsWhereUniqueInput
    create: XOR<slabsCreateWithoutCarsInput, slabsUncheckedCreateWithoutCarsInput>
  }

  export type slabsCreateManyCarsInputEnvelope = {
    data: Enumerable<slabsCreateManyCarsInput>
    skipDuplicates?: boolean
  }

  export type sub_servicesCreateWithoutCarsInput = {
    name?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    description?: string | null
    luggage?: number | null
    passenger_capacity?: number | null
    reservations?: reservationsCreateNestedManyWithoutSub_servicesInput
    services: servicesCreateNestedOneWithoutSub_servicesInput
    timeslots?: timeslotsCreateNestedManyWithoutSub_servicesInput
  }

  export type sub_servicesUncheckedCreateWithoutCarsInput = {
    id?: number
    name?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    service_id: number
    description?: string | null
    luggage?: number | null
    passenger_capacity?: number | null
    reservations?: reservationsUncheckedCreateNestedManyWithoutSub_servicesInput
    timeslots?: timeslotsUncheckedCreateNestedManyWithoutSub_servicesInput
  }

  export type sub_servicesCreateOrConnectWithoutCarsInput = {
    where: sub_servicesWhereUniqueInput
    create: XOR<sub_servicesCreateWithoutCarsInput, sub_servicesUncheckedCreateWithoutCarsInput>
  }

  export type sub_servicesCreateManyCarsInputEnvelope = {
    data: Enumerable<sub_servicesCreateManyCarsInput>
    skipDuplicates?: boolean
  }

  export type toursCreateWithoutCarsInput = {
    title?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    description?: string | null
    luggage?: number | null
  }

  export type toursUncheckedCreateWithoutCarsInput = {
    id?: number
    title?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    description?: string | null
    luggage?: number | null
  }

  export type toursCreateOrConnectWithoutCarsInput = {
    where: toursWhereUniqueInput
    create: XOR<toursCreateWithoutCarsInput, toursUncheckedCreateWithoutCarsInput>
  }

  export type toursCreateManyCarsInputEnvelope = {
    data: Enumerable<toursCreateManyCarsInput>
    skipDuplicates?: boolean
  }

  export type car_pricesUpsertWithWhereUniqueWithoutCarsInput = {
    where: car_pricesWhereUniqueInput
    update: XOR<car_pricesUpdateWithoutCarsInput, car_pricesUncheckedUpdateWithoutCarsInput>
    create: XOR<car_pricesCreateWithoutCarsInput, car_pricesUncheckedCreateWithoutCarsInput>
  }

  export type car_pricesUpdateWithWhereUniqueWithoutCarsInput = {
    where: car_pricesWhereUniqueInput
    data: XOR<car_pricesUpdateWithoutCarsInput, car_pricesUncheckedUpdateWithoutCarsInput>
  }

  export type car_pricesUpdateManyWithWhereWithoutCarsInput = {
    where: car_pricesScalarWhereInput
    data: XOR<car_pricesUpdateManyMutationInput, car_pricesUncheckedUpdateManyWithoutCar_pricesInput>
  }

  export type body_typesUpsertWithoutCarsInput = {
    update: XOR<body_typesUpdateWithoutCarsInput, body_typesUncheckedUpdateWithoutCarsInput>
    create: XOR<body_typesCreateWithoutCarsInput, body_typesUncheckedCreateWithoutCarsInput>
  }

  export type body_typesUpdateWithoutCarsInput = {
    body_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type body_typesUncheckedUpdateWithoutCarsInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type driversUpsertWithoutCarsInput = {
    update: XOR<driversUpdateWithoutCarsInput, driversUncheckedUpdateWithoutCarsInput>
    create: XOR<driversCreateWithoutCarsInput, driversUncheckedCreateWithoutCarsInput>
  }

  export type driversUpdateWithoutCarsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type driversUncheckedUpdateWithoutCarsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type fuel_typesUpsertWithoutCarsInput = {
    update: XOR<fuel_typesUpdateWithoutCarsInput, fuel_typesUncheckedUpdateWithoutCarsInput>
    create: XOR<fuel_typesCreateWithoutCarsInput, fuel_typesUncheckedCreateWithoutCarsInput>
  }

  export type fuel_typesUpdateWithoutCarsInput = {
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type fuel_typesUncheckedUpdateWithoutCarsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type manufacturersUpsertWithoutCarsInput = {
    update: XOR<manufacturersUpdateWithoutCarsInput, manufacturersUncheckedUpdateWithoutCarsInput>
    create: XOR<manufacturersCreateWithoutCarsInput, manufacturersUncheckedCreateWithoutCarsInput>
  }

  export type manufacturersUpdateWithoutCarsInput = {
    Manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type manufacturersUncheckedUpdateWithoutCarsInput = {
    id?: IntFieldUpdateOperationsInput | number
    Manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transmissionsUpsertWithoutCarsInput = {
    update: XOR<transmissionsUpdateWithoutCarsInput, transmissionsUncheckedUpdateWithoutCarsInput>
    create: XOR<transmissionsCreateWithoutCarsInput, transmissionsUncheckedCreateWithoutCarsInput>
  }

  export type transmissionsUpdateWithoutCarsInput = {
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transmissionsUncheckedUpdateWithoutCarsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_typesUpsertWithoutCarsInput = {
    update: XOR<vehicle_typesUpdateWithoutCarsInput, vehicle_typesUncheckedUpdateWithoutCarsInput>
    create: XOR<vehicle_typesCreateWithoutCarsInput, vehicle_typesUncheckedCreateWithoutCarsInput>
  }

  export type vehicle_typesUpdateWithoutCarsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_typesUncheckedUpdateWithoutCarsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type package_serivceUpsertWithWhereUniqueWithoutCarsInput = {
    where: package_serivceWhereUniqueInput
    update: XOR<package_serivceUpdateWithoutCarsInput, package_serivceUncheckedUpdateWithoutCarsInput>
    create: XOR<package_serivceCreateWithoutCarsInput, package_serivceUncheckedCreateWithoutCarsInput>
  }

  export type package_serivceUpdateWithWhereUniqueWithoutCarsInput = {
    where: package_serivceWhereUniqueInput
    data: XOR<package_serivceUpdateWithoutCarsInput, package_serivceUncheckedUpdateWithoutCarsInput>
  }

  export type package_serivceUpdateManyWithWhereWithoutCarsInput = {
    where: package_serivceScalarWhereInput
    data: XOR<package_serivceUpdateManyMutationInput, package_serivceUncheckedUpdateManyWithoutPackage_serivceInput>
  }

  export type package_serivceScalarWhereInput = {
    AND?: Enumerable<package_serivceScalarWhereInput>
    OR?: Enumerable<package_serivceScalarWhereInput>
    NOT?: Enumerable<package_serivceScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    passenger_capacity?: IntFilter | number
    price?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    car_id?: IntFilter | number
    isActive?: BoolNullableFilter | boolean | null
    pickup_location?: StringNullableFilter | string | null
    pickup_lat?: FloatNullableFilter | number | null
    pickup_lng?: FloatNullableFilter | number | null
    dropoff_location?: StringNullableFilter | string | null
    dropoff_lat?: FloatNullableFilter | number | null
    dropoff_lng?: FloatNullableFilter | number | null
    luggage?: IntNullableFilter | number | null
  }

  export type reservationsUpsertWithWhereUniqueWithoutCarsInput = {
    where: reservationsWhereUniqueInput
    update: XOR<reservationsUpdateWithoutCarsInput, reservationsUncheckedUpdateWithoutCarsInput>
    create: XOR<reservationsCreateWithoutCarsInput, reservationsUncheckedCreateWithoutCarsInput>
  }

  export type reservationsUpdateWithWhereUniqueWithoutCarsInput = {
    where: reservationsWhereUniqueInput
    data: XOR<reservationsUpdateWithoutCarsInput, reservationsUncheckedUpdateWithoutCarsInput>
  }

  export type reservationsUpdateManyWithWhereWithoutCarsInput = {
    where: reservationsScalarWhereInput
    data: XOR<reservationsUpdateManyMutationInput, reservationsUncheckedUpdateManyWithoutReservationsInput>
  }

  export type reservationsScalarWhereInput = {
    AND?: Enumerable<reservationsScalarWhereInput>
    OR?: Enumerable<reservationsScalarWhereInput>
    NOT?: Enumerable<reservationsScalarWhereInput>
    id?: IntFilter | number
    order_number?: StringNullableFilter | string | null
    service_id?: IntFilter | number
    car_id?: IntFilter | number
    pick_up_postal_code?: StringNullableFilter | string | null
    pick_up_lat?: FloatNullableFilter | number | null
    pick_up_lon?: FloatNullableFilter | number | null
    pick_up_loc_name?: StringNullableFilter | string | null
    drop_off_postal_code?: StringNullableFilter | string | null
    drop_off_lat?: FloatNullableFilter | number | null
    drop_off_lon?: FloatNullableFilter | number | null
    drop_off_loc_name?: StringNullableFilter | string | null
    pick_up_date?: DateTimeNullableFilter | Date | string | null
    price?: FloatNullableFilter | number | null
    tax?: FloatNullableFilter | number | null
    airline?: StringNullableFilter | string | null
    flight_no?: StringNullableFilter | string | null
    no_of_hours?: IntNullableFilter | number | null
    maximum_passenger?: IntNullableFilter | number | null
    maximum_luggage?: IntNullableFilter | number | null
    customer_first_name?: StringNullableFilter | string | null
    customer_last_name?: StringNullableFilter | string | null
    customer_cnic?: StringNullableFilter | string | null
    customer_email?: StringNullableFilter | string | null
    customer_phone?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    payment_method?: StringNullableFilter | string | null
    isPaid?: IntNullableFilter | number | null
    special_instruction?: StringNullableFilter | string | null
  }

  export type slabsUpsertWithWhereUniqueWithoutCarsInput = {
    where: slabsWhereUniqueInput
    update: XOR<slabsUpdateWithoutCarsInput, slabsUncheckedUpdateWithoutCarsInput>
    create: XOR<slabsCreateWithoutCarsInput, slabsUncheckedCreateWithoutCarsInput>
  }

  export type slabsUpdateWithWhereUniqueWithoutCarsInput = {
    where: slabsWhereUniqueInput
    data: XOR<slabsUpdateWithoutCarsInput, slabsUncheckedUpdateWithoutCarsInput>
  }

  export type slabsUpdateManyWithWhereWithoutCarsInput = {
    where: slabsScalarWhereInput
    data: XOR<slabsUpdateManyMutationInput, slabsUncheckedUpdateManyWithoutSlabsInput>
  }

  export type slabsScalarWhereInput = {
    AND?: Enumerable<slabsScalarWhereInput>
    OR?: Enumerable<slabsScalarWhereInput>
    NOT?: Enumerable<slabsScalarWhereInput>
    id?: IntFilter | number
    car_id?: IntFilter | number
    initial_distance?: FloatFilter | number
    final_distance?: FloatFilter | number
    price?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type sub_servicesUpsertWithWhereUniqueWithoutCarsInput = {
    where: sub_servicesWhereUniqueInput
    update: XOR<sub_servicesUpdateWithoutCarsInput, sub_servicesUncheckedUpdateWithoutCarsInput>
    create: XOR<sub_servicesCreateWithoutCarsInput, sub_servicesUncheckedCreateWithoutCarsInput>
  }

  export type sub_servicesUpdateWithWhereUniqueWithoutCarsInput = {
    where: sub_servicesWhereUniqueInput
    data: XOR<sub_servicesUpdateWithoutCarsInput, sub_servicesUncheckedUpdateWithoutCarsInput>
  }

  export type sub_servicesUpdateManyWithWhereWithoutCarsInput = {
    where: sub_servicesScalarWhereInput
    data: XOR<sub_servicesUpdateManyMutationInput, sub_servicesUncheckedUpdateManyWithoutSub_servicesInput>
  }

  export type sub_servicesScalarWhereInput = {
    AND?: Enumerable<sub_servicesScalarWhereInput>
    OR?: Enumerable<sub_servicesScalarWhereInput>
    NOT?: Enumerable<sub_servicesScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    pickup_location?: StringNullableFilter | string | null
    pickup_lat?: FloatNullableFilter | number | null
    pickup_lng?: FloatNullableFilter | number | null
    dropoff_location?: StringNullableFilter | string | null
    dropoff_lat?: FloatNullableFilter | number | null
    dropoff_lng?: FloatNullableFilter | number | null
    price_per_passenger?: IntNullableFilter | number | null
    status?: BytesNullableFilter | Buffer | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    isActive?: BoolNullableFilter | boolean | null
    car_id?: IntNullableFilter | number | null
    service_id?: IntFilter | number
    description?: StringNullableFilter | string | null
    luggage?: IntNullableFilter | number | null
    passenger_capacity?: IntNullableFilter | number | null
  }

  export type toursUpsertWithWhereUniqueWithoutCarsInput = {
    where: toursWhereUniqueInput
    update: XOR<toursUpdateWithoutCarsInput, toursUncheckedUpdateWithoutCarsInput>
    create: XOR<toursCreateWithoutCarsInput, toursUncheckedCreateWithoutCarsInput>
  }

  export type toursUpdateWithWhereUniqueWithoutCarsInput = {
    where: toursWhereUniqueInput
    data: XOR<toursUpdateWithoutCarsInput, toursUncheckedUpdateWithoutCarsInput>
  }

  export type toursUpdateManyWithWhereWithoutCarsInput = {
    where: toursScalarWhereInput
    data: XOR<toursUpdateManyMutationInput, toursUncheckedUpdateManyWithoutToursInput>
  }

  export type toursScalarWhereInput = {
    AND?: Enumerable<toursScalarWhereInput>
    OR?: Enumerable<toursScalarWhereInput>
    NOT?: Enumerable<toursScalarWhereInput>
    id?: IntFilter | number
    title?: StringNullableFilter | string | null
    pickup_location?: StringNullableFilter | string | null
    pickup_lat?: FloatNullableFilter | number | null
    pickup_lng?: FloatNullableFilter | number | null
    dropoff_location?: StringNullableFilter | string | null
    dropoff_lat?: FloatNullableFilter | number | null
    dropoff_lng?: FloatNullableFilter | number | null
    price_per_passenger?: IntNullableFilter | number | null
    status?: BytesNullableFilter | Buffer | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    isActive?: BoolNullableFilter | boolean | null
    car_id?: IntNullableFilter | number | null
    description?: StringNullableFilter | string | null
    luggage?: IntNullableFilter | number | null
  }

  export type carsCreateWithoutDriversInput = {
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesCreateNestedManyWithoutCarsInput
    body_types: body_typesCreateNestedOneWithoutCarsInput
    fuel_types: fuel_typesCreateNestedOneWithoutCarsInput
    manufacturers: manufacturersCreateNestedOneWithoutCarsInput
    transmissions: transmissionsCreateNestedOneWithoutCarsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutCarsInput
    package_serivce?: package_serivceCreateNestedManyWithoutCarsInput
    reservations?: reservationsCreateNestedManyWithoutCarsInput
    slabs?: slabsCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesCreateNestedManyWithoutCarsInput
    tours?: toursCreateNestedManyWithoutCarsInput
  }

  export type carsUncheckedCreateWithoutDriversInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesUncheckedCreateNestedManyWithoutCarsInput
    package_serivce?: package_serivceUncheckedCreateNestedManyWithoutCarsInput
    reservations?: reservationsUncheckedCreateNestedManyWithoutCarsInput
    slabs?: slabsUncheckedCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutCarsInput
    tours?: toursUncheckedCreateNestedManyWithoutCarsInput
  }

  export type carsCreateOrConnectWithoutDriversInput = {
    where: carsWhereUniqueInput
    create: XOR<carsCreateWithoutDriversInput, carsUncheckedCreateWithoutDriversInput>
  }

  export type carsCreateManyDriversInputEnvelope = {
    data: Enumerable<carsCreateManyDriversInput>
    skipDuplicates?: boolean
  }

  export type carsUpsertWithWhereUniqueWithoutDriversInput = {
    where: carsWhereUniqueInput
    update: XOR<carsUpdateWithoutDriversInput, carsUncheckedUpdateWithoutDriversInput>
    create: XOR<carsCreateWithoutDriversInput, carsUncheckedCreateWithoutDriversInput>
  }

  export type carsUpdateWithWhereUniqueWithoutDriversInput = {
    where: carsWhereUniqueInput
    data: XOR<carsUpdateWithoutDriversInput, carsUncheckedUpdateWithoutDriversInput>
  }

  export type carsUpdateManyWithWhereWithoutDriversInput = {
    where: carsScalarWhereInput
    data: XOR<carsUpdateManyMutationInput, carsUncheckedUpdateManyWithoutCarsInput>
  }

  export type carsCreateWithoutFuel_typesInput = {
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesCreateNestedManyWithoutCarsInput
    body_types: body_typesCreateNestedOneWithoutCarsInput
    drivers: driversCreateNestedOneWithoutCarsInput
    manufacturers: manufacturersCreateNestedOneWithoutCarsInput
    transmissions: transmissionsCreateNestedOneWithoutCarsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutCarsInput
    package_serivce?: package_serivceCreateNestedManyWithoutCarsInput
    reservations?: reservationsCreateNestedManyWithoutCarsInput
    slabs?: slabsCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesCreateNestedManyWithoutCarsInput
    tours?: toursCreateNestedManyWithoutCarsInput
  }

  export type carsUncheckedCreateWithoutFuel_typesInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesUncheckedCreateNestedManyWithoutCarsInput
    package_serivce?: package_serivceUncheckedCreateNestedManyWithoutCarsInput
    reservations?: reservationsUncheckedCreateNestedManyWithoutCarsInput
    slabs?: slabsUncheckedCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutCarsInput
    tours?: toursUncheckedCreateNestedManyWithoutCarsInput
  }

  export type carsCreateOrConnectWithoutFuel_typesInput = {
    where: carsWhereUniqueInput
    create: XOR<carsCreateWithoutFuel_typesInput, carsUncheckedCreateWithoutFuel_typesInput>
  }

  export type carsCreateManyFuel_typesInputEnvelope = {
    data: Enumerable<carsCreateManyFuel_typesInput>
    skipDuplicates?: boolean
  }

  export type carsUpsertWithWhereUniqueWithoutFuel_typesInput = {
    where: carsWhereUniqueInput
    update: XOR<carsUpdateWithoutFuel_typesInput, carsUncheckedUpdateWithoutFuel_typesInput>
    create: XOR<carsCreateWithoutFuel_typesInput, carsUncheckedCreateWithoutFuel_typesInput>
  }

  export type carsUpdateWithWhereUniqueWithoutFuel_typesInput = {
    where: carsWhereUniqueInput
    data: XOR<carsUpdateWithoutFuel_typesInput, carsUncheckedUpdateWithoutFuel_typesInput>
  }

  export type carsUpdateManyWithWhereWithoutFuel_typesInput = {
    where: carsScalarWhereInput
    data: XOR<carsUpdateManyMutationInput, carsUncheckedUpdateManyWithoutCarsInput>
  }

  export type servicesCreateWithoutGratuitiesInput = {
    Name?: string | null
    Status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    airport_services?: airport_servicesCreateNestedManyWithoutServicesInput
    hourly_services?: hourly_servicesCreateNestedManyWithoutServicesInput
    point_to_point_services?: point_to_point_servicesCreateNestedManyWithoutServicesInput
    sub_services?: sub_servicesCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutGratuitiesInput = {
    id?: number
    Name?: string | null
    Status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    airport_services?: airport_servicesUncheckedCreateNestedManyWithoutServicesInput
    hourly_services?: hourly_servicesUncheckedCreateNestedManyWithoutServicesInput
    point_to_point_services?: point_to_point_servicesUncheckedCreateNestedManyWithoutServicesInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesCreateOrConnectWithoutGratuitiesInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutGratuitiesInput, servicesUncheckedCreateWithoutGratuitiesInput>
  }

  export type servicesUpsertWithoutGratuitiesInput = {
    update: XOR<servicesUpdateWithoutGratuitiesInput, servicesUncheckedUpdateWithoutGratuitiesInput>
    create: XOR<servicesCreateWithoutGratuitiesInput, servicesUncheckedCreateWithoutGratuitiesInput>
  }

  export type servicesUpdateWithoutGratuitiesInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    airport_services?: airport_servicesUpdateManyWithoutServicesNestedInput
    hourly_services?: hourly_servicesUpdateManyWithoutServicesNestedInput
    point_to_point_services?: point_to_point_servicesUpdateManyWithoutServicesNestedInput
    sub_services?: sub_servicesUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutGratuitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    airport_services?: airport_servicesUncheckedUpdateManyWithoutServicesNestedInput
    hourly_services?: hourly_servicesUncheckedUpdateManyWithoutServicesNestedInput
    point_to_point_services?: point_to_point_servicesUncheckedUpdateManyWithoutServicesNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type servicesCreateWithoutHourly_servicesInput = {
    Name?: string | null
    Status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    airport_services?: airport_servicesCreateNestedManyWithoutServicesInput
    gratuities?: gratuitiesCreateNestedManyWithoutServicesInput
    point_to_point_services?: point_to_point_servicesCreateNestedManyWithoutServicesInput
    sub_services?: sub_servicesCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutHourly_servicesInput = {
    id?: number
    Name?: string | null
    Status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    airport_services?: airport_servicesUncheckedCreateNestedManyWithoutServicesInput
    gratuities?: gratuitiesUncheckedCreateNestedManyWithoutServicesInput
    point_to_point_services?: point_to_point_servicesUncheckedCreateNestedManyWithoutServicesInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesCreateOrConnectWithoutHourly_servicesInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutHourly_servicesInput, servicesUncheckedCreateWithoutHourly_servicesInput>
  }

  export type servicesUpsertWithoutHourly_servicesInput = {
    update: XOR<servicesUpdateWithoutHourly_servicesInput, servicesUncheckedUpdateWithoutHourly_servicesInput>
    create: XOR<servicesCreateWithoutHourly_servicesInput, servicesUncheckedCreateWithoutHourly_servicesInput>
  }

  export type servicesUpdateWithoutHourly_servicesInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    airport_services?: airport_servicesUpdateManyWithoutServicesNestedInput
    gratuities?: gratuitiesUpdateManyWithoutServicesNestedInput
    point_to_point_services?: point_to_point_servicesUpdateManyWithoutServicesNestedInput
    sub_services?: sub_servicesUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutHourly_servicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    airport_services?: airport_servicesUncheckedUpdateManyWithoutServicesNestedInput
    gratuities?: gratuitiesUncheckedUpdateManyWithoutServicesNestedInput
    point_to_point_services?: point_to_point_servicesUncheckedUpdateManyWithoutServicesNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type carsCreateWithoutManufacturersInput = {
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesCreateNestedManyWithoutCarsInput
    body_types: body_typesCreateNestedOneWithoutCarsInput
    drivers: driversCreateNestedOneWithoutCarsInput
    fuel_types: fuel_typesCreateNestedOneWithoutCarsInput
    transmissions: transmissionsCreateNestedOneWithoutCarsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutCarsInput
    package_serivce?: package_serivceCreateNestedManyWithoutCarsInput
    reservations?: reservationsCreateNestedManyWithoutCarsInput
    slabs?: slabsCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesCreateNestedManyWithoutCarsInput
    tours?: toursCreateNestedManyWithoutCarsInput
  }

  export type carsUncheckedCreateWithoutManufacturersInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesUncheckedCreateNestedManyWithoutCarsInput
    package_serivce?: package_serivceUncheckedCreateNestedManyWithoutCarsInput
    reservations?: reservationsUncheckedCreateNestedManyWithoutCarsInput
    slabs?: slabsUncheckedCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutCarsInput
    tours?: toursUncheckedCreateNestedManyWithoutCarsInput
  }

  export type carsCreateOrConnectWithoutManufacturersInput = {
    where: carsWhereUniqueInput
    create: XOR<carsCreateWithoutManufacturersInput, carsUncheckedCreateWithoutManufacturersInput>
  }

  export type carsCreateManyManufacturersInputEnvelope = {
    data: Enumerable<carsCreateManyManufacturersInput>
    skipDuplicates?: boolean
  }

  export type carsUpsertWithWhereUniqueWithoutManufacturersInput = {
    where: carsWhereUniqueInput
    update: XOR<carsUpdateWithoutManufacturersInput, carsUncheckedUpdateWithoutManufacturersInput>
    create: XOR<carsCreateWithoutManufacturersInput, carsUncheckedCreateWithoutManufacturersInput>
  }

  export type carsUpdateWithWhereUniqueWithoutManufacturersInput = {
    where: carsWhereUniqueInput
    data: XOR<carsUpdateWithoutManufacturersInput, carsUncheckedUpdateWithoutManufacturersInput>
  }

  export type carsUpdateManyWithWhereWithoutManufacturersInput = {
    where: carsScalarWhereInput
    data: XOR<carsUpdateManyMutationInput, carsUncheckedUpdateManyWithoutCarsInput>
  }

  export type servicesCreateWithoutPoint_to_point_servicesInput = {
    Name?: string | null
    Status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    airport_services?: airport_servicesCreateNestedManyWithoutServicesInput
    gratuities?: gratuitiesCreateNestedManyWithoutServicesInput
    hourly_services?: hourly_servicesCreateNestedManyWithoutServicesInput
    sub_services?: sub_servicesCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutPoint_to_point_servicesInput = {
    id?: number
    Name?: string | null
    Status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    airport_services?: airport_servicesUncheckedCreateNestedManyWithoutServicesInput
    gratuities?: gratuitiesUncheckedCreateNestedManyWithoutServicesInput
    hourly_services?: hourly_servicesUncheckedCreateNestedManyWithoutServicesInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesCreateOrConnectWithoutPoint_to_point_servicesInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutPoint_to_point_servicesInput, servicesUncheckedCreateWithoutPoint_to_point_servicesInput>
  }

  export type servicesUpsertWithoutPoint_to_point_servicesInput = {
    update: XOR<servicesUpdateWithoutPoint_to_point_servicesInput, servicesUncheckedUpdateWithoutPoint_to_point_servicesInput>
    create: XOR<servicesCreateWithoutPoint_to_point_servicesInput, servicesUncheckedCreateWithoutPoint_to_point_servicesInput>
  }

  export type servicesUpdateWithoutPoint_to_point_servicesInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    airport_services?: airport_servicesUpdateManyWithoutServicesNestedInput
    gratuities?: gratuitiesUpdateManyWithoutServicesNestedInput
    hourly_services?: hourly_servicesUpdateManyWithoutServicesNestedInput
    sub_services?: sub_servicesUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutPoint_to_point_servicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    airport_services?: airport_servicesUncheckedUpdateManyWithoutServicesNestedInput
    gratuities?: gratuitiesUncheckedUpdateManyWithoutServicesNestedInput
    hourly_services?: hourly_servicesUncheckedUpdateManyWithoutServicesNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type carsCreateWithoutReservationsInput = {
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesCreateNestedManyWithoutCarsInput
    body_types: body_typesCreateNestedOneWithoutCarsInput
    drivers: driversCreateNestedOneWithoutCarsInput
    fuel_types: fuel_typesCreateNestedOneWithoutCarsInput
    manufacturers: manufacturersCreateNestedOneWithoutCarsInput
    transmissions: transmissionsCreateNestedOneWithoutCarsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutCarsInput
    package_serivce?: package_serivceCreateNestedManyWithoutCarsInput
    slabs?: slabsCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesCreateNestedManyWithoutCarsInput
    tours?: toursCreateNestedManyWithoutCarsInput
  }

  export type carsUncheckedCreateWithoutReservationsInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesUncheckedCreateNestedManyWithoutCarsInput
    package_serivce?: package_serivceUncheckedCreateNestedManyWithoutCarsInput
    slabs?: slabsUncheckedCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutCarsInput
    tours?: toursUncheckedCreateNestedManyWithoutCarsInput
  }

  export type carsCreateOrConnectWithoutReservationsInput = {
    where: carsWhereUniqueInput
    create: XOR<carsCreateWithoutReservationsInput, carsUncheckedCreateWithoutReservationsInput>
  }

  export type sub_servicesCreateWithoutReservationsInput = {
    name?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    description?: string | null
    luggage?: number | null
    passenger_capacity?: number | null
    services: servicesCreateNestedOneWithoutSub_servicesInput
    cars?: carsCreateNestedOneWithoutSub_servicesInput
    timeslots?: timeslotsCreateNestedManyWithoutSub_servicesInput
  }

  export type sub_servicesUncheckedCreateWithoutReservationsInput = {
    id?: number
    name?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_id?: number | null
    service_id: number
    description?: string | null
    luggage?: number | null
    passenger_capacity?: number | null
    timeslots?: timeslotsUncheckedCreateNestedManyWithoutSub_servicesInput
  }

  export type sub_servicesCreateOrConnectWithoutReservationsInput = {
    where: sub_servicesWhereUniqueInput
    create: XOR<sub_servicesCreateWithoutReservationsInput, sub_servicesUncheckedCreateWithoutReservationsInput>
  }

  export type carsUpsertWithoutReservationsInput = {
    update: XOR<carsUpdateWithoutReservationsInput, carsUncheckedUpdateWithoutReservationsInput>
    create: XOR<carsCreateWithoutReservationsInput, carsUncheckedCreateWithoutReservationsInput>
  }

  export type carsUpdateWithoutReservationsInput = {
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUpdateManyWithoutCarsNestedInput
    body_types?: body_typesUpdateOneRequiredWithoutCarsNestedInput
    drivers?: driversUpdateOneRequiredWithoutCarsNestedInput
    fuel_types?: fuel_typesUpdateOneRequiredWithoutCarsNestedInput
    manufacturers?: manufacturersUpdateOneRequiredWithoutCarsNestedInput
    transmissions?: transmissionsUpdateOneRequiredWithoutCarsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutCarsNestedInput
    package_serivce?: package_serivceUpdateManyWithoutCarsNestedInput
    slabs?: slabsUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUpdateManyWithoutCarsNestedInput
    tours?: toursUpdateManyWithoutCarsNestedInput
  }

  export type carsUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type_id?: IntFieldUpdateOperationsInput | number
    transmission_id?: IntFieldUpdateOperationsInput | number
    manufacturer_id?: IntFieldUpdateOperationsInput | number
    driver_id?: IntFieldUpdateOperationsInput | number
    fuel_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUncheckedUpdateManyWithoutCarsNestedInput
    package_serivce?: package_serivceUncheckedUpdateManyWithoutCarsNestedInput
    slabs?: slabsUncheckedUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutCarsNestedInput
    tours?: toursUncheckedUpdateManyWithoutCarsNestedInput
  }

  export type sub_servicesUpsertWithoutReservationsInput = {
    update: XOR<sub_servicesUpdateWithoutReservationsInput, sub_servicesUncheckedUpdateWithoutReservationsInput>
    create: XOR<sub_servicesCreateWithoutReservationsInput, sub_servicesUncheckedCreateWithoutReservationsInput>
  }

  export type sub_servicesUpdateWithoutReservationsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    passenger_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    services?: servicesUpdateOneRequiredWithoutSub_servicesNestedInput
    cars?: carsUpdateOneWithoutSub_servicesNestedInput
    timeslots?: timeslotsUpdateManyWithoutSub_servicesNestedInput
  }

  export type sub_servicesUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    passenger_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    timeslots?: timeslotsUncheckedUpdateManyWithoutSub_servicesNestedInput
  }

  export type rolesCreateWithoutRole_usersInput = {
    slug: string
    name: string
    permissions?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type rolesUncheckedCreateWithoutRole_usersInput = {
    id?: number
    slug: string
    name: string
    permissions?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type rolesCreateOrConnectWithoutRole_usersInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutRole_usersInput, rolesUncheckedCreateWithoutRole_usersInput>
  }

  export type usersCreateWithoutRole_usersInput = {
    email: string
    password: string
    permissions?: string | null
    last_login?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    bio?: string | null
    gender?: string | null
    dob?: Date | string | null
    pic?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    address?: string | null
    postal?: string | null
    status?: boolean | null
    reset_token?: string | null
    token_expired_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type usersUncheckedCreateWithoutRole_usersInput = {
    id?: number
    email: string
    password: string
    permissions?: string | null
    last_login?: Date | string | null
    first_name?: string | null
    last_name?: string | null
    bio?: string | null
    gender?: string | null
    dob?: Date | string | null
    pic?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    address?: string | null
    postal?: string | null
    status?: boolean | null
    reset_token?: string | null
    token_expired_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type usersCreateOrConnectWithoutRole_usersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRole_usersInput, usersUncheckedCreateWithoutRole_usersInput>
  }

  export type rolesUpsertWithoutRole_usersInput = {
    update: XOR<rolesUpdateWithoutRole_usersInput, rolesUncheckedUpdateWithoutRole_usersInput>
    create: XOR<rolesCreateWithoutRole_usersInput, rolesUncheckedCreateWithoutRole_usersInput>
  }

  export type rolesUpdateWithoutRole_usersInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesUncheckedUpdateWithoutRole_usersInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpsertWithoutRole_usersInput = {
    update: XOR<usersUpdateWithoutRole_usersInput, usersUncheckedUpdateWithoutRole_usersInput>
    create: XOR<usersCreateWithoutRole_usersInput, usersUncheckedCreateWithoutRole_usersInput>
  }

  export type usersUpdateWithoutRole_usersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pic?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    token_expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateWithoutRole_usersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    permissions?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pic?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    token_expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type role_usersCreateWithoutRolesInput = {
    created_at?: Date | string | null
    updated_at?: Date | string | null
    users: usersCreateNestedOneWithoutRole_usersInput
  }

  export type role_usersUncheckedCreateWithoutRolesInput = {
    user_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type role_usersCreateOrConnectWithoutRolesInput = {
    where: role_usersWhereUniqueInput
    create: XOR<role_usersCreateWithoutRolesInput, role_usersUncheckedCreateWithoutRolesInput>
  }

  export type role_usersCreateManyRolesInputEnvelope = {
    data: Enumerable<role_usersCreateManyRolesInput>
    skipDuplicates?: boolean
  }

  export type role_usersUpsertWithWhereUniqueWithoutRolesInput = {
    where: role_usersWhereUniqueInput
    update: XOR<role_usersUpdateWithoutRolesInput, role_usersUncheckedUpdateWithoutRolesInput>
    create: XOR<role_usersCreateWithoutRolesInput, role_usersUncheckedCreateWithoutRolesInput>
  }

  export type role_usersUpdateWithWhereUniqueWithoutRolesInput = {
    where: role_usersWhereUniqueInput
    data: XOR<role_usersUpdateWithoutRolesInput, role_usersUncheckedUpdateWithoutRolesInput>
  }

  export type role_usersUpdateManyWithWhereWithoutRolesInput = {
    where: role_usersScalarWhereInput
    data: XOR<role_usersUpdateManyMutationInput, role_usersUncheckedUpdateManyWithoutRole_usersInput>
  }

  export type role_usersScalarWhereInput = {
    AND?: Enumerable<role_usersScalarWhereInput>
    OR?: Enumerable<role_usersScalarWhereInput>
    NOT?: Enumerable<role_usersScalarWhereInput>
    user_id?: IntFilter | number
    role_id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type airport_servicesCreateWithoutServicesInput = {
    name: string
    description?: string | null
    pickup_dropoff: boolean
    pickup_date_time: Date | string
    num_passengers: number
    pickup_from: string
    dropoff_location: string
    airline?: string | null
    flight_number?: string | null
    status?: boolean
    pick_up_lat: string
    drop_off_lat: string
    pick_up_lon: string
    drop_off_lon: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type airport_servicesUncheckedCreateWithoutServicesInput = {
    id?: number
    name: string
    description?: string | null
    pickup_dropoff: boolean
    pickup_date_time: Date | string
    num_passengers: number
    pickup_from: string
    dropoff_location: string
    airline?: string | null
    flight_number?: string | null
    status?: boolean
    pick_up_lat: string
    drop_off_lat: string
    pick_up_lon: string
    drop_off_lon: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type airport_servicesCreateOrConnectWithoutServicesInput = {
    where: airport_servicesWhereUniqueInput
    create: XOR<airport_servicesCreateWithoutServicesInput, airport_servicesUncheckedCreateWithoutServicesInput>
  }

  export type airport_servicesCreateManyServicesInputEnvelope = {
    data: Enumerable<airport_servicesCreateManyServicesInput>
    skipDuplicates?: boolean
  }

  export type gratuitiesCreateWithoutServicesInput = {
    percentage?: number | null
    status?: boolean | null
    name?: string | null
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type gratuitiesUncheckedCreateWithoutServicesInput = {
    id?: number
    percentage?: number | null
    status?: boolean | null
    name?: string | null
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type gratuitiesCreateOrConnectWithoutServicesInput = {
    where: gratuitiesWhereUniqueInput
    create: XOR<gratuitiesCreateWithoutServicesInput, gratuitiesUncheckedCreateWithoutServicesInput>
  }

  export type gratuitiesCreateManyServicesInputEnvelope = {
    data: Enumerable<gratuitiesCreateManyServicesInput>
    skipDuplicates?: boolean
  }

  export type hourly_servicesCreateWithoutServicesInput = {
    name: string
    description?: string | null
    pickup_location: string
    pickup_date_time: Date | string
    num_passengers: number
    num_service_hours: number
    dropoff_location: string
    add_another_stop?: boolean
    additional_comments?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type hourly_servicesUncheckedCreateWithoutServicesInput = {
    id?: number
    name: string
    description?: string | null
    pickup_location: string
    pickup_date_time: Date | string
    num_passengers: number
    num_service_hours: number
    dropoff_location: string
    add_another_stop?: boolean
    additional_comments?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type hourly_servicesCreateOrConnectWithoutServicesInput = {
    where: hourly_servicesWhereUniqueInput
    create: XOR<hourly_servicesCreateWithoutServicesInput, hourly_servicesUncheckedCreateWithoutServicesInput>
  }

  export type hourly_servicesCreateManyServicesInputEnvelope = {
    data: Enumerable<hourly_servicesCreateManyServicesInput>
    skipDuplicates?: boolean
  }

  export type point_to_point_servicesCreateWithoutServicesInput = {
    name: string
    description?: string | null
    pickup_location: string
    pickup_date_time: Date | string
    num_passengers: number
    dropoff_location: string
    add_another_stop?: boolean
    additional_comments?: string | null
    status?: boolean
    pick_up_lat: string
    pick_up_lon: string
    drop_off_lat: string
    drop_off_lon: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type point_to_point_servicesUncheckedCreateWithoutServicesInput = {
    id?: number
    name: string
    description?: string | null
    pickup_location: string
    pickup_date_time: Date | string
    num_passengers: number
    dropoff_location: string
    add_another_stop?: boolean
    additional_comments?: string | null
    status?: boolean
    pick_up_lat: string
    pick_up_lon: string
    drop_off_lat: string
    drop_off_lon: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type point_to_point_servicesCreateOrConnectWithoutServicesInput = {
    where: point_to_point_servicesWhereUniqueInput
    create: XOR<point_to_point_servicesCreateWithoutServicesInput, point_to_point_servicesUncheckedCreateWithoutServicesInput>
  }

  export type point_to_point_servicesCreateManyServicesInputEnvelope = {
    data: Enumerable<point_to_point_servicesCreateManyServicesInput>
    skipDuplicates?: boolean
  }

  export type sub_servicesCreateWithoutServicesInput = {
    name?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    description?: string | null
    luggage?: number | null
    passenger_capacity?: number | null
    reservations?: reservationsCreateNestedManyWithoutSub_servicesInput
    cars?: carsCreateNestedOneWithoutSub_servicesInput
    timeslots?: timeslotsCreateNestedManyWithoutSub_servicesInput
  }

  export type sub_servicesUncheckedCreateWithoutServicesInput = {
    id?: number
    name?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_id?: number | null
    description?: string | null
    luggage?: number | null
    passenger_capacity?: number | null
    reservations?: reservationsUncheckedCreateNestedManyWithoutSub_servicesInput
    timeslots?: timeslotsUncheckedCreateNestedManyWithoutSub_servicesInput
  }

  export type sub_servicesCreateOrConnectWithoutServicesInput = {
    where: sub_servicesWhereUniqueInput
    create: XOR<sub_servicesCreateWithoutServicesInput, sub_servicesUncheckedCreateWithoutServicesInput>
  }

  export type sub_servicesCreateManyServicesInputEnvelope = {
    data: Enumerable<sub_servicesCreateManyServicesInput>
    skipDuplicates?: boolean
  }

  export type airport_servicesUpsertWithWhereUniqueWithoutServicesInput = {
    where: airport_servicesWhereUniqueInput
    update: XOR<airport_servicesUpdateWithoutServicesInput, airport_servicesUncheckedUpdateWithoutServicesInput>
    create: XOR<airport_servicesCreateWithoutServicesInput, airport_servicesUncheckedCreateWithoutServicesInput>
  }

  export type airport_servicesUpdateWithWhereUniqueWithoutServicesInput = {
    where: airport_servicesWhereUniqueInput
    data: XOR<airport_servicesUpdateWithoutServicesInput, airport_servicesUncheckedUpdateWithoutServicesInput>
  }

  export type airport_servicesUpdateManyWithWhereWithoutServicesInput = {
    where: airport_servicesScalarWhereInput
    data: XOR<airport_servicesUpdateManyMutationInput, airport_servicesUncheckedUpdateManyWithoutAirport_servicesInput>
  }

  export type airport_servicesScalarWhereInput = {
    AND?: Enumerable<airport_servicesScalarWhereInput>
    OR?: Enumerable<airport_servicesScalarWhereInput>
    NOT?: Enumerable<airport_servicesScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    pickup_dropoff?: BoolFilter | boolean
    pickup_date_time?: DateTimeFilter | Date | string
    num_passengers?: IntFilter | number
    pickup_from?: StringFilter | string
    dropoff_location?: StringFilter | string
    airline?: StringNullableFilter | string | null
    flight_number?: StringNullableFilter | string | null
    status?: BoolFilter | boolean
    pick_up_lat?: StringFilter | string
    drop_off_lat?: StringFilter | string
    pick_up_lon?: StringFilter | string
    drop_off_lon?: StringFilter | string
    service_id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type gratuitiesUpsertWithWhereUniqueWithoutServicesInput = {
    where: gratuitiesWhereUniqueInput
    update: XOR<gratuitiesUpdateWithoutServicesInput, gratuitiesUncheckedUpdateWithoutServicesInput>
    create: XOR<gratuitiesCreateWithoutServicesInput, gratuitiesUncheckedCreateWithoutServicesInput>
  }

  export type gratuitiesUpdateWithWhereUniqueWithoutServicesInput = {
    where: gratuitiesWhereUniqueInput
    data: XOR<gratuitiesUpdateWithoutServicesInput, gratuitiesUncheckedUpdateWithoutServicesInput>
  }

  export type gratuitiesUpdateManyWithWhereWithoutServicesInput = {
    where: gratuitiesScalarWhereInput
    data: XOR<gratuitiesUpdateManyMutationInput, gratuitiesUncheckedUpdateManyWithoutGratuitiesInput>
  }

  export type gratuitiesScalarWhereInput = {
    AND?: Enumerable<gratuitiesScalarWhereInput>
    OR?: Enumerable<gratuitiesScalarWhereInput>
    NOT?: Enumerable<gratuitiesScalarWhereInput>
    id?: IntFilter | number
    percentage?: IntNullableFilter | number | null
    status?: BoolNullableFilter | boolean | null
    name?: StringNullableFilter | string | null
    price?: IntFilter | number
    service_id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type hourly_servicesUpsertWithWhereUniqueWithoutServicesInput = {
    where: hourly_servicesWhereUniqueInput
    update: XOR<hourly_servicesUpdateWithoutServicesInput, hourly_servicesUncheckedUpdateWithoutServicesInput>
    create: XOR<hourly_servicesCreateWithoutServicesInput, hourly_servicesUncheckedCreateWithoutServicesInput>
  }

  export type hourly_servicesUpdateWithWhereUniqueWithoutServicesInput = {
    where: hourly_servicesWhereUniqueInput
    data: XOR<hourly_servicesUpdateWithoutServicesInput, hourly_servicesUncheckedUpdateWithoutServicesInput>
  }

  export type hourly_servicesUpdateManyWithWhereWithoutServicesInput = {
    where: hourly_servicesScalarWhereInput
    data: XOR<hourly_servicesUpdateManyMutationInput, hourly_servicesUncheckedUpdateManyWithoutHourly_servicesInput>
  }

  export type hourly_servicesScalarWhereInput = {
    AND?: Enumerable<hourly_servicesScalarWhereInput>
    OR?: Enumerable<hourly_servicesScalarWhereInput>
    NOT?: Enumerable<hourly_servicesScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    pickup_location?: StringFilter | string
    pickup_date_time?: DateTimeFilter | Date | string
    num_passengers?: IntFilter | number
    num_service_hours?: IntFilter | number
    dropoff_location?: StringFilter | string
    add_another_stop?: BoolFilter | boolean
    additional_comments?: StringNullableFilter | string | null
    status?: BoolFilter | boolean
    service_id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type point_to_point_servicesUpsertWithWhereUniqueWithoutServicesInput = {
    where: point_to_point_servicesWhereUniqueInput
    update: XOR<point_to_point_servicesUpdateWithoutServicesInput, point_to_point_servicesUncheckedUpdateWithoutServicesInput>
    create: XOR<point_to_point_servicesCreateWithoutServicesInput, point_to_point_servicesUncheckedCreateWithoutServicesInput>
  }

  export type point_to_point_servicesUpdateWithWhereUniqueWithoutServicesInput = {
    where: point_to_point_servicesWhereUniqueInput
    data: XOR<point_to_point_servicesUpdateWithoutServicesInput, point_to_point_servicesUncheckedUpdateWithoutServicesInput>
  }

  export type point_to_point_servicesUpdateManyWithWhereWithoutServicesInput = {
    where: point_to_point_servicesScalarWhereInput
    data: XOR<point_to_point_servicesUpdateManyMutationInput, point_to_point_servicesUncheckedUpdateManyWithoutPoint_to_point_servicesInput>
  }

  export type point_to_point_servicesScalarWhereInput = {
    AND?: Enumerable<point_to_point_servicesScalarWhereInput>
    OR?: Enumerable<point_to_point_servicesScalarWhereInput>
    NOT?: Enumerable<point_to_point_servicesScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    pickup_location?: StringFilter | string
    pickup_date_time?: DateTimeFilter | Date | string
    num_passengers?: IntFilter | number
    dropoff_location?: StringFilter | string
    add_another_stop?: BoolFilter | boolean
    additional_comments?: StringNullableFilter | string | null
    status?: BoolFilter | boolean
    pick_up_lat?: StringFilter | string
    pick_up_lon?: StringFilter | string
    drop_off_lat?: StringFilter | string
    drop_off_lon?: StringFilter | string
    service_id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type sub_servicesUpsertWithWhereUniqueWithoutServicesInput = {
    where: sub_servicesWhereUniqueInput
    update: XOR<sub_servicesUpdateWithoutServicesInput, sub_servicesUncheckedUpdateWithoutServicesInput>
    create: XOR<sub_servicesCreateWithoutServicesInput, sub_servicesUncheckedCreateWithoutServicesInput>
  }

  export type sub_servicesUpdateWithWhereUniqueWithoutServicesInput = {
    where: sub_servicesWhereUniqueInput
    data: XOR<sub_servicesUpdateWithoutServicesInput, sub_servicesUncheckedUpdateWithoutServicesInput>
  }

  export type sub_servicesUpdateManyWithWhereWithoutServicesInput = {
    where: sub_servicesScalarWhereInput
    data: XOR<sub_servicesUpdateManyMutationInput, sub_servicesUncheckedUpdateManyWithoutSub_servicesInput>
  }

  export type carsCreateWithoutToursInput = {
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesCreateNestedManyWithoutCarsInput
    body_types: body_typesCreateNestedOneWithoutCarsInput
    drivers: driversCreateNestedOneWithoutCarsInput
    fuel_types: fuel_typesCreateNestedOneWithoutCarsInput
    manufacturers: manufacturersCreateNestedOneWithoutCarsInput
    transmissions: transmissionsCreateNestedOneWithoutCarsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutCarsInput
    package_serivce?: package_serivceCreateNestedManyWithoutCarsInput
    reservations?: reservationsCreateNestedManyWithoutCarsInput
    slabs?: slabsCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesCreateNestedManyWithoutCarsInput
  }

  export type carsUncheckedCreateWithoutToursInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesUncheckedCreateNestedManyWithoutCarsInput
    package_serivce?: package_serivceUncheckedCreateNestedManyWithoutCarsInput
    reservations?: reservationsUncheckedCreateNestedManyWithoutCarsInput
    slabs?: slabsUncheckedCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutCarsInput
  }

  export type carsCreateOrConnectWithoutToursInput = {
    where: carsWhereUniqueInput
    create: XOR<carsCreateWithoutToursInput, carsUncheckedCreateWithoutToursInput>
  }

  export type carsUpsertWithoutToursInput = {
    update: XOR<carsUpdateWithoutToursInput, carsUncheckedUpdateWithoutToursInput>
    create: XOR<carsCreateWithoutToursInput, carsUncheckedCreateWithoutToursInput>
  }

  export type carsUpdateWithoutToursInput = {
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUpdateManyWithoutCarsNestedInput
    body_types?: body_typesUpdateOneRequiredWithoutCarsNestedInput
    drivers?: driversUpdateOneRequiredWithoutCarsNestedInput
    fuel_types?: fuel_typesUpdateOneRequiredWithoutCarsNestedInput
    manufacturers?: manufacturersUpdateOneRequiredWithoutCarsNestedInput
    transmissions?: transmissionsUpdateOneRequiredWithoutCarsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutCarsNestedInput
    package_serivce?: package_serivceUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUpdateManyWithoutCarsNestedInput
    slabs?: slabsUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUpdateManyWithoutCarsNestedInput
  }

  export type carsUncheckedUpdateWithoutToursInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type_id?: IntFieldUpdateOperationsInput | number
    transmission_id?: IntFieldUpdateOperationsInput | number
    manufacturer_id?: IntFieldUpdateOperationsInput | number
    driver_id?: IntFieldUpdateOperationsInput | number
    fuel_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUncheckedUpdateManyWithoutCarsNestedInput
    package_serivce?: package_serivceUncheckedUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUncheckedUpdateManyWithoutCarsNestedInput
    slabs?: slabsUncheckedUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutCarsNestedInput
  }

  export type carsCreateWithoutTransmissionsInput = {
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesCreateNestedManyWithoutCarsInput
    body_types: body_typesCreateNestedOneWithoutCarsInput
    drivers: driversCreateNestedOneWithoutCarsInput
    fuel_types: fuel_typesCreateNestedOneWithoutCarsInput
    manufacturers: manufacturersCreateNestedOneWithoutCarsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutCarsInput
    package_serivce?: package_serivceCreateNestedManyWithoutCarsInput
    reservations?: reservationsCreateNestedManyWithoutCarsInput
    slabs?: slabsCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesCreateNestedManyWithoutCarsInput
    tours?: toursCreateNestedManyWithoutCarsInput
  }

  export type carsUncheckedCreateWithoutTransmissionsInput = {
    id?: number
    body_type_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesUncheckedCreateNestedManyWithoutCarsInput
    package_serivce?: package_serivceUncheckedCreateNestedManyWithoutCarsInput
    reservations?: reservationsUncheckedCreateNestedManyWithoutCarsInput
    slabs?: slabsUncheckedCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutCarsInput
    tours?: toursUncheckedCreateNestedManyWithoutCarsInput
  }

  export type carsCreateOrConnectWithoutTransmissionsInput = {
    where: carsWhereUniqueInput
    create: XOR<carsCreateWithoutTransmissionsInput, carsUncheckedCreateWithoutTransmissionsInput>
  }

  export type carsCreateManyTransmissionsInputEnvelope = {
    data: Enumerable<carsCreateManyTransmissionsInput>
    skipDuplicates?: boolean
  }

  export type carsUpsertWithWhereUniqueWithoutTransmissionsInput = {
    where: carsWhereUniqueInput
    update: XOR<carsUpdateWithoutTransmissionsInput, carsUncheckedUpdateWithoutTransmissionsInput>
    create: XOR<carsCreateWithoutTransmissionsInput, carsUncheckedCreateWithoutTransmissionsInput>
  }

  export type carsUpdateWithWhereUniqueWithoutTransmissionsInput = {
    where: carsWhereUniqueInput
    data: XOR<carsUpdateWithoutTransmissionsInput, carsUncheckedUpdateWithoutTransmissionsInput>
  }

  export type carsUpdateManyWithWhereWithoutTransmissionsInput = {
    where: carsScalarWhereInput
    data: XOR<carsUpdateManyMutationInput, carsUncheckedUpdateManyWithoutCarsInput>
  }

  export type role_usersCreateWithoutUsersInput = {
    created_at?: Date | string | null
    updated_at?: Date | string | null
    roles: rolesCreateNestedOneWithoutRole_usersInput
  }

  export type role_usersUncheckedCreateWithoutUsersInput = {
    role_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type role_usersCreateOrConnectWithoutUsersInput = {
    where: role_usersWhereUniqueInput
    create: XOR<role_usersCreateWithoutUsersInput, role_usersUncheckedCreateWithoutUsersInput>
  }

  export type role_usersCreateManyUsersInputEnvelope = {
    data: Enumerable<role_usersCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type role_usersUpsertWithWhereUniqueWithoutUsersInput = {
    where: role_usersWhereUniqueInput
    update: XOR<role_usersUpdateWithoutUsersInput, role_usersUncheckedUpdateWithoutUsersInput>
    create: XOR<role_usersCreateWithoutUsersInput, role_usersUncheckedCreateWithoutUsersInput>
  }

  export type role_usersUpdateWithWhereUniqueWithoutUsersInput = {
    where: role_usersWhereUniqueInput
    data: XOR<role_usersUpdateWithoutUsersInput, role_usersUncheckedUpdateWithoutUsersInput>
  }

  export type role_usersUpdateManyWithWhereWithoutUsersInput = {
    where: role_usersScalarWhereInput
    data: XOR<role_usersUpdateManyMutationInput, role_usersUncheckedUpdateManyWithoutRole_usersInput>
  }

  export type carsCreateWithoutPackage_serivceInput = {
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesCreateNestedManyWithoutCarsInput
    body_types: body_typesCreateNestedOneWithoutCarsInput
    drivers: driversCreateNestedOneWithoutCarsInput
    fuel_types: fuel_typesCreateNestedOneWithoutCarsInput
    manufacturers: manufacturersCreateNestedOneWithoutCarsInput
    transmissions: transmissionsCreateNestedOneWithoutCarsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutCarsInput
    reservations?: reservationsCreateNestedManyWithoutCarsInput
    slabs?: slabsCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesCreateNestedManyWithoutCarsInput
    tours?: toursCreateNestedManyWithoutCarsInput
  }

  export type carsUncheckedCreateWithoutPackage_serivceInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesUncheckedCreateNestedManyWithoutCarsInput
    reservations?: reservationsUncheckedCreateNestedManyWithoutCarsInput
    slabs?: slabsUncheckedCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutCarsInput
    tours?: toursUncheckedCreateNestedManyWithoutCarsInput
  }

  export type carsCreateOrConnectWithoutPackage_serivceInput = {
    where: carsWhereUniqueInput
    create: XOR<carsCreateWithoutPackage_serivceInput, carsUncheckedCreateWithoutPackage_serivceInput>
  }

  export type carsUpsertWithoutPackage_serivceInput = {
    update: XOR<carsUpdateWithoutPackage_serivceInput, carsUncheckedUpdateWithoutPackage_serivceInput>
    create: XOR<carsCreateWithoutPackage_serivceInput, carsUncheckedCreateWithoutPackage_serivceInput>
  }

  export type carsUpdateWithoutPackage_serivceInput = {
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUpdateManyWithoutCarsNestedInput
    body_types?: body_typesUpdateOneRequiredWithoutCarsNestedInput
    drivers?: driversUpdateOneRequiredWithoutCarsNestedInput
    fuel_types?: fuel_typesUpdateOneRequiredWithoutCarsNestedInput
    manufacturers?: manufacturersUpdateOneRequiredWithoutCarsNestedInput
    transmissions?: transmissionsUpdateOneRequiredWithoutCarsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutCarsNestedInput
    reservations?: reservationsUpdateManyWithoutCarsNestedInput
    slabs?: slabsUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUpdateManyWithoutCarsNestedInput
    tours?: toursUpdateManyWithoutCarsNestedInput
  }

  export type carsUncheckedUpdateWithoutPackage_serivceInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type_id?: IntFieldUpdateOperationsInput | number
    transmission_id?: IntFieldUpdateOperationsInput | number
    manufacturer_id?: IntFieldUpdateOperationsInput | number
    driver_id?: IntFieldUpdateOperationsInput | number
    fuel_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUncheckedUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUncheckedUpdateManyWithoutCarsNestedInput
    slabs?: slabsUncheckedUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutCarsNestedInput
    tours?: toursUncheckedUpdateManyWithoutCarsNestedInput
  }

  export type carsCreateWithoutSlabsInput = {
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesCreateNestedManyWithoutCarsInput
    body_types: body_typesCreateNestedOneWithoutCarsInput
    drivers: driversCreateNestedOneWithoutCarsInput
    fuel_types: fuel_typesCreateNestedOneWithoutCarsInput
    manufacturers: manufacturersCreateNestedOneWithoutCarsInput
    transmissions: transmissionsCreateNestedOneWithoutCarsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutCarsInput
    package_serivce?: package_serivceCreateNestedManyWithoutCarsInput
    reservations?: reservationsCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesCreateNestedManyWithoutCarsInput
    tours?: toursCreateNestedManyWithoutCarsInput
  }

  export type carsUncheckedCreateWithoutSlabsInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesUncheckedCreateNestedManyWithoutCarsInput
    package_serivce?: package_serivceUncheckedCreateNestedManyWithoutCarsInput
    reservations?: reservationsUncheckedCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutCarsInput
    tours?: toursUncheckedCreateNestedManyWithoutCarsInput
  }

  export type carsCreateOrConnectWithoutSlabsInput = {
    where: carsWhereUniqueInput
    create: XOR<carsCreateWithoutSlabsInput, carsUncheckedCreateWithoutSlabsInput>
  }

  export type carsUpsertWithoutSlabsInput = {
    update: XOR<carsUpdateWithoutSlabsInput, carsUncheckedUpdateWithoutSlabsInput>
    create: XOR<carsCreateWithoutSlabsInput, carsUncheckedCreateWithoutSlabsInput>
  }

  export type carsUpdateWithoutSlabsInput = {
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUpdateManyWithoutCarsNestedInput
    body_types?: body_typesUpdateOneRequiredWithoutCarsNestedInput
    drivers?: driversUpdateOneRequiredWithoutCarsNestedInput
    fuel_types?: fuel_typesUpdateOneRequiredWithoutCarsNestedInput
    manufacturers?: manufacturersUpdateOneRequiredWithoutCarsNestedInput
    transmissions?: transmissionsUpdateOneRequiredWithoutCarsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutCarsNestedInput
    package_serivce?: package_serivceUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUpdateManyWithoutCarsNestedInput
    tours?: toursUpdateManyWithoutCarsNestedInput
  }

  export type carsUncheckedUpdateWithoutSlabsInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type_id?: IntFieldUpdateOperationsInput | number
    transmission_id?: IntFieldUpdateOperationsInput | number
    manufacturer_id?: IntFieldUpdateOperationsInput | number
    driver_id?: IntFieldUpdateOperationsInput | number
    fuel_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUncheckedUpdateManyWithoutCarsNestedInput
    package_serivce?: package_serivceUncheckedUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUncheckedUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutCarsNestedInput
    tours?: toursUncheckedUpdateManyWithoutCarsNestedInput
  }

  export type sub_servicesCreateWithoutTimeslotsInput = {
    name?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    description?: string | null
    luggage?: number | null
    passenger_capacity?: number | null
    reservations?: reservationsCreateNestedManyWithoutSub_servicesInput
    services: servicesCreateNestedOneWithoutSub_servicesInput
    cars?: carsCreateNestedOneWithoutSub_servicesInput
  }

  export type sub_servicesUncheckedCreateWithoutTimeslotsInput = {
    id?: number
    name?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_id?: number | null
    service_id: number
    description?: string | null
    luggage?: number | null
    passenger_capacity?: number | null
    reservations?: reservationsUncheckedCreateNestedManyWithoutSub_servicesInput
  }

  export type sub_servicesCreateOrConnectWithoutTimeslotsInput = {
    where: sub_servicesWhereUniqueInput
    create: XOR<sub_servicesCreateWithoutTimeslotsInput, sub_servicesUncheckedCreateWithoutTimeslotsInput>
  }

  export type sub_servicesUpsertWithoutTimeslotsInput = {
    update: XOR<sub_servicesUpdateWithoutTimeslotsInput, sub_servicesUncheckedUpdateWithoutTimeslotsInput>
    create: XOR<sub_servicesCreateWithoutTimeslotsInput, sub_servicesUncheckedCreateWithoutTimeslotsInput>
  }

  export type sub_servicesUpdateWithoutTimeslotsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    passenger_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    reservations?: reservationsUpdateManyWithoutSub_servicesNestedInput
    services?: servicesUpdateOneRequiredWithoutSub_servicesNestedInput
    cars?: carsUpdateOneWithoutSub_servicesNestedInput
  }

  export type sub_servicesUncheckedUpdateWithoutTimeslotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    passenger_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    reservations?: reservationsUncheckedUpdateManyWithoutSub_servicesNestedInput
  }

  export type carsCreateWithoutVehicle_typesInput = {
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesCreateNestedManyWithoutCarsInput
    body_types: body_typesCreateNestedOneWithoutCarsInput
    drivers: driversCreateNestedOneWithoutCarsInput
    fuel_types: fuel_typesCreateNestedOneWithoutCarsInput
    manufacturers: manufacturersCreateNestedOneWithoutCarsInput
    transmissions: transmissionsCreateNestedOneWithoutCarsInput
    package_serivce?: package_serivceCreateNestedManyWithoutCarsInput
    reservations?: reservationsCreateNestedManyWithoutCarsInput
    slabs?: slabsCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesCreateNestedManyWithoutCarsInput
    tours?: toursCreateNestedManyWithoutCarsInput
  }

  export type carsUncheckedCreateWithoutVehicle_typesInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesUncheckedCreateNestedManyWithoutCarsInput
    package_serivce?: package_serivceUncheckedCreateNestedManyWithoutCarsInput
    reservations?: reservationsUncheckedCreateNestedManyWithoutCarsInput
    slabs?: slabsUncheckedCreateNestedManyWithoutCarsInput
    sub_services?: sub_servicesUncheckedCreateNestedManyWithoutCarsInput
    tours?: toursUncheckedCreateNestedManyWithoutCarsInput
  }

  export type carsCreateOrConnectWithoutVehicle_typesInput = {
    where: carsWhereUniqueInput
    create: XOR<carsCreateWithoutVehicle_typesInput, carsUncheckedCreateWithoutVehicle_typesInput>
  }

  export type carsCreateManyVehicle_typesInputEnvelope = {
    data: Enumerable<carsCreateManyVehicle_typesInput>
    skipDuplicates?: boolean
  }

  export type carsUpsertWithWhereUniqueWithoutVehicle_typesInput = {
    where: carsWhereUniqueInput
    update: XOR<carsUpdateWithoutVehicle_typesInput, carsUncheckedUpdateWithoutVehicle_typesInput>
    create: XOR<carsCreateWithoutVehicle_typesInput, carsUncheckedCreateWithoutVehicle_typesInput>
  }

  export type carsUpdateWithWhereUniqueWithoutVehicle_typesInput = {
    where: carsWhereUniqueInput
    data: XOR<carsUpdateWithoutVehicle_typesInput, carsUncheckedUpdateWithoutVehicle_typesInput>
  }

  export type carsUpdateManyWithWhereWithoutVehicle_typesInput = {
    where: carsScalarWhereInput
    data: XOR<carsUpdateManyMutationInput, carsUncheckedUpdateManyWithoutCarsInput>
  }

  export type reservationsCreateWithoutSub_servicesInput = {
    order_number?: string | null
    pick_up_postal_code?: string | null
    pick_up_lat?: number | null
    pick_up_lon?: number | null
    pick_up_loc_name?: string | null
    drop_off_postal_code?: string | null
    drop_off_lat?: number | null
    drop_off_lon?: number | null
    drop_off_loc_name?: string | null
    pick_up_date?: Date | string | null
    price?: number | null
    tax?: number | null
    airline?: string | null
    flight_no?: string | null
    no_of_hours?: number | null
    maximum_passenger?: number | null
    maximum_luggage?: number | null
    customer_first_name?: string | null
    customer_last_name?: string | null
    customer_cnic?: string | null
    customer_email?: string | null
    customer_phone?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    uuid?: string
    payment_method?: string | null
    isPaid?: number | null
    special_instruction?: string | null
    cars: carsCreateNestedOneWithoutReservationsInput
  }

  export type reservationsUncheckedCreateWithoutSub_servicesInput = {
    id?: number
    order_number?: string | null
    car_id: number
    pick_up_postal_code?: string | null
    pick_up_lat?: number | null
    pick_up_lon?: number | null
    pick_up_loc_name?: string | null
    drop_off_postal_code?: string | null
    drop_off_lat?: number | null
    drop_off_lon?: number | null
    drop_off_loc_name?: string | null
    pick_up_date?: Date | string | null
    price?: number | null
    tax?: number | null
    airline?: string | null
    flight_no?: string | null
    no_of_hours?: number | null
    maximum_passenger?: number | null
    maximum_luggage?: number | null
    customer_first_name?: string | null
    customer_last_name?: string | null
    customer_cnic?: string | null
    customer_email?: string | null
    customer_phone?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    uuid?: string
    payment_method?: string | null
    isPaid?: number | null
    special_instruction?: string | null
  }

  export type reservationsCreateOrConnectWithoutSub_servicesInput = {
    where: reservationsWhereUniqueInput
    create: XOR<reservationsCreateWithoutSub_servicesInput, reservationsUncheckedCreateWithoutSub_servicesInput>
  }

  export type reservationsCreateManySub_servicesInputEnvelope = {
    data: Enumerable<reservationsCreateManySub_servicesInput>
    skipDuplicates?: boolean
  }

  export type servicesCreateWithoutSub_servicesInput = {
    Name?: string | null
    Status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    airport_services?: airport_servicesCreateNestedManyWithoutServicesInput
    gratuities?: gratuitiesCreateNestedManyWithoutServicesInput
    hourly_services?: hourly_servicesCreateNestedManyWithoutServicesInput
    point_to_point_services?: point_to_point_servicesCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutSub_servicesInput = {
    id?: number
    Name?: string | null
    Status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    airport_services?: airport_servicesUncheckedCreateNestedManyWithoutServicesInput
    gratuities?: gratuitiesUncheckedCreateNestedManyWithoutServicesInput
    hourly_services?: hourly_servicesUncheckedCreateNestedManyWithoutServicesInput
    point_to_point_services?: point_to_point_servicesUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesCreateOrConnectWithoutSub_servicesInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutSub_servicesInput, servicesUncheckedCreateWithoutSub_servicesInput>
  }

  export type carsCreateWithoutSub_servicesInput = {
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesCreateNestedManyWithoutCarsInput
    body_types: body_typesCreateNestedOneWithoutCarsInput
    drivers: driversCreateNestedOneWithoutCarsInput
    fuel_types: fuel_typesCreateNestedOneWithoutCarsInput
    manufacturers: manufacturersCreateNestedOneWithoutCarsInput
    transmissions: transmissionsCreateNestedOneWithoutCarsInput
    vehicle_types: vehicle_typesCreateNestedOneWithoutCarsInput
    package_serivce?: package_serivceCreateNestedManyWithoutCarsInput
    reservations?: reservationsCreateNestedManyWithoutCarsInput
    slabs?: slabsCreateNestedManyWithoutCarsInput
    tours?: toursCreateNestedManyWithoutCarsInput
  }

  export type carsUncheckedCreateWithoutSub_servicesInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
    car_prices?: car_pricesUncheckedCreateNestedManyWithoutCarsInput
    package_serivce?: package_serivceUncheckedCreateNestedManyWithoutCarsInput
    reservations?: reservationsUncheckedCreateNestedManyWithoutCarsInput
    slabs?: slabsUncheckedCreateNestedManyWithoutCarsInput
    tours?: toursUncheckedCreateNestedManyWithoutCarsInput
  }

  export type carsCreateOrConnectWithoutSub_servicesInput = {
    where: carsWhereUniqueInput
    create: XOR<carsCreateWithoutSub_servicesInput, carsUncheckedCreateWithoutSub_servicesInput>
  }

  export type timeslotsCreateWithoutSub_servicesInput = {
    time?: Date | string | null
    isActive?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type timeslotsUncheckedCreateWithoutSub_servicesInput = {
    id?: number
    time?: Date | string | null
    isActive?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type timeslotsCreateOrConnectWithoutSub_servicesInput = {
    where: timeslotsWhereUniqueInput
    create: XOR<timeslotsCreateWithoutSub_servicesInput, timeslotsUncheckedCreateWithoutSub_servicesInput>
  }

  export type timeslotsCreateManySub_servicesInputEnvelope = {
    data: Enumerable<timeslotsCreateManySub_servicesInput>
    skipDuplicates?: boolean
  }

  export type reservationsUpsertWithWhereUniqueWithoutSub_servicesInput = {
    where: reservationsWhereUniqueInput
    update: XOR<reservationsUpdateWithoutSub_servicesInput, reservationsUncheckedUpdateWithoutSub_servicesInput>
    create: XOR<reservationsCreateWithoutSub_servicesInput, reservationsUncheckedCreateWithoutSub_servicesInput>
  }

  export type reservationsUpdateWithWhereUniqueWithoutSub_servicesInput = {
    where: reservationsWhereUniqueInput
    data: XOR<reservationsUpdateWithoutSub_servicesInput, reservationsUncheckedUpdateWithoutSub_servicesInput>
  }

  export type reservationsUpdateManyWithWhereWithoutSub_servicesInput = {
    where: reservationsScalarWhereInput
    data: XOR<reservationsUpdateManyMutationInput, reservationsUncheckedUpdateManyWithoutReservationsInput>
  }

  export type servicesUpsertWithoutSub_servicesInput = {
    update: XOR<servicesUpdateWithoutSub_servicesInput, servicesUncheckedUpdateWithoutSub_servicesInput>
    create: XOR<servicesCreateWithoutSub_servicesInput, servicesUncheckedCreateWithoutSub_servicesInput>
  }

  export type servicesUpdateWithoutSub_servicesInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    airport_services?: airport_servicesUpdateManyWithoutServicesNestedInput
    gratuities?: gratuitiesUpdateManyWithoutServicesNestedInput
    hourly_services?: hourly_servicesUpdateManyWithoutServicesNestedInput
    point_to_point_services?: point_to_point_servicesUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutSub_servicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    airport_services?: airport_servicesUncheckedUpdateManyWithoutServicesNestedInput
    gratuities?: gratuitiesUncheckedUpdateManyWithoutServicesNestedInput
    hourly_services?: hourly_servicesUncheckedUpdateManyWithoutServicesNestedInput
    point_to_point_services?: point_to_point_servicesUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type carsUpsertWithoutSub_servicesInput = {
    update: XOR<carsUpdateWithoutSub_servicesInput, carsUncheckedUpdateWithoutSub_servicesInput>
    create: XOR<carsCreateWithoutSub_servicesInput, carsUncheckedCreateWithoutSub_servicesInput>
  }

  export type carsUpdateWithoutSub_servicesInput = {
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUpdateManyWithoutCarsNestedInput
    body_types?: body_typesUpdateOneRequiredWithoutCarsNestedInput
    drivers?: driversUpdateOneRequiredWithoutCarsNestedInput
    fuel_types?: fuel_typesUpdateOneRequiredWithoutCarsNestedInput
    manufacturers?: manufacturersUpdateOneRequiredWithoutCarsNestedInput
    transmissions?: transmissionsUpdateOneRequiredWithoutCarsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutCarsNestedInput
    package_serivce?: package_serivceUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUpdateManyWithoutCarsNestedInput
    slabs?: slabsUpdateManyWithoutCarsNestedInput
    tours?: toursUpdateManyWithoutCarsNestedInput
  }

  export type carsUncheckedUpdateWithoutSub_servicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type_id?: IntFieldUpdateOperationsInput | number
    transmission_id?: IntFieldUpdateOperationsInput | number
    manufacturer_id?: IntFieldUpdateOperationsInput | number
    driver_id?: IntFieldUpdateOperationsInput | number
    fuel_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUncheckedUpdateManyWithoutCarsNestedInput
    package_serivce?: package_serivceUncheckedUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUncheckedUpdateManyWithoutCarsNestedInput
    slabs?: slabsUncheckedUpdateManyWithoutCarsNestedInput
    tours?: toursUncheckedUpdateManyWithoutCarsNestedInput
  }

  export type timeslotsUpsertWithWhereUniqueWithoutSub_servicesInput = {
    where: timeslotsWhereUniqueInput
    update: XOR<timeslotsUpdateWithoutSub_servicesInput, timeslotsUncheckedUpdateWithoutSub_servicesInput>
    create: XOR<timeslotsCreateWithoutSub_servicesInput, timeslotsUncheckedCreateWithoutSub_servicesInput>
  }

  export type timeslotsUpdateWithWhereUniqueWithoutSub_servicesInput = {
    where: timeslotsWhereUniqueInput
    data: XOR<timeslotsUpdateWithoutSub_servicesInput, timeslotsUncheckedUpdateWithoutSub_servicesInput>
  }

  export type timeslotsUpdateManyWithWhereWithoutSub_servicesInput = {
    where: timeslotsScalarWhereInput
    data: XOR<timeslotsUpdateManyMutationInput, timeslotsUncheckedUpdateManyWithoutTimeslotsInput>
  }

  export type timeslotsScalarWhereInput = {
    AND?: Enumerable<timeslotsScalarWhereInput>
    OR?: Enumerable<timeslotsScalarWhereInput>
    NOT?: Enumerable<timeslotsScalarWhereInput>
    id?: IntFilter | number
    time?: DateTimeNullableFilter | Date | string | null
    isActive?: BoolNullableFilter | boolean | null
    sub_service_id?: IntNullableFilter | number | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type carsCreateManyBody_typesInput = {
    id?: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
  }

  export type carsUpdateWithoutBody_typesInput = {
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUpdateManyWithoutCarsNestedInput
    drivers?: driversUpdateOneRequiredWithoutCarsNestedInput
    fuel_types?: fuel_typesUpdateOneRequiredWithoutCarsNestedInput
    manufacturers?: manufacturersUpdateOneRequiredWithoutCarsNestedInput
    transmissions?: transmissionsUpdateOneRequiredWithoutCarsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutCarsNestedInput
    package_serivce?: package_serivceUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUpdateManyWithoutCarsNestedInput
    slabs?: slabsUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUpdateManyWithoutCarsNestedInput
    tours?: toursUpdateManyWithoutCarsNestedInput
  }

  export type carsUncheckedUpdateWithoutBody_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    transmission_id?: IntFieldUpdateOperationsInput | number
    manufacturer_id?: IntFieldUpdateOperationsInput | number
    driver_id?: IntFieldUpdateOperationsInput | number
    fuel_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUncheckedUpdateManyWithoutCarsNestedInput
    package_serivce?: package_serivceUncheckedUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUncheckedUpdateManyWithoutCarsNestedInput
    slabs?: slabsUncheckedUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutCarsNestedInput
    tours?: toursUncheckedUpdateManyWithoutCarsNestedInput
  }

  export type carsUncheckedUpdateManyWithoutCarsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transmission_id?: IntFieldUpdateOperationsInput | number
    manufacturer_id?: IntFieldUpdateOperationsInput | number
    driver_id?: IntFieldUpdateOperationsInput | number
    fuel_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
  }

  export type car_pricesCreateManyCar_price_typesInput = {
    id?: number
    car_id: number
    monday?: number | null
    tuesday?: number | null
    wednesday?: number | null
    thursday?: number | null
    friday?: number | null
    saturday?: number | null
    sunday?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type car_pricesUpdateWithoutCar_price_typesInput = {
    monday?: NullableIntFieldUpdateOperationsInput | number | null
    tuesday?: NullableIntFieldUpdateOperationsInput | number | null
    wednesday?: NullableIntFieldUpdateOperationsInput | number | null
    thursday?: NullableIntFieldUpdateOperationsInput | number | null
    friday?: NullableIntFieldUpdateOperationsInput | number | null
    saturday?: NullableIntFieldUpdateOperationsInput | number | null
    sunday?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cars?: carsUpdateOneRequiredWithoutCar_pricesNestedInput
  }

  export type car_pricesUncheckedUpdateWithoutCar_price_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    car_id?: IntFieldUpdateOperationsInput | number
    monday?: NullableIntFieldUpdateOperationsInput | number | null
    tuesday?: NullableIntFieldUpdateOperationsInput | number | null
    wednesday?: NullableIntFieldUpdateOperationsInput | number | null
    thursday?: NullableIntFieldUpdateOperationsInput | number | null
    friday?: NullableIntFieldUpdateOperationsInput | number | null
    saturday?: NullableIntFieldUpdateOperationsInput | number | null
    sunday?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type car_pricesUncheckedUpdateManyWithoutCar_pricesInput = {
    id?: IntFieldUpdateOperationsInput | number
    car_id?: IntFieldUpdateOperationsInput | number
    monday?: NullableIntFieldUpdateOperationsInput | number | null
    tuesday?: NullableIntFieldUpdateOperationsInput | number | null
    wednesday?: NullableIntFieldUpdateOperationsInput | number | null
    thursday?: NullableIntFieldUpdateOperationsInput | number | null
    friday?: NullableIntFieldUpdateOperationsInput | number | null
    saturday?: NullableIntFieldUpdateOperationsInput | number | null
    sunday?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type car_pricesCreateManyCarsInput = {
    id?: number
    car_price_type_id: number
    monday?: number | null
    tuesday?: number | null
    wednesday?: number | null
    thursday?: number | null
    friday?: number | null
    saturday?: number | null
    sunday?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type package_serivceCreateManyCarsInput = {
    id?: number
    name?: string | null
    description?: string | null
    passenger_capacity: number
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    luggage?: number | null
  }

  export type reservationsCreateManyCarsInput = {
    id?: number
    order_number?: string | null
    service_id: number
    pick_up_postal_code?: string | null
    pick_up_lat?: number | null
    pick_up_lon?: number | null
    pick_up_loc_name?: string | null
    drop_off_postal_code?: string | null
    drop_off_lat?: number | null
    drop_off_lon?: number | null
    drop_off_loc_name?: string | null
    pick_up_date?: Date | string | null
    price?: number | null
    tax?: number | null
    airline?: string | null
    flight_no?: string | null
    no_of_hours?: number | null
    maximum_passenger?: number | null
    maximum_luggage?: number | null
    customer_first_name?: string | null
    customer_last_name?: string | null
    customer_cnic?: string | null
    customer_email?: string | null
    customer_phone?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    uuid?: string
    payment_method?: string | null
    isPaid?: number | null
    special_instruction?: string | null
  }

  export type slabsCreateManyCarsInput = {
    id?: number
    initial_distance: number
    final_distance: number
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type sub_servicesCreateManyCarsInput = {
    id?: number
    name?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    service_id: number
    description?: string | null
    luggage?: number | null
    passenger_capacity?: number | null
  }

  export type toursCreateManyCarsInput = {
    id?: number
    title?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    description?: string | null
    luggage?: number | null
  }

  export type car_pricesUpdateWithoutCarsInput = {
    monday?: NullableIntFieldUpdateOperationsInput | number | null
    tuesday?: NullableIntFieldUpdateOperationsInput | number | null
    wednesday?: NullableIntFieldUpdateOperationsInput | number | null
    thursday?: NullableIntFieldUpdateOperationsInput | number | null
    friday?: NullableIntFieldUpdateOperationsInput | number | null
    saturday?: NullableIntFieldUpdateOperationsInput | number | null
    sunday?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    car_price_types?: car_price_typesUpdateOneRequiredWithoutCar_pricesNestedInput
  }

  export type car_pricesUncheckedUpdateWithoutCarsInput = {
    id?: IntFieldUpdateOperationsInput | number
    car_price_type_id?: IntFieldUpdateOperationsInput | number
    monday?: NullableIntFieldUpdateOperationsInput | number | null
    tuesday?: NullableIntFieldUpdateOperationsInput | number | null
    wednesday?: NullableIntFieldUpdateOperationsInput | number | null
    thursday?: NullableIntFieldUpdateOperationsInput | number | null
    friday?: NullableIntFieldUpdateOperationsInput | number | null
    saturday?: NullableIntFieldUpdateOperationsInput | number | null
    sunday?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type package_serivceUpdateWithoutCarsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_capacity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type package_serivceUncheckedUpdateWithoutCarsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_capacity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type package_serivceUncheckedUpdateManyWithoutPackage_serivceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_capacity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reservationsUpdateWithoutCarsInput = {
    order_number?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_no?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_hours?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    customer_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_cnic?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: NullableIntFieldUpdateOperationsInput | number | null
    special_instruction?: NullableStringFieldUpdateOperationsInput | string | null
    sub_services?: sub_servicesUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type reservationsUncheckedUpdateWithoutCarsInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_number?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: IntFieldUpdateOperationsInput | number
    pick_up_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_no?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_hours?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    customer_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_cnic?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: NullableIntFieldUpdateOperationsInput | number | null
    special_instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reservationsUncheckedUpdateManyWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_number?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: IntFieldUpdateOperationsInput | number
    pick_up_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_no?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_hours?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    customer_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_cnic?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: NullableIntFieldUpdateOperationsInput | number | null
    special_instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type slabsUpdateWithoutCarsInput = {
    initial_distance?: FloatFieldUpdateOperationsInput | number
    final_distance?: FloatFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type slabsUncheckedUpdateWithoutCarsInput = {
    id?: IntFieldUpdateOperationsInput | number
    initial_distance?: FloatFieldUpdateOperationsInput | number
    final_distance?: FloatFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type slabsUncheckedUpdateManyWithoutSlabsInput = {
    id?: IntFieldUpdateOperationsInput | number
    initial_distance?: FloatFieldUpdateOperationsInput | number
    final_distance?: FloatFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sub_servicesUpdateWithoutCarsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    passenger_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    reservations?: reservationsUpdateManyWithoutSub_servicesNestedInput
    services?: servicesUpdateOneRequiredWithoutSub_servicesNestedInput
    timeslots?: timeslotsUpdateManyWithoutSub_servicesNestedInput
  }

  export type sub_servicesUncheckedUpdateWithoutCarsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    service_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    passenger_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    reservations?: reservationsUncheckedUpdateManyWithoutSub_servicesNestedInput
    timeslots?: timeslotsUncheckedUpdateManyWithoutSub_servicesNestedInput
  }

  export type sub_servicesUncheckedUpdateManyWithoutSub_servicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    service_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    passenger_capacity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type toursUpdateWithoutCarsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type toursUncheckedUpdateWithoutCarsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type toursUncheckedUpdateManyWithoutToursInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type carsCreateManyDriversInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
  }

  export type carsUpdateWithoutDriversInput = {
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUpdateManyWithoutCarsNestedInput
    body_types?: body_typesUpdateOneRequiredWithoutCarsNestedInput
    fuel_types?: fuel_typesUpdateOneRequiredWithoutCarsNestedInput
    manufacturers?: manufacturersUpdateOneRequiredWithoutCarsNestedInput
    transmissions?: transmissionsUpdateOneRequiredWithoutCarsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutCarsNestedInput
    package_serivce?: package_serivceUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUpdateManyWithoutCarsNestedInput
    slabs?: slabsUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUpdateManyWithoutCarsNestedInput
    tours?: toursUpdateManyWithoutCarsNestedInput
  }

  export type carsUncheckedUpdateWithoutDriversInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type_id?: IntFieldUpdateOperationsInput | number
    transmission_id?: IntFieldUpdateOperationsInput | number
    manufacturer_id?: IntFieldUpdateOperationsInput | number
    fuel_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUncheckedUpdateManyWithoutCarsNestedInput
    package_serivce?: package_serivceUncheckedUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUncheckedUpdateManyWithoutCarsNestedInput
    slabs?: slabsUncheckedUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutCarsNestedInput
    tours?: toursUncheckedUpdateManyWithoutCarsNestedInput
  }

  export type carsCreateManyFuel_typesInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
  }

  export type carsUpdateWithoutFuel_typesInput = {
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUpdateManyWithoutCarsNestedInput
    body_types?: body_typesUpdateOneRequiredWithoutCarsNestedInput
    drivers?: driversUpdateOneRequiredWithoutCarsNestedInput
    manufacturers?: manufacturersUpdateOneRequiredWithoutCarsNestedInput
    transmissions?: transmissionsUpdateOneRequiredWithoutCarsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutCarsNestedInput
    package_serivce?: package_serivceUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUpdateManyWithoutCarsNestedInput
    slabs?: slabsUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUpdateManyWithoutCarsNestedInput
    tours?: toursUpdateManyWithoutCarsNestedInput
  }

  export type carsUncheckedUpdateWithoutFuel_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type_id?: IntFieldUpdateOperationsInput | number
    transmission_id?: IntFieldUpdateOperationsInput | number
    manufacturer_id?: IntFieldUpdateOperationsInput | number
    driver_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUncheckedUpdateManyWithoutCarsNestedInput
    package_serivce?: package_serivceUncheckedUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUncheckedUpdateManyWithoutCarsNestedInput
    slabs?: slabsUncheckedUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutCarsNestedInput
    tours?: toursUncheckedUpdateManyWithoutCarsNestedInput
  }

  export type carsCreateManyManufacturersInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
  }

  export type carsUpdateWithoutManufacturersInput = {
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUpdateManyWithoutCarsNestedInput
    body_types?: body_typesUpdateOneRequiredWithoutCarsNestedInput
    drivers?: driversUpdateOneRequiredWithoutCarsNestedInput
    fuel_types?: fuel_typesUpdateOneRequiredWithoutCarsNestedInput
    transmissions?: transmissionsUpdateOneRequiredWithoutCarsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutCarsNestedInput
    package_serivce?: package_serivceUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUpdateManyWithoutCarsNestedInput
    slabs?: slabsUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUpdateManyWithoutCarsNestedInput
    tours?: toursUpdateManyWithoutCarsNestedInput
  }

  export type carsUncheckedUpdateWithoutManufacturersInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type_id?: IntFieldUpdateOperationsInput | number
    transmission_id?: IntFieldUpdateOperationsInput | number
    driver_id?: IntFieldUpdateOperationsInput | number
    fuel_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUncheckedUpdateManyWithoutCarsNestedInput
    package_serivce?: package_serivceUncheckedUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUncheckedUpdateManyWithoutCarsNestedInput
    slabs?: slabsUncheckedUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutCarsNestedInput
    tours?: toursUncheckedUpdateManyWithoutCarsNestedInput
  }

  export type role_usersCreateManyRolesInput = {
    user_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type role_usersUpdateWithoutRolesInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutRole_usersNestedInput
  }

  export type role_usersUncheckedUpdateWithoutRolesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type role_usersUncheckedUpdateManyWithoutRole_usersInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type airport_servicesCreateManyServicesInput = {
    id?: number
    name: string
    description?: string | null
    pickup_dropoff: boolean
    pickup_date_time: Date | string
    num_passengers: number
    pickup_from: string
    dropoff_location: string
    airline?: string | null
    flight_number?: string | null
    status?: boolean
    pick_up_lat: string
    drop_off_lat: string
    pick_up_lon: string
    drop_off_lon: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type gratuitiesCreateManyServicesInput = {
    id?: number
    percentage?: number | null
    status?: boolean | null
    name?: string | null
    price: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type hourly_servicesCreateManyServicesInput = {
    id?: number
    name: string
    description?: string | null
    pickup_location: string
    pickup_date_time: Date | string
    num_passengers: number
    num_service_hours: number
    dropoff_location: string
    add_another_stop?: boolean
    additional_comments?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type point_to_point_servicesCreateManyServicesInput = {
    id?: number
    name: string
    description?: string | null
    pickup_location: string
    pickup_date_time: Date | string
    num_passengers: number
    dropoff_location: string
    add_another_stop?: boolean
    additional_comments?: string | null
    status?: boolean
    pick_up_lat: string
    pick_up_lon: string
    drop_off_lat: string
    drop_off_lon: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type sub_servicesCreateManyServicesInput = {
    id?: number
    name?: string | null
    pickup_location?: string | null
    pickup_lat?: number | null
    pickup_lng?: number | null
    dropoff_location?: string | null
    dropoff_lat?: number | null
    dropoff_lng?: number | null
    price_per_passenger?: number | null
    status?: Buffer | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_id?: number | null
    description?: string | null
    luggage?: number | null
    passenger_capacity?: number | null
  }

  export type airport_servicesUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_dropoff?: BoolFieldUpdateOperationsInput | boolean
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    pickup_from?: StringFieldUpdateOperationsInput | string
    dropoff_location?: StringFieldUpdateOperationsInput | string
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    pick_up_lat?: StringFieldUpdateOperationsInput | string
    drop_off_lat?: StringFieldUpdateOperationsInput | string
    pick_up_lon?: StringFieldUpdateOperationsInput | string
    drop_off_lon?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type airport_servicesUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_dropoff?: BoolFieldUpdateOperationsInput | boolean
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    pickup_from?: StringFieldUpdateOperationsInput | string
    dropoff_location?: StringFieldUpdateOperationsInput | string
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    pick_up_lat?: StringFieldUpdateOperationsInput | string
    drop_off_lat?: StringFieldUpdateOperationsInput | string
    pick_up_lon?: StringFieldUpdateOperationsInput | string
    drop_off_lon?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type airport_servicesUncheckedUpdateManyWithoutAirport_servicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_dropoff?: BoolFieldUpdateOperationsInput | boolean
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    pickup_from?: StringFieldUpdateOperationsInput | string
    dropoff_location?: StringFieldUpdateOperationsInput | string
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    pick_up_lat?: StringFieldUpdateOperationsInput | string
    drop_off_lat?: StringFieldUpdateOperationsInput | string
    pick_up_lon?: StringFieldUpdateOperationsInput | string
    drop_off_lon?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gratuitiesUpdateWithoutServicesInput = {
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gratuitiesUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type gratuitiesUncheckedUpdateManyWithoutGratuitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    percentage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hourly_servicesUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: StringFieldUpdateOperationsInput | string
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    num_service_hours?: IntFieldUpdateOperationsInput | number
    dropoff_location?: StringFieldUpdateOperationsInput | string
    add_another_stop?: BoolFieldUpdateOperationsInput | boolean
    additional_comments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hourly_servicesUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: StringFieldUpdateOperationsInput | string
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    num_service_hours?: IntFieldUpdateOperationsInput | number
    dropoff_location?: StringFieldUpdateOperationsInput | string
    add_another_stop?: BoolFieldUpdateOperationsInput | boolean
    additional_comments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hourly_servicesUncheckedUpdateManyWithoutHourly_servicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: StringFieldUpdateOperationsInput | string
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    num_service_hours?: IntFieldUpdateOperationsInput | number
    dropoff_location?: StringFieldUpdateOperationsInput | string
    add_another_stop?: BoolFieldUpdateOperationsInput | boolean
    additional_comments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type point_to_point_servicesUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: StringFieldUpdateOperationsInput | string
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    dropoff_location?: StringFieldUpdateOperationsInput | string
    add_another_stop?: BoolFieldUpdateOperationsInput | boolean
    additional_comments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    pick_up_lat?: StringFieldUpdateOperationsInput | string
    pick_up_lon?: StringFieldUpdateOperationsInput | string
    drop_off_lat?: StringFieldUpdateOperationsInput | string
    drop_off_lon?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type point_to_point_servicesUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: StringFieldUpdateOperationsInput | string
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    dropoff_location?: StringFieldUpdateOperationsInput | string
    add_another_stop?: BoolFieldUpdateOperationsInput | boolean
    additional_comments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    pick_up_lat?: StringFieldUpdateOperationsInput | string
    pick_up_lon?: StringFieldUpdateOperationsInput | string
    drop_off_lat?: StringFieldUpdateOperationsInput | string
    drop_off_lon?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type point_to_point_servicesUncheckedUpdateManyWithoutPoint_to_point_servicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: StringFieldUpdateOperationsInput | string
    pickup_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    num_passengers?: IntFieldUpdateOperationsInput | number
    dropoff_location?: StringFieldUpdateOperationsInput | string
    add_another_stop?: BoolFieldUpdateOperationsInput | boolean
    additional_comments?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    pick_up_lat?: StringFieldUpdateOperationsInput | string
    pick_up_lon?: StringFieldUpdateOperationsInput | string
    drop_off_lat?: StringFieldUpdateOperationsInput | string
    drop_off_lon?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sub_servicesUpdateWithoutServicesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    passenger_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    reservations?: reservationsUpdateManyWithoutSub_servicesNestedInput
    cars?: carsUpdateOneWithoutSub_servicesNestedInput
    timeslots?: timeslotsUpdateManyWithoutSub_servicesNestedInput
  }

  export type sub_servicesUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pickup_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoff_lng?: NullableFloatFieldUpdateOperationsInput | number | null
    price_per_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    luggage?: NullableIntFieldUpdateOperationsInput | number | null
    passenger_capacity?: NullableIntFieldUpdateOperationsInput | number | null
    reservations?: reservationsUncheckedUpdateManyWithoutSub_servicesNestedInput
    timeslots?: timeslotsUncheckedUpdateManyWithoutSub_servicesNestedInput
  }

  export type carsCreateManyTransmissionsInput = {
    id?: number
    body_type_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    vehicle_type_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
  }

  export type carsUpdateWithoutTransmissionsInput = {
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUpdateManyWithoutCarsNestedInput
    body_types?: body_typesUpdateOneRequiredWithoutCarsNestedInput
    drivers?: driversUpdateOneRequiredWithoutCarsNestedInput
    fuel_types?: fuel_typesUpdateOneRequiredWithoutCarsNestedInput
    manufacturers?: manufacturersUpdateOneRequiredWithoutCarsNestedInput
    vehicle_types?: vehicle_typesUpdateOneRequiredWithoutCarsNestedInput
    package_serivce?: package_serivceUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUpdateManyWithoutCarsNestedInput
    slabs?: slabsUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUpdateManyWithoutCarsNestedInput
    tours?: toursUpdateManyWithoutCarsNestedInput
  }

  export type carsUncheckedUpdateWithoutTransmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type_id?: IntFieldUpdateOperationsInput | number
    manufacturer_id?: IntFieldUpdateOperationsInput | number
    driver_id?: IntFieldUpdateOperationsInput | number
    fuel_id?: IntFieldUpdateOperationsInput | number
    vehicle_type_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUncheckedUpdateManyWithoutCarsNestedInput
    package_serivce?: package_serivceUncheckedUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUncheckedUpdateManyWithoutCarsNestedInput
    slabs?: slabsUncheckedUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutCarsNestedInput
    tours?: toursUncheckedUpdateManyWithoutCarsNestedInput
  }

  export type role_usersCreateManyUsersInput = {
    role_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type role_usersUpdateWithoutUsersInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles?: rolesUpdateOneRequiredWithoutRole_usersNestedInput
  }

  export type role_usersUncheckedUpdateWithoutUsersInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type carsCreateManyVehicle_typesInput = {
    id?: number
    body_type_id: number
    transmission_id: number
    manufacturer_id: number
    driver_id: number
    fuel_id: number
    car_model?: string | null
    name?: string | null
    qty?: string | null
    passenger_seats?: number | null
    maximum_luggage?: number | null
    total_doors?: number | null
    child_seat?: number | null
    image?: string | null
    status?: boolean | null
    per_mile_rate?: number | null
    hourly_rate?: number | null
    minimum_fare?: number | null
    minimum_hours?: number | null
    fixed_price?: number | null
    is_slab_enabled?: boolean | null
    is_loc_enabled?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    isActive?: boolean | null
    car_type?: cars_car_type | null
  }

  export type carsUpdateWithoutVehicle_typesInput = {
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUpdateManyWithoutCarsNestedInput
    body_types?: body_typesUpdateOneRequiredWithoutCarsNestedInput
    drivers?: driversUpdateOneRequiredWithoutCarsNestedInput
    fuel_types?: fuel_typesUpdateOneRequiredWithoutCarsNestedInput
    manufacturers?: manufacturersUpdateOneRequiredWithoutCarsNestedInput
    transmissions?: transmissionsUpdateOneRequiredWithoutCarsNestedInput
    package_serivce?: package_serivceUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUpdateManyWithoutCarsNestedInput
    slabs?: slabsUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUpdateManyWithoutCarsNestedInput
    tours?: toursUpdateManyWithoutCarsNestedInput
  }

  export type carsUncheckedUpdateWithoutVehicle_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    body_type_id?: IntFieldUpdateOperationsInput | number
    transmission_id?: IntFieldUpdateOperationsInput | number
    manufacturer_id?: IntFieldUpdateOperationsInput | number
    driver_id?: IntFieldUpdateOperationsInput | number
    fuel_id?: IntFieldUpdateOperationsInput | number
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    passenger_seats?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    total_doors?: NullableIntFieldUpdateOperationsInput | number | null
    child_seat?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    per_mile_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    hourly_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    minimum_hours?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_slab_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_loc_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    car_type?: NullableEnumcars_car_typeFieldUpdateOperationsInput | cars_car_type | null
    car_prices?: car_pricesUncheckedUpdateManyWithoutCarsNestedInput
    package_serivce?: package_serivceUncheckedUpdateManyWithoutCarsNestedInput
    reservations?: reservationsUncheckedUpdateManyWithoutCarsNestedInput
    slabs?: slabsUncheckedUpdateManyWithoutCarsNestedInput
    sub_services?: sub_servicesUncheckedUpdateManyWithoutCarsNestedInput
    tours?: toursUncheckedUpdateManyWithoutCarsNestedInput
  }

  export type reservationsCreateManySub_servicesInput = {
    id?: number
    order_number?: string | null
    car_id: number
    pick_up_postal_code?: string | null
    pick_up_lat?: number | null
    pick_up_lon?: number | null
    pick_up_loc_name?: string | null
    drop_off_postal_code?: string | null
    drop_off_lat?: number | null
    drop_off_lon?: number | null
    drop_off_loc_name?: string | null
    pick_up_date?: Date | string | null
    price?: number | null
    tax?: number | null
    airline?: string | null
    flight_no?: string | null
    no_of_hours?: number | null
    maximum_passenger?: number | null
    maximum_luggage?: number | null
    customer_first_name?: string | null
    customer_last_name?: string | null
    customer_cnic?: string | null
    customer_email?: string | null
    customer_phone?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    uuid?: string
    payment_method?: string | null
    isPaid?: number | null
    special_instruction?: string | null
  }

  export type timeslotsCreateManySub_servicesInput = {
    id?: number
    time?: Date | string | null
    isActive?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type reservationsUpdateWithoutSub_servicesInput = {
    order_number?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_no?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_hours?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    customer_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_cnic?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: NullableIntFieldUpdateOperationsInput | number | null
    special_instruction?: NullableStringFieldUpdateOperationsInput | string | null
    cars?: carsUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type reservationsUncheckedUpdateWithoutSub_servicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_number?: NullableStringFieldUpdateOperationsInput | string | null
    car_id?: IntFieldUpdateOperationsInput | number
    pick_up_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    pick_up_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    drop_off_lat?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_lon?: NullableFloatFieldUpdateOperationsInput | number | null
    drop_off_loc_name?: NullableStringFieldUpdateOperationsInput | string | null
    pick_up_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    flight_no?: NullableStringFieldUpdateOperationsInput | string | null
    no_of_hours?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_passenger?: NullableIntFieldUpdateOperationsInput | number | null
    maximum_luggage?: NullableIntFieldUpdateOperationsInput | number | null
    customer_first_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_last_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_cnic?: NullableStringFieldUpdateOperationsInput | string | null
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: NullableIntFieldUpdateOperationsInput | number | null
    special_instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type timeslotsUpdateWithoutSub_servicesInput = {
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type timeslotsUncheckedUpdateWithoutSub_servicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type timeslotsUncheckedUpdateManyWithoutTimeslotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}